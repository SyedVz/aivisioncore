#************************************************************
#   Copyright (C) 2023 OSS Nokalva, Inc.  All rights reserved.
#************************************************************

#   THIS FILE IS PROPRIETARY MATERIAL OF OSS NOKALVA, INC.
#   AND MAY BE USED AND DISTRIBUTED ONLY BY DIRECT LICENSEES OF OSS NOKALVA, INC.
#   THIS COPYRIGHT STATEMENT MAY NOT BE REMOVED.

#   Python 3.7 or higher is required!

#   This file was generated for 'Syed Kamal' by 'https://asn1.io/ASN1-Python-Compiler/' at '5/1/2024 2:38:08 PM'

from warnings import warn
from typing import Union, Any
import datetime as dt
import private.osspy_per as osspy
from private.ossvalidate import Asn1Type, validate_value_type, validate_value, report_empty_value, report_missing_field, report_extra_field

class MessageFrame:
    def __init__(self):
        self._comp_types = {"messageId" : MessageFrame__1, "value" : MessageFrame__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.MessageFrame"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = MessageFrame()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'messageId' in value:
            MessageFrame__1.encode(encoding_rule, value['messageId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'value' in value:
            MessageFrame__2.encode(encoding_rule, value['value'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = MessageFrame()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['messageId'] = MessageFrame__1.decode(encoding_rule, stream, value_tracker)
        value['value'] = MessageFrame__2.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = MessageFrame()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'messageId' in value:
            MessageFrame__1.validate(value['messageId'], errors, '{}/{}'.format(comp_path ,'messageId'))
        elif 'messageId' not in value:
            report_missing_field(type(self).__name__, 'messageId', errors, comp_path)
        if 'value' in value:
            MessageFrame__2.validate(value['value'], errors, '{}/{}'.format(comp_path ,'value'))
        elif 'value' not in value:
            report_missing_field(type(self).__name__, 'value', errors, comp_path)

        return errors

class MessageFrame__1:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "{MessageTypes}","permitted":[(0,32767)]}},{"type":"simple table constraint","isExtensible": True,"fields":{"type":"constraint union","constraints":[{"type":"single value","permitted": 20},{"type":"single value","permitted": 18},{"type":"single value","permitted": 19},{"type":"single value","permitted": 21},{"type":"single value","permitted": 22},{"type":"single value","permitted": 23},{"type":"single value","permitted": 24},{"type":"single value","permitted": 25},{"type":"single value","permitted": 26},{"type":"single value","permitted": 27},{"type":"single value","permitted": 28},{"type":"single value","permitted": 29},{"type":"single value","permitted": 30},{"type":"single value","permitted": 31},{"type":"single value","permitted": 32},{"type":"single value","permitted": 240},{"type":"single value","permitted": 241},{"type":"single value","permitted": 242},{"type":"single value","permitted": 243},{"type":"single value","permitted": 244}]}}]
        self._unique_indetifier = "DSRC.MessageFrame.messageId"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = MessageFrame__1()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 32767

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = MessageFrame__1()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 32767

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = MessageFrame__1()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class MessageFrame__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.MessageFrame.value"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = MessageFrame__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["messageId"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded and value is not None and value_tracker.are_equivalent([20], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                BasicSafetyMessage.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([18], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                MapData.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([19], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                SPAT.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([21], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                CommonSafetyRequest.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([22], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                EmergencyVehicleAlert.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([23], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                IntersectionCollision.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([24], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                NMEAcorrections.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([25], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                ProbeDataManagement.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([26], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                ProbeVehicleData.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([27], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                RoadSideAlert.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([28], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                RTCMcorrections.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([29], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                SignalRequestMessage.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([30], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                SignalStatusMessage.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([31], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                TravelerInformation.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([32], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                PersonalSafetyMessage.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([240], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                SignalAheadMessage.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([241], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                DataRequestMessage.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([242], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                DataRequestResponse.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([243], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                StatusMessage.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([244], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                DisconnectMessage.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = MessageFrame__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["messageId"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            if (not is_decoded and value_tracker.are_equivalent([20], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = BasicSafetyMessage.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([18], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = MapData.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([19], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = SPAT.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([21], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = CommonSafetyRequest.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([22], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = EmergencyVehicleAlert.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([23], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = IntersectionCollision.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([24], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = NMEAcorrections.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([25], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = ProbeDataManagement.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([26], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = ProbeVehicleData.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([27], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = RoadSideAlert.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([28], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = RTCMcorrections.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([29], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = SignalRequestMessage.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([30], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = SignalStatusMessage.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([31], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = TravelerInformation.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([32], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = PersonalSafetyMessage.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([240], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = SignalAheadMessage.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([241], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = DataRequestMessage.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([242], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = DataRequestResponse.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([243], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = StatusMessage.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([244], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = DisconnectMessage.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = MessageFrame__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class BasicSafetyMessage:
    def __init__(self):
        self._comp_types = {"coreData" : BSMcoreData, "partII" : BasicSafetyMessage__3, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.BasicSafetyMessage"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = BasicSafetyMessage()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('partII' in value and 'partII' not in self._def_vals):
            preamble_bits[0] = True
        elif ('partII' in value and 'partII' in self._def_vals):
            if not value_tracker.are_def_eq(value['partII'], self._def_vals['partII'], self._comp_types['partII']):
                preamble_bits[0] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[1] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'coreData' in value:
            BSMcoreData.encode(encoding_rule, value['coreData'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            BasicSafetyMessage__3.encode(encoding_rule, value['partII'], value_tracker, stream)
        if preamble_bits[2]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = BasicSafetyMessage()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['coreData'] = BSMcoreData.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['partII'] = BasicSafetyMessage__3.decode(encoding_rule, stream, value_tracker)
        elif 'partII' in self._def_vals:
            value['partII'] = self._def_vals['partII']
        if preamble_bits[2]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = BasicSafetyMessage()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'coreData' in value:
            BSMcoreData.validate(value['coreData'], errors, '{}/{}'.format(comp_path ,'coreData'))
        elif 'coreData' not in value:
            report_missing_field(type(self).__name__, 'coreData', errors, comp_path)
        if 'partII' in value:
            BasicSafetyMessage__3.validate(value['partII'], errors, '{}/{}'.format(comp_path ,'partII'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class BasicSafetyMessage__3:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,8)]}}]
        self._unique_indetifier = "DSRC.BasicSafetyMessage.partII"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                PartIIcontent_1.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                PartIIcontent_1.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(PartIIcontent_1.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = BasicSafetyMessage__3()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(PartIIcontent_1.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = BasicSafetyMessage__3()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = BasicSafetyMessage__3()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                PartIIcontent_1.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class PartII_Id:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..63","permitted":[(0,63)]}}]
        self._unique_indetifier = "DSRC.PartII-Id"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = PartII_Id()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 63

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = PartII_Id()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 63

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = PartII_Id()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class CommonSafetyRequest:
    def __init__(self):
        self._comp_types = {"timeStamp" : MinuteOfTheYear, "msgCnt" : BumperHeight, "id" : TemporaryID, "requests" : RequestedItemList, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.CommonSafetyRequest"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = CommonSafetyRequest()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('msgCnt' in value and 'msgCnt' not in self._def_vals):
            preamble_bits[1] = True
        elif ('msgCnt' in value and 'msgCnt' in self._def_vals):
            if not value_tracker.are_def_eq(value['msgCnt'], self._def_vals['msgCnt'], self._comp_types['msgCnt']):
                preamble_bits[1] = True
        if ('id' in value and 'id' not in self._def_vals):
            preamble_bits[2] = True
        elif ('id' in value and 'id' in self._def_vals):
            if not value_tracker.are_def_eq(value['id'], self._def_vals['id'], self._comp_types['id']):
                preamble_bits[2] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[3] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if preamble_bits[2]:
            BumperHeight.encode(encoding_rule, value['msgCnt'], value_tracker, stream)
        if preamble_bits[3]:
            TemporaryID.encode(encoding_rule, value['id'], value_tracker, stream)
        if 'requests' in value:
            RequestedItemList.encode(encoding_rule, value['requests'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[4]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = CommonSafetyRequest()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        if preamble_bits[2]:
            value['msgCnt'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        elif 'msgCnt' in self._def_vals:
            value['msgCnt'] = self._def_vals['msgCnt']
        if preamble_bits[3]:
            value['id'] = TemporaryID.decode(encoding_rule, stream, value_tracker)
        elif 'id' in self._def_vals:
            value['id'] = self._def_vals['id']
        value['requests'] = RequestedItemList.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[4]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = CommonSafetyRequest()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'msgCnt' in value:
            BumperHeight.validate(value['msgCnt'], errors, '{}/{}'.format(comp_path ,'msgCnt'))
        if 'id' in value:
            TemporaryID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        if 'requests' in value:
            RequestedItemList.validate(value['requests'], errors, '{}/{}'.format(comp_path ,'requests'))
        elif 'requests' not in value:
            report_missing_field(type(self).__name__, 'requests', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class EmergencyVehicleAlert:
    def __init__(self):
        self._comp_types = {"timeStamp" : MinuteOfTheYear, "id" : TemporaryID, "rsaMsg" : RoadSideAlert, "responseType" : ResponseType, "details" : EmergencyDetails, "mass" : AmbientAirPressure, "basicType" : VehicleType, "vehicleType" : VehicleGroupAffected, "responseEquip" : IncidentResponseEquipment, "responderType" : ResponderGroupAffected, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.EmergencyVehicleAlert"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = EmergencyVehicleAlert()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 10

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('id' in value and 'id' not in self._def_vals):
            preamble_bits[1] = True
        elif ('id' in value and 'id' in self._def_vals):
            if not value_tracker.are_def_eq(value['id'], self._def_vals['id'], self._comp_types['id']):
                preamble_bits[1] = True
        if ('responseType' in value and 'responseType' not in self._def_vals):
            preamble_bits[2] = True
        elif ('responseType' in value and 'responseType' in self._def_vals):
            if not value_tracker.are_def_eq(value['responseType'], self._def_vals['responseType'], self._comp_types['responseType']):
                preamble_bits[2] = True
        if ('details' in value and 'details' not in self._def_vals):
            preamble_bits[3] = True
        elif ('details' in value and 'details' in self._def_vals):
            if not value_tracker.are_def_eq(value['details'], self._def_vals['details'], self._comp_types['details']):
                preamble_bits[3] = True
        if ('mass' in value and 'mass' not in self._def_vals):
            preamble_bits[4] = True
        elif ('mass' in value and 'mass' in self._def_vals):
            if not value_tracker.are_def_eq(value['mass'], self._def_vals['mass'], self._comp_types['mass']):
                preamble_bits[4] = True
        if ('basicType' in value and 'basicType' not in self._def_vals):
            preamble_bits[5] = True
        elif ('basicType' in value and 'basicType' in self._def_vals):
            if not value_tracker.are_def_eq(value['basicType'], self._def_vals['basicType'], self._comp_types['basicType']):
                preamble_bits[5] = True
        if ('vehicleType' in value and 'vehicleType' not in self._def_vals):
            preamble_bits[6] = True
        elif ('vehicleType' in value and 'vehicleType' in self._def_vals):
            if not value_tracker.are_def_eq(value['vehicleType'], self._def_vals['vehicleType'], self._comp_types['vehicleType']):
                preamble_bits[6] = True
        if ('responseEquip' in value and 'responseEquip' not in self._def_vals):
            preamble_bits[7] = True
        elif ('responseEquip' in value and 'responseEquip' in self._def_vals):
            if not value_tracker.are_def_eq(value['responseEquip'], self._def_vals['responseEquip'], self._comp_types['responseEquip']):
                preamble_bits[7] = True
        if ('responderType' in value and 'responderType' not in self._def_vals):
            preamble_bits[8] = True
        elif ('responderType' in value and 'responderType' in self._def_vals):
            if not value_tracker.are_def_eq(value['responderType'], self._def_vals['responderType'], self._comp_types['responderType']):
                preamble_bits[8] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[9] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[9] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if preamble_bits[2]:
            TemporaryID.encode(encoding_rule, value['id'], value_tracker, stream)
        if 'rsaMsg' in value:
            RoadSideAlert.encode(encoding_rule, value['rsaMsg'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[3]:
            ResponseType.encode(encoding_rule, value['responseType'], value_tracker, stream)
        if preamble_bits[4]:
            EmergencyDetails.encode(encoding_rule, value['details'], value_tracker, stream)
        if preamble_bits[5]:
            AmbientAirPressure.encode(encoding_rule, value['mass'], value_tracker, stream)
        if preamble_bits[6]:
            VehicleType.encode(encoding_rule, value['basicType'], value_tracker, stream)
        if preamble_bits[7]:
            VehicleGroupAffected.encode(encoding_rule, value['vehicleType'], value_tracker, stream)
        if preamble_bits[8]:
            IncidentResponseEquipment.encode(encoding_rule, value['responseEquip'], value_tracker, stream)
        if preamble_bits[9]:
            ResponderGroupAffected.encode(encoding_rule, value['responderType'], value_tracker, stream)
        if preamble_bits[10]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = EmergencyVehicleAlert()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 10

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        if preamble_bits[2]:
            value['id'] = TemporaryID.decode(encoding_rule, stream, value_tracker)
        elif 'id' in self._def_vals:
            value['id'] = self._def_vals['id']
        value['rsaMsg'] = RoadSideAlert.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[3]:
            value['responseType'] = ResponseType.decode(encoding_rule, stream, value_tracker)
        elif 'responseType' in self._def_vals:
            value['responseType'] = self._def_vals['responseType']
        if preamble_bits[4]:
            value['details'] = EmergencyDetails.decode(encoding_rule, stream, value_tracker)
        elif 'details' in self._def_vals:
            value['details'] = self._def_vals['details']
        if preamble_bits[5]:
            value['mass'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'mass' in self._def_vals:
            value['mass'] = self._def_vals['mass']
        if preamble_bits[6]:
            value['basicType'] = VehicleType.decode(encoding_rule, stream, value_tracker)
        elif 'basicType' in self._def_vals:
            value['basicType'] = self._def_vals['basicType']
        if preamble_bits[7]:
            value['vehicleType'] = VehicleGroupAffected.decode(encoding_rule, stream, value_tracker)
        elif 'vehicleType' in self._def_vals:
            value['vehicleType'] = self._def_vals['vehicleType']
        if preamble_bits[8]:
            value['responseEquip'] = IncidentResponseEquipment.decode(encoding_rule, stream, value_tracker)
        elif 'responseEquip' in self._def_vals:
            value['responseEquip'] = self._def_vals['responseEquip']
        if preamble_bits[9]:
            value['responderType'] = ResponderGroupAffected.decode(encoding_rule, stream, value_tracker)
        elif 'responderType' in self._def_vals:
            value['responderType'] = self._def_vals['responderType']
        if preamble_bits[10]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = EmergencyVehicleAlert()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'id' in value:
            TemporaryID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        if 'rsaMsg' in value:
            RoadSideAlert.validate(value['rsaMsg'], errors, '{}/{}'.format(comp_path ,'rsaMsg'))
        elif 'rsaMsg' not in value:
            report_missing_field(type(self).__name__, 'rsaMsg', errors, comp_path)
        if 'responseType' in value:
            ResponseType.validate(value['responseType'], errors, '{}/{}'.format(comp_path ,'responseType'))
        if 'details' in value:
            EmergencyDetails.validate(value['details'], errors, '{}/{}'.format(comp_path ,'details'))
        if 'mass' in value:
            AmbientAirPressure.validate(value['mass'], errors, '{}/{}'.format(comp_path ,'mass'))
        if 'basicType' in value:
            VehicleType.validate(value['basicType'], errors, '{}/{}'.format(comp_path ,'basicType'))
        if 'vehicleType' in value:
            VehicleGroupAffected.validate(value['vehicleType'], errors, '{}/{}'.format(comp_path ,'vehicleType'))
        if 'responseEquip' in value:
            IncidentResponseEquipment.validate(value['responseEquip'], errors, '{}/{}'.format(comp_path ,'responseEquip'))
        if 'responderType' in value:
            ResponderGroupAffected.validate(value['responderType'], errors, '{}/{}'.format(comp_path ,'responderType'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class IntersectionCollision:
    def __init__(self):
        self._comp_types = {"msgCnt" : BumperHeight, "id" : TemporaryID, "timeStamp" : MinuteOfTheYear, "partOne" : BSMcoreData, "path" : PathHistory, "pathPrediction" : PathPrediction, "intersectionID" : IntersectionReferenceID, "laneNumber" : ApproachOrLane, "eventFlag" : VehicleEventFlags, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.IntersectionCollision"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = IntersectionCollision()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('partOne' in value and 'partOne' not in self._def_vals):
            preamble_bits[1] = True
        elif ('partOne' in value and 'partOne' in self._def_vals):
            if not value_tracker.are_def_eq(value['partOne'], self._def_vals['partOne'], self._comp_types['partOne']):
                preamble_bits[1] = True
        if ('path' in value and 'path' not in self._def_vals):
            preamble_bits[2] = True
        elif ('path' in value and 'path' in self._def_vals):
            if not value_tracker.are_def_eq(value['path'], self._def_vals['path'], self._comp_types['path']):
                preamble_bits[2] = True
        if ('pathPrediction' in value and 'pathPrediction' not in self._def_vals):
            preamble_bits[3] = True
        elif ('pathPrediction' in value and 'pathPrediction' in self._def_vals):
            if not value_tracker.are_def_eq(value['pathPrediction'], self._def_vals['pathPrediction'], self._comp_types['pathPrediction']):
                preamble_bits[3] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[4] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[4] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'msgCnt' in value:
            BumperHeight.encode(encoding_rule, value['msgCnt'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'id' in value:
            TemporaryID.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if preamble_bits[2]:
            BSMcoreData.encode(encoding_rule, value['partOne'], value_tracker, stream)
        if preamble_bits[3]:
            PathHistory.encode(encoding_rule, value['path'], value_tracker, stream)
        if preamble_bits[4]:
            PathPrediction.encode(encoding_rule, value['pathPrediction'], value_tracker, stream)
        if 'intersectionID' in value:
            IntersectionReferenceID.encode(encoding_rule, value['intersectionID'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'laneNumber' in value:
            ApproachOrLane.encode(encoding_rule, value['laneNumber'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'eventFlag' in value:
            VehicleEventFlags.encode(encoding_rule, value['eventFlag'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[5]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = IntersectionCollision()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['msgCnt'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        value['id'] = TemporaryID.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        if preamble_bits[2]:
            value['partOne'] = BSMcoreData.decode(encoding_rule, stream, value_tracker)
        elif 'partOne' in self._def_vals:
            value['partOne'] = self._def_vals['partOne']
        if preamble_bits[3]:
            value['path'] = PathHistory.decode(encoding_rule, stream, value_tracker)
        elif 'path' in self._def_vals:
            value['path'] = self._def_vals['path']
        if preamble_bits[4]:
            value['pathPrediction'] = PathPrediction.decode(encoding_rule, stream, value_tracker)
        elif 'pathPrediction' in self._def_vals:
            value['pathPrediction'] = self._def_vals['pathPrediction']
        value['intersectionID'] = IntersectionReferenceID.decode(encoding_rule, stream, value_tracker)
        value['laneNumber'] = ApproachOrLane.decode(encoding_rule, stream, value_tracker)
        value['eventFlag'] = VehicleEventFlags.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[5]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = IntersectionCollision()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'msgCnt' in value:
            BumperHeight.validate(value['msgCnt'], errors, '{}/{}'.format(comp_path ,'msgCnt'))
        elif 'msgCnt' not in value:
            report_missing_field(type(self).__name__, 'msgCnt', errors, comp_path)
        if 'id' in value:
            TemporaryID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'partOne' in value:
            BSMcoreData.validate(value['partOne'], errors, '{}/{}'.format(comp_path ,'partOne'))
        if 'path' in value:
            PathHistory.validate(value['path'], errors, '{}/{}'.format(comp_path ,'path'))
        if 'pathPrediction' in value:
            PathPrediction.validate(value['pathPrediction'], errors, '{}/{}'.format(comp_path ,'pathPrediction'))
        if 'intersectionID' in value:
            IntersectionReferenceID.validate(value['intersectionID'], errors, '{}/{}'.format(comp_path ,'intersectionID'))
        elif 'intersectionID' not in value:
            report_missing_field(type(self).__name__, 'intersectionID', errors, comp_path)
        if 'laneNumber' in value:
            ApproachOrLane.validate(value['laneNumber'], errors, '{}/{}'.format(comp_path ,'laneNumber'))
        elif 'laneNumber' not in value:
            report_missing_field(type(self).__name__, 'laneNumber', errors, comp_path)
        if 'eventFlag' in value:
            VehicleEventFlags.validate(value['eventFlag'], errors, '{}/{}'.format(comp_path ,'eventFlag'))
        elif 'eventFlag' not in value:
            report_missing_field(type(self).__name__, 'eventFlag', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class MapData:
    def __init__(self):
        self._comp_types = {"timeStamp" : MinuteOfTheYear, "msgIssueRevision" : BumperHeight, "layerType" : LayerType, "layerID" : Iso3833VehicleType, "intersections" : IntersectionGeometryList, "roadSegments" : RoadSegmentList, "dataParameters" : DataParameters, "restrictionList" : RestrictionClassList, "regional" : MapData__10}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.MapData"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = MapData()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 8

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('layerType' in value and 'layerType' not in self._def_vals):
            preamble_bits[1] = True
        elif ('layerType' in value and 'layerType' in self._def_vals):
            if not value_tracker.are_def_eq(value['layerType'], self._def_vals['layerType'], self._comp_types['layerType']):
                preamble_bits[1] = True
        if ('layerID' in value and 'layerID' not in self._def_vals):
            preamble_bits[2] = True
        elif ('layerID' in value and 'layerID' in self._def_vals):
            if not value_tracker.are_def_eq(value['layerID'], self._def_vals['layerID'], self._comp_types['layerID']):
                preamble_bits[2] = True
        if ('intersections' in value and 'intersections' not in self._def_vals):
            preamble_bits[3] = True
        elif ('intersections' in value and 'intersections' in self._def_vals):
            if not value_tracker.are_def_eq(value['intersections'], self._def_vals['intersections'], self._comp_types['intersections']):
                preamble_bits[3] = True
        if ('roadSegments' in value and 'roadSegments' not in self._def_vals):
            preamble_bits[4] = True
        elif ('roadSegments' in value and 'roadSegments' in self._def_vals):
            if not value_tracker.are_def_eq(value['roadSegments'], self._def_vals['roadSegments'], self._comp_types['roadSegments']):
                preamble_bits[4] = True
        if ('dataParameters' in value and 'dataParameters' not in self._def_vals):
            preamble_bits[5] = True
        elif ('dataParameters' in value and 'dataParameters' in self._def_vals):
            if not value_tracker.are_def_eq(value['dataParameters'], self._def_vals['dataParameters'], self._comp_types['dataParameters']):
                preamble_bits[5] = True
        if ('restrictionList' in value and 'restrictionList' not in self._def_vals):
            preamble_bits[6] = True
        elif ('restrictionList' in value and 'restrictionList' in self._def_vals):
            if not value_tracker.are_def_eq(value['restrictionList'], self._def_vals['restrictionList'], self._comp_types['restrictionList']):
                preamble_bits[6] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[7] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[7] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if 'msgIssueRevision' in value:
            BumperHeight.encode(encoding_rule, value['msgIssueRevision'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            LayerType.encode(encoding_rule, value['layerType'], value_tracker, stream)
        if preamble_bits[3]:
            Iso3833VehicleType.encode(encoding_rule, value['layerID'], value_tracker, stream)
        if preamble_bits[4]:
            IntersectionGeometryList.encode(encoding_rule, value['intersections'], value_tracker, stream)
        if preamble_bits[5]:
            RoadSegmentList.encode(encoding_rule, value['roadSegments'], value_tracker, stream)
        if preamble_bits[6]:
            DataParameters.encode(encoding_rule, value['dataParameters'], value_tracker, stream)
        if preamble_bits[7]:
            RestrictionClassList.encode(encoding_rule, value['restrictionList'], value_tracker, stream)
        if preamble_bits[8]:
            MapData__10.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = MapData()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 8

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        value['msgIssueRevision'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['layerType'] = LayerType.decode(encoding_rule, stream, value_tracker)
        elif 'layerType' in self._def_vals:
            value['layerType'] = self._def_vals['layerType']
        if preamble_bits[3]:
            value['layerID'] = Iso3833VehicleType.decode(encoding_rule, stream, value_tracker)
        elif 'layerID' in self._def_vals:
            value['layerID'] = self._def_vals['layerID']
        if preamble_bits[4]:
            value['intersections'] = IntersectionGeometryList.decode(encoding_rule, stream, value_tracker)
        elif 'intersections' in self._def_vals:
            value['intersections'] = self._def_vals['intersections']
        if preamble_bits[5]:
            value['roadSegments'] = RoadSegmentList.decode(encoding_rule, stream, value_tracker)
        elif 'roadSegments' in self._def_vals:
            value['roadSegments'] = self._def_vals['roadSegments']
        if preamble_bits[6]:
            value['dataParameters'] = DataParameters.decode(encoding_rule, stream, value_tracker)
        elif 'dataParameters' in self._def_vals:
            value['dataParameters'] = self._def_vals['dataParameters']
        if preamble_bits[7]:
            value['restrictionList'] = RestrictionClassList.decode(encoding_rule, stream, value_tracker)
        elif 'restrictionList' in self._def_vals:
            value['restrictionList'] = self._def_vals['restrictionList']
        if preamble_bits[8]:
            value['regional'] = MapData__10.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = MapData()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'msgIssueRevision' in value:
            BumperHeight.validate(value['msgIssueRevision'], errors, '{}/{}'.format(comp_path ,'msgIssueRevision'))
        elif 'msgIssueRevision' not in value:
            report_missing_field(type(self).__name__, 'msgIssueRevision', errors, comp_path)
        if 'layerType' in value:
            LayerType.validate(value['layerType'], errors, '{}/{}'.format(comp_path ,'layerType'))
        if 'layerID' in value:
            Iso3833VehicleType.validate(value['layerID'], errors, '{}/{}'.format(comp_path ,'layerID'))
        if 'intersections' in value:
            IntersectionGeometryList.validate(value['intersections'], errors, '{}/{}'.format(comp_path ,'intersections'))
        if 'roadSegments' in value:
            RoadSegmentList.validate(value['roadSegments'], errors, '{}/{}'.format(comp_path ,'roadSegments'))
        if 'dataParameters' in value:
            DataParameters.validate(value['dataParameters'], errors, '{}/{}'.format(comp_path ,'dataParameters'))
        if 'restrictionList' in value:
            RestrictionClassList.validate(value['restrictionList'], errors, '{}/{}'.format(comp_path ,'restrictionList'))
        if 'regional' in value:
            MapData__10.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class MapData__10:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,4)]}}]
        self._unique_indetifier = "DSRC.MapData.regional"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RegionalExtension_5.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RegionalExtension_5.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RegionalExtension_5.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = MapData__10()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RegionalExtension_5.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = MapData__10()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = MapData__10()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RegionalExtension_5.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class NMEAcorrections:
    def __init__(self):
        self._comp_types = {"timeStamp" : MinuteOfTheYear, "rev" : NMEA_Revision, "msg" : DSRCmsgID, "wdCount" : GrossDistance, "payload" : NMEA_Payload, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.NMEAcorrections"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = NMEAcorrections()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('rev' in value and 'rev' not in self._def_vals):
            preamble_bits[1] = True
        elif ('rev' in value and 'rev' in self._def_vals):
            if not value_tracker.are_def_eq(value['rev'], self._def_vals['rev'], self._comp_types['rev']):
                preamble_bits[1] = True
        if ('msg' in value and 'msg' not in self._def_vals):
            preamble_bits[2] = True
        elif ('msg' in value and 'msg' in self._def_vals):
            if not value_tracker.are_def_eq(value['msg'], self._def_vals['msg'], self._comp_types['msg']):
                preamble_bits[2] = True
        if ('wdCount' in value and 'wdCount' not in self._def_vals):
            preamble_bits[3] = True
        elif ('wdCount' in value and 'wdCount' in self._def_vals):
            if not value_tracker.are_def_eq(value['wdCount'], self._def_vals['wdCount'], self._comp_types['wdCount']):
                preamble_bits[3] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[4] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[4] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if preamble_bits[2]:
            NMEA_Revision.encode(encoding_rule, value['rev'], value_tracker, stream)
        if preamble_bits[3]:
            DSRCmsgID.encode(encoding_rule, value['msg'], value_tracker, stream)
        if preamble_bits[4]:
            GrossDistance.encode(encoding_rule, value['wdCount'], value_tracker, stream)
        if 'payload' in value:
            NMEA_Payload.encode(encoding_rule, value['payload'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[5]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = NMEAcorrections()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        if preamble_bits[2]:
            value['rev'] = NMEA_Revision.decode(encoding_rule, stream, value_tracker)
        elif 'rev' in self._def_vals:
            value['rev'] = self._def_vals['rev']
        if preamble_bits[3]:
            value['msg'] = DSRCmsgID.decode(encoding_rule, stream, value_tracker)
        elif 'msg' in self._def_vals:
            value['msg'] = self._def_vals['msg']
        if preamble_bits[4]:
            value['wdCount'] = GrossDistance.decode(encoding_rule, stream, value_tracker)
        elif 'wdCount' in self._def_vals:
            value['wdCount'] = self._def_vals['wdCount']
        value['payload'] = NMEA_Payload.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[5]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = NMEAcorrections()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'rev' in value:
            NMEA_Revision.validate(value['rev'], errors, '{}/{}'.format(comp_path ,'rev'))
        if 'msg' in value:
            DSRCmsgID.validate(value['msg'], errors, '{}/{}'.format(comp_path ,'msg'))
        if 'wdCount' in value:
            GrossDistance.validate(value['wdCount'], errors, '{}/{}'.format(comp_path ,'wdCount'))
        if 'payload' in value:
            NMEA_Payload.validate(value['payload'], errors, '{}/{}'.format(comp_path ,'payload'))
        elif 'payload' not in value:
            report_missing_field(type(self).__name__, 'payload', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class PersonalSafetyMessage:
    def __init__(self):
        self._comp_types = {"basicType" : PersonalDeviceUserType, "secMark" : DSecond, "msgCnt" : BumperHeight, "id" : TemporaryID, "position" : Position3D, "accuracy" : PositionalAccuracy, "speed" : Speed, "heading" : Angle, "accelSet" : AccelerationSet4Way, "pathHistory" : PathHistory, "pathPrediction" : PathPrediction, "propulsion" : PropelledInformation, "useState" : ExteriorLights, "crossRequest" : IsDolly, "crossState" : IsDolly, "clusterSize" : NumberOfParticipantsInCluster, "clusterRadius" : Iso3833VehicleType, "eventResponderType" : PublicSafetyEventResponderWorkerType, "activityType" : PersonalAssistive, "activitySubType" : PublicSafetyDirectingTrafficSubType, "assistType" : PersonalAssistive, "sizing" : UserSizeAndBehaviour, "attachment" : Attachment, "attachmentRadius" : AttachmentRadius, "animalType" : AnimalType, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.PersonalSafetyMessage"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = PersonalSafetyMessage()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 18

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('accelSet' in value and 'accelSet' not in self._def_vals):
            preamble_bits[0] = True
        elif ('accelSet' in value and 'accelSet' in self._def_vals):
            if not value_tracker.are_def_eq(value['accelSet'], self._def_vals['accelSet'], self._comp_types['accelSet']):
                preamble_bits[0] = True
        if ('pathHistory' in value and 'pathHistory' not in self._def_vals):
            preamble_bits[1] = True
        elif ('pathHistory' in value and 'pathHistory' in self._def_vals):
            if not value_tracker.are_def_eq(value['pathHistory'], self._def_vals['pathHistory'], self._comp_types['pathHistory']):
                preamble_bits[1] = True
        if ('pathPrediction' in value and 'pathPrediction' not in self._def_vals):
            preamble_bits[2] = True
        elif ('pathPrediction' in value and 'pathPrediction' in self._def_vals):
            if not value_tracker.are_def_eq(value['pathPrediction'], self._def_vals['pathPrediction'], self._comp_types['pathPrediction']):
                preamble_bits[2] = True
        if ('propulsion' in value and 'propulsion' not in self._def_vals):
            preamble_bits[3] = True
        elif ('propulsion' in value and 'propulsion' in self._def_vals):
            if not value_tracker.are_def_eq(value['propulsion'], self._def_vals['propulsion'], self._comp_types['propulsion']):
                preamble_bits[3] = True
        if ('useState' in value and 'useState' not in self._def_vals):
            preamble_bits[4] = True
        elif ('useState' in value and 'useState' in self._def_vals):
            if not value_tracker.are_def_eq(value['useState'], self._def_vals['useState'], self._comp_types['useState']):
                preamble_bits[4] = True
        if ('crossRequest' in value and 'crossRequest' not in self._def_vals):
            preamble_bits[5] = True
        elif ('crossRequest' in value and 'crossRequest' in self._def_vals):
            if not value_tracker.are_def_eq(value['crossRequest'], self._def_vals['crossRequest'], self._comp_types['crossRequest']):
                preamble_bits[5] = True
        if ('crossState' in value and 'crossState' not in self._def_vals):
            preamble_bits[6] = True
        elif ('crossState' in value and 'crossState' in self._def_vals):
            if not value_tracker.are_def_eq(value['crossState'], self._def_vals['crossState'], self._comp_types['crossState']):
                preamble_bits[6] = True
        if ('clusterSize' in value and 'clusterSize' not in self._def_vals):
            preamble_bits[7] = True
        elif ('clusterSize' in value and 'clusterSize' in self._def_vals):
            if not value_tracker.are_def_eq(value['clusterSize'], self._def_vals['clusterSize'], self._comp_types['clusterSize']):
                preamble_bits[7] = True
        if ('clusterRadius' in value and 'clusterRadius' not in self._def_vals):
            preamble_bits[8] = True
        elif ('clusterRadius' in value and 'clusterRadius' in self._def_vals):
            if not value_tracker.are_def_eq(value['clusterRadius'], self._def_vals['clusterRadius'], self._comp_types['clusterRadius']):
                preamble_bits[8] = True
        if ('eventResponderType' in value and 'eventResponderType' not in self._def_vals):
            preamble_bits[9] = True
        elif ('eventResponderType' in value and 'eventResponderType' in self._def_vals):
            if not value_tracker.are_def_eq(value['eventResponderType'], self._def_vals['eventResponderType'], self._comp_types['eventResponderType']):
                preamble_bits[9] = True
        if ('activityType' in value and 'activityType' not in self._def_vals):
            preamble_bits[10] = True
        elif ('activityType' in value and 'activityType' in self._def_vals):
            if not value_tracker.are_def_eq(value['activityType'], self._def_vals['activityType'], self._comp_types['activityType']):
                preamble_bits[10] = True
        if ('activitySubType' in value and 'activitySubType' not in self._def_vals):
            preamble_bits[11] = True
        elif ('activitySubType' in value and 'activitySubType' in self._def_vals):
            if not value_tracker.are_def_eq(value['activitySubType'], self._def_vals['activitySubType'], self._comp_types['activitySubType']):
                preamble_bits[11] = True
        if ('assistType' in value and 'assistType' not in self._def_vals):
            preamble_bits[12] = True
        elif ('assistType' in value and 'assistType' in self._def_vals):
            if not value_tracker.are_def_eq(value['assistType'], self._def_vals['assistType'], self._comp_types['assistType']):
                preamble_bits[12] = True
        if ('sizing' in value and 'sizing' not in self._def_vals):
            preamble_bits[13] = True
        elif ('sizing' in value and 'sizing' in self._def_vals):
            if not value_tracker.are_def_eq(value['sizing'], self._def_vals['sizing'], self._comp_types['sizing']):
                preamble_bits[13] = True
        if ('attachment' in value and 'attachment' not in self._def_vals):
            preamble_bits[14] = True
        elif ('attachment' in value and 'attachment' in self._def_vals):
            if not value_tracker.are_def_eq(value['attachment'], self._def_vals['attachment'], self._comp_types['attachment']):
                preamble_bits[14] = True
        if ('attachmentRadius' in value and 'attachmentRadius' not in self._def_vals):
            preamble_bits[15] = True
        elif ('attachmentRadius' in value and 'attachmentRadius' in self._def_vals):
            if not value_tracker.are_def_eq(value['attachmentRadius'], self._def_vals['attachmentRadius'], self._comp_types['attachmentRadius']):
                preamble_bits[15] = True
        if ('animalType' in value and 'animalType' not in self._def_vals):
            preamble_bits[16] = True
        elif ('animalType' in value and 'animalType' in self._def_vals):
            if not value_tracker.are_def_eq(value['animalType'], self._def_vals['animalType'], self._comp_types['animalType']):
                preamble_bits[16] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[17] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[17] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'basicType' in value:
            PersonalDeviceUserType.encode(encoding_rule, value['basicType'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'secMark' in value:
            DSecond.encode(encoding_rule, value['secMark'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'msgCnt' in value:
            BumperHeight.encode(encoding_rule, value['msgCnt'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'id' in value:
            TemporaryID.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'position' in value:
            Position3D.encode(encoding_rule, value['position'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'accuracy' in value:
            PositionalAccuracy.encode(encoding_rule, value['accuracy'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'speed' in value:
            Speed.encode(encoding_rule, value['speed'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'heading' in value:
            Angle.encode(encoding_rule, value['heading'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            AccelerationSet4Way.encode(encoding_rule, value['accelSet'], value_tracker, stream)
        if preamble_bits[2]:
            PathHistory.encode(encoding_rule, value['pathHistory'], value_tracker, stream)
        if preamble_bits[3]:
            PathPrediction.encode(encoding_rule, value['pathPrediction'], value_tracker, stream)
        if preamble_bits[4]:
            PropelledInformation.encode(encoding_rule, value['propulsion'], value_tracker, stream)
        if preamble_bits[5]:
            ExteriorLights.encode(encoding_rule, value['useState'], value_tracker, stream)
        if preamble_bits[6]:
            IsDolly.encode(encoding_rule, value['crossRequest'], value_tracker, stream)
        if preamble_bits[7]:
            IsDolly.encode(encoding_rule, value['crossState'], value_tracker, stream)
        if preamble_bits[8]:
            NumberOfParticipantsInCluster.encode(encoding_rule, value['clusterSize'], value_tracker, stream)
        if preamble_bits[9]:
            Iso3833VehicleType.encode(encoding_rule, value['clusterRadius'], value_tracker, stream)
        if preamble_bits[10]:
            PublicSafetyEventResponderWorkerType.encode(encoding_rule, value['eventResponderType'], value_tracker, stream)
        if preamble_bits[11]:
            PersonalAssistive.encode(encoding_rule, value['activityType'], value_tracker, stream)
        if preamble_bits[12]:
            PublicSafetyDirectingTrafficSubType.encode(encoding_rule, value['activitySubType'], value_tracker, stream)
        if preamble_bits[13]:
            PersonalAssistive.encode(encoding_rule, value['assistType'], value_tracker, stream)
        if preamble_bits[14]:
            UserSizeAndBehaviour.encode(encoding_rule, value['sizing'], value_tracker, stream)
        if preamble_bits[15]:
            Attachment.encode(encoding_rule, value['attachment'], value_tracker, stream)
        if preamble_bits[16]:
            AttachmentRadius.encode(encoding_rule, value['attachmentRadius'], value_tracker, stream)
        if preamble_bits[17]:
            AnimalType.encode(encoding_rule, value['animalType'], value_tracker, stream)
        if preamble_bits[18]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = PersonalSafetyMessage()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 18

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['basicType'] = PersonalDeviceUserType.decode(encoding_rule, stream, value_tracker)
        value['secMark'] = DSecond.decode(encoding_rule, stream, value_tracker)
        value['msgCnt'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        value['id'] = TemporaryID.decode(encoding_rule, stream, value_tracker)
        value['position'] = Position3D.decode(encoding_rule, stream, value_tracker)
        value['accuracy'] = PositionalAccuracy.decode(encoding_rule, stream, value_tracker)
        value['speed'] = Speed.decode(encoding_rule, stream, value_tracker)
        value['heading'] = Angle.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['accelSet'] = AccelerationSet4Way.decode(encoding_rule, stream, value_tracker)
        elif 'accelSet' in self._def_vals:
            value['accelSet'] = self._def_vals['accelSet']
        if preamble_bits[2]:
            value['pathHistory'] = PathHistory.decode(encoding_rule, stream, value_tracker)
        elif 'pathHistory' in self._def_vals:
            value['pathHistory'] = self._def_vals['pathHistory']
        if preamble_bits[3]:
            value['pathPrediction'] = PathPrediction.decode(encoding_rule, stream, value_tracker)
        elif 'pathPrediction' in self._def_vals:
            value['pathPrediction'] = self._def_vals['pathPrediction']
        if preamble_bits[4]:
            value['propulsion'] = PropelledInformation.decode(encoding_rule, stream, value_tracker)
        elif 'propulsion' in self._def_vals:
            value['propulsion'] = self._def_vals['propulsion']
        if preamble_bits[5]:
            value['useState'] = ExteriorLights.decode(encoding_rule, stream, value_tracker)
        elif 'useState' in self._def_vals:
            value['useState'] = self._def_vals['useState']
        if preamble_bits[6]:
            value['crossRequest'] = IsDolly.decode(encoding_rule, stream, value_tracker)
        elif 'crossRequest' in self._def_vals:
            value['crossRequest'] = self._def_vals['crossRequest']
        if preamble_bits[7]:
            value['crossState'] = IsDolly.decode(encoding_rule, stream, value_tracker)
        elif 'crossState' in self._def_vals:
            value['crossState'] = self._def_vals['crossState']
        if preamble_bits[8]:
            value['clusterSize'] = NumberOfParticipantsInCluster.decode(encoding_rule, stream, value_tracker)
        elif 'clusterSize' in self._def_vals:
            value['clusterSize'] = self._def_vals['clusterSize']
        if preamble_bits[9]:
            value['clusterRadius'] = Iso3833VehicleType.decode(encoding_rule, stream, value_tracker)
        elif 'clusterRadius' in self._def_vals:
            value['clusterRadius'] = self._def_vals['clusterRadius']
        if preamble_bits[10]:
            value['eventResponderType'] = PublicSafetyEventResponderWorkerType.decode(encoding_rule, stream, value_tracker)
        elif 'eventResponderType' in self._def_vals:
            value['eventResponderType'] = self._def_vals['eventResponderType']
        if preamble_bits[11]:
            value['activityType'] = PersonalAssistive.decode(encoding_rule, stream, value_tracker)
        elif 'activityType' in self._def_vals:
            value['activityType'] = self._def_vals['activityType']
        if preamble_bits[12]:
            value['activitySubType'] = PublicSafetyDirectingTrafficSubType.decode(encoding_rule, stream, value_tracker)
        elif 'activitySubType' in self._def_vals:
            value['activitySubType'] = self._def_vals['activitySubType']
        if preamble_bits[13]:
            value['assistType'] = PersonalAssistive.decode(encoding_rule, stream, value_tracker)
        elif 'assistType' in self._def_vals:
            value['assistType'] = self._def_vals['assistType']
        if preamble_bits[14]:
            value['sizing'] = UserSizeAndBehaviour.decode(encoding_rule, stream, value_tracker)
        elif 'sizing' in self._def_vals:
            value['sizing'] = self._def_vals['sizing']
        if preamble_bits[15]:
            value['attachment'] = Attachment.decode(encoding_rule, stream, value_tracker)
        elif 'attachment' in self._def_vals:
            value['attachment'] = self._def_vals['attachment']
        if preamble_bits[16]:
            value['attachmentRadius'] = AttachmentRadius.decode(encoding_rule, stream, value_tracker)
        elif 'attachmentRadius' in self._def_vals:
            value['attachmentRadius'] = self._def_vals['attachmentRadius']
        if preamble_bits[17]:
            value['animalType'] = AnimalType.decode(encoding_rule, stream, value_tracker)
        elif 'animalType' in self._def_vals:
            value['animalType'] = self._def_vals['animalType']
        if preamble_bits[18]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = PersonalSafetyMessage()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'basicType' in value:
            PersonalDeviceUserType.validate(value['basicType'], errors, '{}/{}'.format(comp_path ,'basicType'))
        elif 'basicType' not in value:
            report_missing_field(type(self).__name__, 'basicType', errors, comp_path)
        if 'secMark' in value:
            DSecond.validate(value['secMark'], errors, '{}/{}'.format(comp_path ,'secMark'))
        elif 'secMark' not in value:
            report_missing_field(type(self).__name__, 'secMark', errors, comp_path)
        if 'msgCnt' in value:
            BumperHeight.validate(value['msgCnt'], errors, '{}/{}'.format(comp_path ,'msgCnt'))
        elif 'msgCnt' not in value:
            report_missing_field(type(self).__name__, 'msgCnt', errors, comp_path)
        if 'id' in value:
            TemporaryID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'position' in value:
            Position3D.validate(value['position'], errors, '{}/{}'.format(comp_path ,'position'))
        elif 'position' not in value:
            report_missing_field(type(self).__name__, 'position', errors, comp_path)
        if 'accuracy' in value:
            PositionalAccuracy.validate(value['accuracy'], errors, '{}/{}'.format(comp_path ,'accuracy'))
        elif 'accuracy' not in value:
            report_missing_field(type(self).__name__, 'accuracy', errors, comp_path)
        if 'speed' in value:
            Speed.validate(value['speed'], errors, '{}/{}'.format(comp_path ,'speed'))
        elif 'speed' not in value:
            report_missing_field(type(self).__name__, 'speed', errors, comp_path)
        if 'heading' in value:
            Angle.validate(value['heading'], errors, '{}/{}'.format(comp_path ,'heading'))
        elif 'heading' not in value:
            report_missing_field(type(self).__name__, 'heading', errors, comp_path)
        if 'accelSet' in value:
            AccelerationSet4Way.validate(value['accelSet'], errors, '{}/{}'.format(comp_path ,'accelSet'))
        if 'pathHistory' in value:
            PathHistory.validate(value['pathHistory'], errors, '{}/{}'.format(comp_path ,'pathHistory'))
        if 'pathPrediction' in value:
            PathPrediction.validate(value['pathPrediction'], errors, '{}/{}'.format(comp_path ,'pathPrediction'))
        if 'propulsion' in value:
            PropelledInformation.validate(value['propulsion'], errors, '{}/{}'.format(comp_path ,'propulsion'))
        if 'useState' in value:
            ExteriorLights.validate(value['useState'], errors, '{}/{}'.format(comp_path ,'useState'))
        if 'crossRequest' in value:
            IsDolly.validate(value['crossRequest'], errors, '{}/{}'.format(comp_path ,'crossRequest'))
        if 'crossState' in value:
            IsDolly.validate(value['crossState'], errors, '{}/{}'.format(comp_path ,'crossState'))
        if 'clusterSize' in value:
            NumberOfParticipantsInCluster.validate(value['clusterSize'], errors, '{}/{}'.format(comp_path ,'clusterSize'))
        if 'clusterRadius' in value:
            Iso3833VehicleType.validate(value['clusterRadius'], errors, '{}/{}'.format(comp_path ,'clusterRadius'))
        if 'eventResponderType' in value:
            PublicSafetyEventResponderWorkerType.validate(value['eventResponderType'], errors, '{}/{}'.format(comp_path ,'eventResponderType'))
        if 'activityType' in value:
            PersonalAssistive.validate(value['activityType'], errors, '{}/{}'.format(comp_path ,'activityType'))
        if 'activitySubType' in value:
            PublicSafetyDirectingTrafficSubType.validate(value['activitySubType'], errors, '{}/{}'.format(comp_path ,'activitySubType'))
        if 'assistType' in value:
            PersonalAssistive.validate(value['assistType'], errors, '{}/{}'.format(comp_path ,'assistType'))
        if 'sizing' in value:
            UserSizeAndBehaviour.validate(value['sizing'], errors, '{}/{}'.format(comp_path ,'sizing'))
        if 'attachment' in value:
            Attachment.validate(value['attachment'], errors, '{}/{}'.format(comp_path ,'attachment'))
        if 'attachmentRadius' in value:
            AttachmentRadius.validate(value['attachmentRadius'], errors, '{}/{}'.format(comp_path ,'attachmentRadius'))
        if 'animalType' in value:
            AnimalType.validate(value['animalType'], errors, '{}/{}'.format(comp_path ,'animalType'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class ProbeDataManagement:
    def __init__(self):
        self._comp_types = {"timeStamp" : MinuteOfTheYear, "sample" : Sample, "directions" : HeadingSlice, "term" : ProbeDataManagement__6, "snapshot" : ProbeDataManagement__9, "txInterval" : SecondOfTime, "dataElements" : VehicleStatusRequestList, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.ProbeDataManagement"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ProbeDataManagement()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('dataElements' in value and 'dataElements' not in self._def_vals):
            preamble_bits[1] = True
        elif ('dataElements' in value and 'dataElements' in self._def_vals):
            if not value_tracker.are_def_eq(value['dataElements'], self._def_vals['dataElements'], self._comp_types['dataElements']):
                preamble_bits[1] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[2] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[2] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if 'sample' in value:
            Sample.encode(encoding_rule, value['sample'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'directions' in value:
            HeadingSlice.encode(encoding_rule, value['directions'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'term' in value:
            ProbeDataManagement__6.encode(encoding_rule, value['term'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'snapshot' in value:
            ProbeDataManagement__9.encode(encoding_rule, value['snapshot'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'txInterval' in value:
            SecondOfTime.encode(encoding_rule, value['txInterval'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            VehicleStatusRequestList.encode(encoding_rule, value['dataElements'], value_tracker, stream)
        if preamble_bits[3]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ProbeDataManagement()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        value['sample'] = Sample.decode(encoding_rule, stream, value_tracker)
        value['directions'] = HeadingSlice.decode(encoding_rule, stream, value_tracker)
        value['term'] = ProbeDataManagement__6.decode(encoding_rule, stream, value_tracker)
        value['snapshot'] = ProbeDataManagement__9.decode(encoding_rule, stream, value_tracker)
        value['txInterval'] = SecondOfTime.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['dataElements'] = VehicleStatusRequestList.decode(encoding_rule, stream, value_tracker)
        elif 'dataElements' in self._def_vals:
            value['dataElements'] = self._def_vals['dataElements']
        if preamble_bits[3]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ProbeDataManagement()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'sample' in value:
            Sample.validate(value['sample'], errors, '{}/{}'.format(comp_path ,'sample'))
        elif 'sample' not in value:
            report_missing_field(type(self).__name__, 'sample', errors, comp_path)
        if 'directions' in value:
            HeadingSlice.validate(value['directions'], errors, '{}/{}'.format(comp_path ,'directions'))
        elif 'directions' not in value:
            report_missing_field(type(self).__name__, 'directions', errors, comp_path)
        if 'term' in value:
            ProbeDataManagement__6.validate(value['term'], errors, '{}/{}'.format(comp_path ,'term'))
        elif 'term' not in value:
            report_missing_field(type(self).__name__, 'term', errors, comp_path)
        if 'snapshot' in value:
            ProbeDataManagement__9.validate(value['snapshot'], errors, '{}/{}'.format(comp_path ,'snapshot'))
        elif 'snapshot' not in value:
            report_missing_field(type(self).__name__, 'snapshot', errors, comp_path)
        if 'txInterval' in value:
            SecondOfTime.validate(value['txInterval'], errors, '{}/{}'.format(comp_path ,'txInterval'))
        elif 'txInterval' not in value:
            report_missing_field(type(self).__name__, 'txInterval', errors, comp_path)
        if 'dataElements' in value:
            VehicleStatusRequestList.validate(value['dataElements'], errors, '{}/{}'.format(comp_path ,'dataElements'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class ProbeDataManagement__6:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.ProbeDataManagement.term"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"termtime": 0, "termDistance": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = ProbeDataManagement__6()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'termtime':
                TermTime.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'termDistance':
                TermDistance.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = ProbeDataManagement__6()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'termtime':
                alternative = TermTime.decode(encoding_rule, stream, value_tracker)
            if identifier == 'termDistance':
                alternative = TermDistance.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = ProbeDataManagement__6()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'termtime' in value:
            TermTime.validate(value['termtime'], errors, '{}/{}'.format(comp_path ,'termtime'))
            is_checked = True
        if 'termDistance' in value:
            TermDistance.validate(value['termDistance'], errors, '{}/{}'.format(comp_path ,'termDistance'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class ProbeDataManagement__9:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.ProbeDataManagement.snapshot"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"snapshotTime": 0, "snapshotDistance": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = ProbeDataManagement__9()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'snapshotTime':
                SnapshotTime.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'snapshotDistance':
                SnapshotDistance.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = ProbeDataManagement__9()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'snapshotTime':
                alternative = SnapshotTime.decode(encoding_rule, stream, value_tracker)
            if identifier == 'snapshotDistance':
                alternative = SnapshotDistance.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = ProbeDataManagement__9()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'snapshotTime' in value:
            SnapshotTime.validate(value['snapshotTime'], errors, '{}/{}'.format(comp_path ,'snapshotTime'))
            is_checked = True
        if 'snapshotDistance' in value:
            SnapshotDistance.validate(value['snapshotDistance'], errors, '{}/{}'.format(comp_path ,'snapshotDistance'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class ProbeVehicleData:
    def __init__(self):
        self._comp_types = {"timeStamp" : MinuteOfTheYear, "segNum" : DSRCmsgID, "probeID" : VehicleIdent, "startVector" : FullPositionVector, "vehicleType" : VehicleClassification, "snapshots" : ProbeVehicleData__7, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.ProbeVehicleData"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ProbeVehicleData()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('segNum' in value and 'segNum' not in self._def_vals):
            preamble_bits[1] = True
        elif ('segNum' in value and 'segNum' in self._def_vals):
            if not value_tracker.are_def_eq(value['segNum'], self._def_vals['segNum'], self._comp_types['segNum']):
                preamble_bits[1] = True
        if ('probeID' in value and 'probeID' not in self._def_vals):
            preamble_bits[2] = True
        elif ('probeID' in value and 'probeID' in self._def_vals):
            if not value_tracker.are_def_eq(value['probeID'], self._def_vals['probeID'], self._comp_types['probeID']):
                preamble_bits[2] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[3] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if preamble_bits[2]:
            DSRCmsgID.encode(encoding_rule, value['segNum'], value_tracker, stream)
        if preamble_bits[3]:
            VehicleIdent.encode(encoding_rule, value['probeID'], value_tracker, stream)
        if 'startVector' in value:
            FullPositionVector.encode(encoding_rule, value['startVector'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'vehicleType' in value:
            VehicleClassification.encode(encoding_rule, value['vehicleType'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'snapshots' in value:
            ProbeVehicleData__7.encode(encoding_rule, value['snapshots'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[4]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ProbeVehicleData()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        if preamble_bits[2]:
            value['segNum'] = DSRCmsgID.decode(encoding_rule, stream, value_tracker)
        elif 'segNum' in self._def_vals:
            value['segNum'] = self._def_vals['segNum']
        if preamble_bits[3]:
            value['probeID'] = VehicleIdent.decode(encoding_rule, stream, value_tracker)
        elif 'probeID' in self._def_vals:
            value['probeID'] = self._def_vals['probeID']
        value['startVector'] = FullPositionVector.decode(encoding_rule, stream, value_tracker)
        value['vehicleType'] = VehicleClassification.decode(encoding_rule, stream, value_tracker)
        value['snapshots'] = ProbeVehicleData__7.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[4]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ProbeVehicleData()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'segNum' in value:
            DSRCmsgID.validate(value['segNum'], errors, '{}/{}'.format(comp_path ,'segNum'))
        if 'probeID' in value:
            VehicleIdent.validate(value['probeID'], errors, '{}/{}'.format(comp_path ,'probeID'))
        if 'startVector' in value:
            FullPositionVector.validate(value['startVector'], errors, '{}/{}'.format(comp_path ,'startVector'))
        elif 'startVector' not in value:
            report_missing_field(type(self).__name__, 'startVector', errors, comp_path)
        if 'vehicleType' in value:
            VehicleClassification.validate(value['vehicleType'], errors, '{}/{}'.format(comp_path ,'vehicleType'))
        elif 'vehicleType' not in value:
            report_missing_field(type(self).__name__, 'vehicleType', errors, comp_path)
        if 'snapshots' in value:
            ProbeVehicleData__7.validate(value['snapshots'], errors, '{}/{}'.format(comp_path ,'snapshots'))
        elif 'snapshots' not in value:
            report_missing_field(type(self).__name__, 'snapshots', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class ProbeVehicleData__7:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,32)]}}]
        self._unique_indetifier = "DSRC.ProbeVehicleData.snapshots"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                Snapshot.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                Snapshot.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(Snapshot.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = ProbeVehicleData__7()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(Snapshot.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = ProbeVehicleData__7()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = ProbeVehicleData__7()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                Snapshot.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class RoadSideAlert:
    def __init__(self):
        self._comp_types = {"msgCnt" : BumperHeight, "timeStamp" : MinuteOfTheYear, "typeEvent" : DSecond, "description" : EventDescription__3, "priority" : Priority, "heading" : HeadingSlice, "extent" : Extent, "position" : FullPositionVector, "furtherInfoID" : FurtherInfoID, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RoadSideAlert"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RoadSideAlert()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 8

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('description' in value and 'description' not in self._def_vals):
            preamble_bits[1] = True
        elif ('description' in value and 'description' in self._def_vals):
            if not value_tracker.are_def_eq(value['description'], self._def_vals['description'], self._comp_types['description']):
                preamble_bits[1] = True
        if ('priority' in value and 'priority' not in self._def_vals):
            preamble_bits[2] = True
        elif ('priority' in value and 'priority' in self._def_vals):
            if not value_tracker.are_def_eq(value['priority'], self._def_vals['priority'], self._comp_types['priority']):
                preamble_bits[2] = True
        if ('heading' in value and 'heading' not in self._def_vals):
            preamble_bits[3] = True
        elif ('heading' in value and 'heading' in self._def_vals):
            if not value_tracker.are_def_eq(value['heading'], self._def_vals['heading'], self._comp_types['heading']):
                preamble_bits[3] = True
        if ('extent' in value and 'extent' not in self._def_vals):
            preamble_bits[4] = True
        elif ('extent' in value and 'extent' in self._def_vals):
            if not value_tracker.are_def_eq(value['extent'], self._def_vals['extent'], self._comp_types['extent']):
                preamble_bits[4] = True
        if ('position' in value and 'position' not in self._def_vals):
            preamble_bits[5] = True
        elif ('position' in value and 'position' in self._def_vals):
            if not value_tracker.are_def_eq(value['position'], self._def_vals['position'], self._comp_types['position']):
                preamble_bits[5] = True
        if ('furtherInfoID' in value and 'furtherInfoID' not in self._def_vals):
            preamble_bits[6] = True
        elif ('furtherInfoID' in value and 'furtherInfoID' in self._def_vals):
            if not value_tracker.are_def_eq(value['furtherInfoID'], self._def_vals['furtherInfoID'], self._comp_types['furtherInfoID']):
                preamble_bits[6] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[7] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[7] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'msgCnt' in value:
            BumperHeight.encode(encoding_rule, value['msgCnt'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if 'typeEvent' in value:
            DSecond.encode(encoding_rule, value['typeEvent'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            EventDescription__3.encode(encoding_rule, value['description'], value_tracker, stream)
        if preamble_bits[3]:
            Priority.encode(encoding_rule, value['priority'], value_tracker, stream)
        if preamble_bits[4]:
            HeadingSlice.encode(encoding_rule, value['heading'], value_tracker, stream)
        if preamble_bits[5]:
            Extent.encode(encoding_rule, value['extent'], value_tracker, stream)
        if preamble_bits[6]:
            FullPositionVector.encode(encoding_rule, value['position'], value_tracker, stream)
        if preamble_bits[7]:
            FurtherInfoID.encode(encoding_rule, value['furtherInfoID'], value_tracker, stream)
        if preamble_bits[8]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RoadSideAlert()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 8

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['msgCnt'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        value['typeEvent'] = DSecond.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['description'] = EventDescription__3.decode(encoding_rule, stream, value_tracker)
        elif 'description' in self._def_vals:
            value['description'] = self._def_vals['description']
        if preamble_bits[3]:
            value['priority'] = Priority.decode(encoding_rule, stream, value_tracker)
        elif 'priority' in self._def_vals:
            value['priority'] = self._def_vals['priority']
        if preamble_bits[4]:
            value['heading'] = HeadingSlice.decode(encoding_rule, stream, value_tracker)
        elif 'heading' in self._def_vals:
            value['heading'] = self._def_vals['heading']
        if preamble_bits[5]:
            value['extent'] = Extent.decode(encoding_rule, stream, value_tracker)
        elif 'extent' in self._def_vals:
            value['extent'] = self._def_vals['extent']
        if preamble_bits[6]:
            value['position'] = FullPositionVector.decode(encoding_rule, stream, value_tracker)
        elif 'position' in self._def_vals:
            value['position'] = self._def_vals['position']
        if preamble_bits[7]:
            value['furtherInfoID'] = FurtherInfoID.decode(encoding_rule, stream, value_tracker)
        elif 'furtherInfoID' in self._def_vals:
            value['furtherInfoID'] = self._def_vals['furtherInfoID']
        if preamble_bits[8]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RoadSideAlert()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'msgCnt' in value:
            BumperHeight.validate(value['msgCnt'], errors, '{}/{}'.format(comp_path ,'msgCnt'))
        elif 'msgCnt' not in value:
            report_missing_field(type(self).__name__, 'msgCnt', errors, comp_path)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'typeEvent' in value:
            DSecond.validate(value['typeEvent'], errors, '{}/{}'.format(comp_path ,'typeEvent'))
        elif 'typeEvent' not in value:
            report_missing_field(type(self).__name__, 'typeEvent', errors, comp_path)
        if 'description' in value:
            EventDescription__3.validate(value['description'], errors, '{}/{}'.format(comp_path ,'description'))
        if 'priority' in value:
            Priority.validate(value['priority'], errors, '{}/{}'.format(comp_path ,'priority'))
        if 'heading' in value:
            HeadingSlice.validate(value['heading'], errors, '{}/{}'.format(comp_path ,'heading'))
        if 'extent' in value:
            Extent.validate(value['extent'], errors, '{}/{}'.format(comp_path ,'extent'))
        if 'position' in value:
            FullPositionVector.validate(value['position'], errors, '{}/{}'.format(comp_path ,'position'))
        if 'furtherInfoID' in value:
            FurtherInfoID.validate(value['furtherInfoID'], errors, '{}/{}'.format(comp_path ,'furtherInfoID'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class RTCMcorrections:
    def __init__(self):
        self._comp_types = {"msgCnt" : BumperHeight, "rev" : RTCM_Revision, "timeStamp" : MinuteOfTheYear, "anchorPoint" : FullPositionVector, "rtcmHeader" : RTCMheader, "msgs" : RTCMmessageList, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RTCMcorrections"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RTCMcorrections()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('anchorPoint' in value and 'anchorPoint' not in self._def_vals):
            preamble_bits[1] = True
        elif ('anchorPoint' in value and 'anchorPoint' in self._def_vals):
            if not value_tracker.are_def_eq(value['anchorPoint'], self._def_vals['anchorPoint'], self._comp_types['anchorPoint']):
                preamble_bits[1] = True
        if ('rtcmHeader' in value and 'rtcmHeader' not in self._def_vals):
            preamble_bits[2] = True
        elif ('rtcmHeader' in value and 'rtcmHeader' in self._def_vals):
            if not value_tracker.are_def_eq(value['rtcmHeader'], self._def_vals['rtcmHeader'], self._comp_types['rtcmHeader']):
                preamble_bits[2] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[3] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'msgCnt' in value:
            BumperHeight.encode(encoding_rule, value['msgCnt'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'rev' in value:
            RTCM_Revision.encode(encoding_rule, value['rev'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if preamble_bits[2]:
            FullPositionVector.encode(encoding_rule, value['anchorPoint'], value_tracker, stream)
        if preamble_bits[3]:
            RTCMheader.encode(encoding_rule, value['rtcmHeader'], value_tracker, stream)
        if 'msgs' in value:
            RTCMmessageList.encode(encoding_rule, value['msgs'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[4]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RTCMcorrections()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['msgCnt'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        value['rev'] = RTCM_Revision.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        if preamble_bits[2]:
            value['anchorPoint'] = FullPositionVector.decode(encoding_rule, stream, value_tracker)
        elif 'anchorPoint' in self._def_vals:
            value['anchorPoint'] = self._def_vals['anchorPoint']
        if preamble_bits[3]:
            value['rtcmHeader'] = RTCMheader.decode(encoding_rule, stream, value_tracker)
        elif 'rtcmHeader' in self._def_vals:
            value['rtcmHeader'] = self._def_vals['rtcmHeader']
        value['msgs'] = RTCMmessageList.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[4]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RTCMcorrections()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'msgCnt' in value:
            BumperHeight.validate(value['msgCnt'], errors, '{}/{}'.format(comp_path ,'msgCnt'))
        elif 'msgCnt' not in value:
            report_missing_field(type(self).__name__, 'msgCnt', errors, comp_path)
        if 'rev' in value:
            RTCM_Revision.validate(value['rev'], errors, '{}/{}'.format(comp_path ,'rev'))
        elif 'rev' not in value:
            report_missing_field(type(self).__name__, 'rev', errors, comp_path)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'anchorPoint' in value:
            FullPositionVector.validate(value['anchorPoint'], errors, '{}/{}'.format(comp_path ,'anchorPoint'))
        if 'rtcmHeader' in value:
            RTCMheader.validate(value['rtcmHeader'], errors, '{}/{}'.format(comp_path ,'rtcmHeader'))
        if 'msgs' in value:
            RTCMmessageList.validate(value['msgs'], errors, '{}/{}'.format(comp_path ,'msgs'))
        elif 'msgs' not in value:
            report_missing_field(type(self).__name__, 'msgs', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class SPAT:
    def __init__(self):
        self._comp_types = {"timeStamp" : MinuteOfTheYear, "name" : DescriptiveName, "intersections" : IntersectionStateList, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SPAT"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SPAT()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('name' in value and 'name' not in self._def_vals):
            preamble_bits[1] = True
        elif ('name' in value and 'name' in self._def_vals):
            if not value_tracker.are_def_eq(value['name'], self._def_vals['name'], self._comp_types['name']):
                preamble_bits[1] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[2] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[2] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if preamble_bits[2]:
            DescriptiveName.encode(encoding_rule, value['name'], value_tracker, stream)
        if 'intersections' in value:
            IntersectionStateList.encode(encoding_rule, value['intersections'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[3]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SPAT()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        if preamble_bits[2]:
            value['name'] = DescriptiveName.decode(encoding_rule, stream, value_tracker)
        elif 'name' in self._def_vals:
            value['name'] = self._def_vals['name']
        value['intersections'] = IntersectionStateList.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[3]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SPAT()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'name' in value:
            DescriptiveName.validate(value['name'], errors, '{}/{}'.format(comp_path ,'name'))
        if 'intersections' in value:
            IntersectionStateList.validate(value['intersections'], errors, '{}/{}'.format(comp_path ,'intersections'))
        elif 'intersections' not in value:
            report_missing_field(type(self).__name__, 'intersections', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class SignalRequestMessage:
    def __init__(self):
        self._comp_types = {"timeStamp" : MinuteOfTheYear, "second" : DSecond, "sequenceNumber" : BumperHeight, "requests" : SignalRequestList, "requestor" : RequestorDescription, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SignalRequestMessage"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SignalRequestMessage()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('sequenceNumber' in value and 'sequenceNumber' not in self._def_vals):
            preamble_bits[1] = True
        elif ('sequenceNumber' in value and 'sequenceNumber' in self._def_vals):
            if not value_tracker.are_def_eq(value['sequenceNumber'], self._def_vals['sequenceNumber'], self._comp_types['sequenceNumber']):
                preamble_bits[1] = True
        if ('requests' in value and 'requests' not in self._def_vals):
            preamble_bits[2] = True
        elif ('requests' in value and 'requests' in self._def_vals):
            if not value_tracker.are_def_eq(value['requests'], self._def_vals['requests'], self._comp_types['requests']):
                preamble_bits[2] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[3] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if 'second' in value:
            DSecond.encode(encoding_rule, value['second'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            BumperHeight.encode(encoding_rule, value['sequenceNumber'], value_tracker, stream)
        if preamble_bits[3]:
            SignalRequestList.encode(encoding_rule, value['requests'], value_tracker, stream)
        if 'requestor' in value:
            RequestorDescription.encode(encoding_rule, value['requestor'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[4]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SignalRequestMessage()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        value['second'] = DSecond.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['sequenceNumber'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        elif 'sequenceNumber' in self._def_vals:
            value['sequenceNumber'] = self._def_vals['sequenceNumber']
        if preamble_bits[3]:
            value['requests'] = SignalRequestList.decode(encoding_rule, stream, value_tracker)
        elif 'requests' in self._def_vals:
            value['requests'] = self._def_vals['requests']
        value['requestor'] = RequestorDescription.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[4]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SignalRequestMessage()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'second' in value:
            DSecond.validate(value['second'], errors, '{}/{}'.format(comp_path ,'second'))
        elif 'second' not in value:
            report_missing_field(type(self).__name__, 'second', errors, comp_path)
        if 'sequenceNumber' in value:
            BumperHeight.validate(value['sequenceNumber'], errors, '{}/{}'.format(comp_path ,'sequenceNumber'))
        if 'requests' in value:
            SignalRequestList.validate(value['requests'], errors, '{}/{}'.format(comp_path ,'requests'))
        if 'requestor' in value:
            RequestorDescription.validate(value['requestor'], errors, '{}/{}'.format(comp_path ,'requestor'))
        elif 'requestor' not in value:
            report_missing_field(type(self).__name__, 'requestor', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class SignalStatusMessage:
    def __init__(self):
        self._comp_types = {"timeStamp" : MinuteOfTheYear, "second" : DSecond, "sequenceNumber" : BumperHeight, "status" : SignalStatusList, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SignalStatusMessage"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SignalStatusMessage()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('sequenceNumber' in value and 'sequenceNumber' not in self._def_vals):
            preamble_bits[1] = True
        elif ('sequenceNumber' in value and 'sequenceNumber' in self._def_vals):
            if not value_tracker.are_def_eq(value['sequenceNumber'], self._def_vals['sequenceNumber'], self._comp_types['sequenceNumber']):
                preamble_bits[1] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[2] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[2] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if 'second' in value:
            DSecond.encode(encoding_rule, value['second'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            BumperHeight.encode(encoding_rule, value['sequenceNumber'], value_tracker, stream)
        if 'status' in value:
            SignalStatusList.encode(encoding_rule, value['status'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[3]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SignalStatusMessage()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        value['second'] = DSecond.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['sequenceNumber'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        elif 'sequenceNumber' in self._def_vals:
            value['sequenceNumber'] = self._def_vals['sequenceNumber']
        value['status'] = SignalStatusList.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[3]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SignalStatusMessage()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'second' in value:
            DSecond.validate(value['second'], errors, '{}/{}'.format(comp_path ,'second'))
        elif 'second' not in value:
            report_missing_field(type(self).__name__, 'second', errors, comp_path)
        if 'sequenceNumber' in value:
            BumperHeight.validate(value['sequenceNumber'], errors, '{}/{}'.format(comp_path ,'sequenceNumber'))
        if 'status' in value:
            SignalStatusList.validate(value['status'], errors, '{}/{}'.format(comp_path ,'status'))
        elif 'status' not in value:
            report_missing_field(type(self).__name__, 'status', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class TravelerInformation:
    def __init__(self):
        self._comp_types = {"msgCnt" : BumperHeight, "timeStamp" : MinuteOfTheYear, "packetID" : UniqueMSGID, "urlB" : URL_Base, "dataFrames" : TravelerDataFrameList, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.TravelerInformation"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = TravelerInformation()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('packetID' in value and 'packetID' not in self._def_vals):
            preamble_bits[1] = True
        elif ('packetID' in value and 'packetID' in self._def_vals):
            if not value_tracker.are_def_eq(value['packetID'], self._def_vals['packetID'], self._comp_types['packetID']):
                preamble_bits[1] = True
        if ('urlB' in value and 'urlB' not in self._def_vals):
            preamble_bits[2] = True
        elif ('urlB' in value and 'urlB' in self._def_vals):
            if not value_tracker.are_def_eq(value['urlB'], self._def_vals['urlB'], self._comp_types['urlB']):
                preamble_bits[2] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[3] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'msgCnt' in value:
            BumperHeight.encode(encoding_rule, value['msgCnt'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if preamble_bits[2]:
            UniqueMSGID.encode(encoding_rule, value['packetID'], value_tracker, stream)
        if preamble_bits[3]:
            URL_Base.encode(encoding_rule, value['urlB'], value_tracker, stream)
        if 'dataFrames' in value:
            TravelerDataFrameList.encode(encoding_rule, value['dataFrames'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[4]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = TravelerInformation()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['msgCnt'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        if preamble_bits[2]:
            value['packetID'] = UniqueMSGID.decode(encoding_rule, stream, value_tracker)
        elif 'packetID' in self._def_vals:
            value['packetID'] = self._def_vals['packetID']
        if preamble_bits[3]:
            value['urlB'] = URL_Base.decode(encoding_rule, stream, value_tracker)
        elif 'urlB' in self._def_vals:
            value['urlB'] = self._def_vals['urlB']
        value['dataFrames'] = TravelerDataFrameList.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[4]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = TravelerInformation()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'msgCnt' in value:
            BumperHeight.validate(value['msgCnt'], errors, '{}/{}'.format(comp_path ,'msgCnt'))
        elif 'msgCnt' not in value:
            report_missing_field(type(self).__name__, 'msgCnt', errors, comp_path)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'packetID' in value:
            UniqueMSGID.validate(value['packetID'], errors, '{}/{}'.format(comp_path ,'packetID'))
        if 'urlB' in value:
            URL_Base.validate(value['urlB'], errors, '{}/{}'.format(comp_path ,'urlB'))
        if 'dataFrames' in value:
            TravelerDataFrameList.validate(value['dataFrames'], errors, '{}/{}'.format(comp_path ,'dataFrames'))
        elif 'dataFrames' not in value:
            report_missing_field(type(self).__name__, 'dataFrames', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class TestMessage00:
    def __init__(self):
        self._comp_types = {"header" : Header, "regional" : RegionalExtension_1}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.TestMessage00"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = TestMessage00()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('header' in value and 'header' not in self._def_vals):
            preamble_bits[0] = True
        elif ('header' in value and 'header' in self._def_vals):
            if not value_tracker.are_def_eq(value['header'], self._def_vals['header'], self._comp_types['header']):
                preamble_bits[0] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[1] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            Header.encode(encoding_rule, value['header'], value_tracker, stream)
        if preamble_bits[2]:
            RegionalExtension_1.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = TestMessage00()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['header'] = Header.decode(encoding_rule, stream, value_tracker)
        elif 'header' in self._def_vals:
            value['header'] = self._def_vals['header']
        if preamble_bits[2]:
            value['regional'] = RegionalExtension_1.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = TestMessage00()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'header' in value:
            Header.validate(value['header'], errors, '{}/{}'.format(comp_path ,'header'))
        if 'regional' in value:
            RegionalExtension_1.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

TestMessage01 = TestMessage00
TestMessage02 = TestMessage00
TestMessage03 = TestMessage00
TestMessage04 = TestMessage00
TestMessage05 = TestMessage00
TestMessage06 = TestMessage00
TestMessage07 = TestMessage00
TestMessage08 = TestMessage00
TestMessage09 = TestMessage00
TestMessage10 = TestMessage00
TestMessage11 = TestMessage00
TestMessage12 = TestMessage00
TestMessage13 = TestMessage00
TestMessage14 = TestMessage00
TestMessage15 = TestMessage00

class AccelerationSet4Way:
    def __init__(self):
        self._comp_types = {"long" : Acceleration, "lat" : Acceleration, "vert" : SteeringWheelAngleRateOfChange, "yaw" : DrivenLineOffsetLg}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.AccelerationSet4Way"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = AccelerationSet4Way()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'long' in value:
            Acceleration.encode(encoding_rule, value['long'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            Acceleration.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'vert' in value:
            SteeringWheelAngleRateOfChange.encode(encoding_rule, value['vert'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'yaw' in value:
            DrivenLineOffsetLg.encode(encoding_rule, value['yaw'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = AccelerationSet4Way()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['long'] = Acceleration.decode(encoding_rule, stream, value_tracker)
        value['lat'] = Acceleration.decode(encoding_rule, stream, value_tracker)
        value['vert'] = SteeringWheelAngleRateOfChange.decode(encoding_rule, stream, value_tracker)
        value['yaw'] = DrivenLineOffsetLg.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = AccelerationSet4Way()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'long' in value:
            Acceleration.validate(value['long'], errors, '{}/{}'.format(comp_path ,'long'))
        elif 'long' not in value:
            report_missing_field(type(self).__name__, 'long', errors, comp_path)
        if 'lat' in value:
            Acceleration.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)
        if 'vert' in value:
            SteeringWheelAngleRateOfChange.validate(value['vert'], errors, '{}/{}'.format(comp_path ,'vert'))
        elif 'vert' not in value:
            report_missing_field(type(self).__name__, 'vert', errors, comp_path)
        if 'yaw' in value:
            DrivenLineOffsetLg.validate(value['yaw'], errors, '{}/{}'.format(comp_path ,'yaw'))
        elif 'yaw' not in value:
            report_missing_field(type(self).__name__, 'yaw', errors, comp_path)

        return errors

class AccelSteerYawRateConfidence:
    def __init__(self):
        self._comp_types = {"yawRate" : YawRateConfidence, "acceleration" : AccelerationConfidence, "steeringWheelAngle" : SteeringWheelAngleConfidence}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.AccelSteerYawRateConfidence"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = AccelSteerYawRateConfidence()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'yawRate' in value:
            YawRateConfidence.encode(encoding_rule, value['yawRate'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'acceleration' in value:
            AccelerationConfidence.encode(encoding_rule, value['acceleration'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'steeringWheelAngle' in value:
            SteeringWheelAngleConfidence.encode(encoding_rule, value['steeringWheelAngle'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = AccelSteerYawRateConfidence()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['yawRate'] = YawRateConfidence.decode(encoding_rule, stream, value_tracker)
        value['acceleration'] = AccelerationConfidence.decode(encoding_rule, stream, value_tracker)
        value['steeringWheelAngle'] = SteeringWheelAngleConfidence.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = AccelSteerYawRateConfidence()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'yawRate' in value:
            YawRateConfidence.validate(value['yawRate'], errors, '{}/{}'.format(comp_path ,'yawRate'))
        elif 'yawRate' not in value:
            report_missing_field(type(self).__name__, 'yawRate', errors, comp_path)
        if 'acceleration' in value:
            AccelerationConfidence.validate(value['acceleration'], errors, '{}/{}'.format(comp_path ,'acceleration'))
        elif 'acceleration' not in value:
            report_missing_field(type(self).__name__, 'acceleration', errors, comp_path)
        if 'steeringWheelAngle' in value:
            SteeringWheelAngleConfidence.validate(value['steeringWheelAngle'], errors, '{}/{}'.format(comp_path ,'steeringWheelAngle'))
        elif 'steeringWheelAngle' not in value:
            report_missing_field(type(self).__name__, 'steeringWheelAngle', errors, comp_path)

        return errors

class AdvisorySpeed:
    def __init__(self):
        self._comp_types = {"type" : AdvisorySpeedType, "speed" : SpeedAdvice, "confidence" : SpeedConfidence, "distance" : ZoneLength, "class" : AmbientAirPressure, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.AdvisorySpeed"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = AdvisorySpeed()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('speed' in value and 'speed' not in self._def_vals):
            preamble_bits[0] = True
        elif ('speed' in value and 'speed' in self._def_vals):
            if not value_tracker.are_def_eq(value['speed'], self._def_vals['speed'], self._comp_types['speed']):
                preamble_bits[0] = True
        if ('confidence' in value and 'confidence' not in self._def_vals):
            preamble_bits[1] = True
        elif ('confidence' in value and 'confidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['confidence'], self._def_vals['confidence'], self._comp_types['confidence']):
                preamble_bits[1] = True
        if ('distance' in value and 'distance' not in self._def_vals):
            preamble_bits[2] = True
        elif ('distance' in value and 'distance' in self._def_vals):
            if not value_tracker.are_def_eq(value['distance'], self._def_vals['distance'], self._comp_types['distance']):
                preamble_bits[2] = True
        if ('class' in value and 'class' not in self._def_vals):
            preamble_bits[3] = True
        elif ('class' in value and 'class' in self._def_vals):
            if not value_tracker.are_def_eq(value['class'], self._def_vals['class'], self._comp_types['class']):
                preamble_bits[3] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[4] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[4] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'type' in value:
            AdvisorySpeedType.encode(encoding_rule, value['type'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            SpeedAdvice.encode(encoding_rule, value['speed'], value_tracker, stream)
        if preamble_bits[2]:
            SpeedConfidence.encode(encoding_rule, value['confidence'], value_tracker, stream)
        if preamble_bits[3]:
            ZoneLength.encode(encoding_rule, value['distance'], value_tracker, stream)
        if preamble_bits[4]:
            AmbientAirPressure.encode(encoding_rule, value['class'], value_tracker, stream)
        if preamble_bits[5]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = AdvisorySpeed()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['type'] = AdvisorySpeedType.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['speed'] = SpeedAdvice.decode(encoding_rule, stream, value_tracker)
        elif 'speed' in self._def_vals:
            value['speed'] = self._def_vals['speed']
        if preamble_bits[2]:
            value['confidence'] = SpeedConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'confidence' in self._def_vals:
            value['confidence'] = self._def_vals['confidence']
        if preamble_bits[3]:
            value['distance'] = ZoneLength.decode(encoding_rule, stream, value_tracker)
        elif 'distance' in self._def_vals:
            value['distance'] = self._def_vals['distance']
        if preamble_bits[4]:
            value['class'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'class' in self._def_vals:
            value['class'] = self._def_vals['class']
        if preamble_bits[5]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = AdvisorySpeed()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'type' in value:
            AdvisorySpeedType.validate(value['type'], errors, '{}/{}'.format(comp_path ,'type'))
        elif 'type' not in value:
            report_missing_field(type(self).__name__, 'type', errors, comp_path)
        if 'speed' in value:
            SpeedAdvice.validate(value['speed'], errors, '{}/{}'.format(comp_path ,'speed'))
        if 'confidence' in value:
            SpeedConfidence.validate(value['confidence'], errors, '{}/{}'.format(comp_path ,'confidence'))
        if 'distance' in value:
            ZoneLength.validate(value['distance'], errors, '{}/{}'.format(comp_path ,'distance'))
        if 'class' in value:
            AmbientAirPressure.validate(value['class'], errors, '{}/{}'.format(comp_path ,'class'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class AdvisorySpeedList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,16)]}}]
        self._unique_indetifier = "DSRC.AdvisorySpeedList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                AdvisorySpeed.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                AdvisorySpeed.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(AdvisorySpeed.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = AdvisorySpeedList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(AdvisorySpeed.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = AdvisorySpeedList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = AdvisorySpeedList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                AdvisorySpeed.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class AntennaOffsetSet:
    def __init__(self):
        self._comp_types = {"antOffsetX" : Offset_B12, "antOffsetY" : Offset_B09, "antOffsetZ" : Offset_B10}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.AntennaOffsetSet"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = AntennaOffsetSet()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'antOffsetX' in value:
            Offset_B12.encode(encoding_rule, value['antOffsetX'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'antOffsetY' in value:
            Offset_B09.encode(encoding_rule, value['antOffsetY'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'antOffsetZ' in value:
            Offset_B10.encode(encoding_rule, value['antOffsetZ'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = AntennaOffsetSet()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['antOffsetX'] = Offset_B12.decode(encoding_rule, stream, value_tracker)
        value['antOffsetY'] = Offset_B09.decode(encoding_rule, stream, value_tracker)
        value['antOffsetZ'] = Offset_B10.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = AntennaOffsetSet()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'antOffsetX' in value:
            Offset_B12.validate(value['antOffsetX'], errors, '{}/{}'.format(comp_path ,'antOffsetX'))
        elif 'antOffsetX' not in value:
            report_missing_field(type(self).__name__, 'antOffsetX', errors, comp_path)
        if 'antOffsetY' in value:
            Offset_B09.validate(value['antOffsetY'], errors, '{}/{}'.format(comp_path ,'antOffsetY'))
        elif 'antOffsetY' not in value:
            report_missing_field(type(self).__name__, 'antOffsetY', errors, comp_path)
        if 'antOffsetZ' in value:
            Offset_B10.validate(value['antOffsetZ'], errors, '{}/{}'.format(comp_path ,'antOffsetZ'))
        elif 'antOffsetZ' not in value:
            report_missing_field(type(self).__name__, 'antOffsetZ', errors, comp_path)

        return errors

class ApproachOrLane:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.ApproachOrLane"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"approach": 0, "lane": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = ApproachOrLane()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'approach':
                ApproachID.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'lane':
                AmbientAirPressure.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = ApproachOrLane()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'approach':
                alternative = ApproachID.decode(encoding_rule, stream, value_tracker)
            if identifier == 'lane':
                alternative = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = ApproachOrLane()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'approach' in value:
            ApproachID.validate(value['approach'], errors, '{}/{}'.format(comp_path ,'approach'))
            is_checked = True
        if 'lane' in value:
            AmbientAirPressure.validate(value['lane'], errors, '{}/{}'.format(comp_path ,'lane'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class BrakeSystemStatus:
    def __init__(self):
        self._comp_types = {"wheelBrakes" : BrakeAppliedStatus, "traction" : AntiLockBrakeStatus, "abs" : AntiLockBrakeStatus, "scs" : AntiLockBrakeStatus, "brakeBoost" : BrakeBoostApplied, "auxBrakes" : AuxiliaryBrakeStatus}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.BrakeSystemStatus"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = BrakeSystemStatus()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'wheelBrakes' in value:
            BrakeAppliedStatus.encode(encoding_rule, value['wheelBrakes'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'traction' in value:
            AntiLockBrakeStatus.encode(encoding_rule, value['traction'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'abs' in value:
            AntiLockBrakeStatus.encode(encoding_rule, value['abs'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'scs' in value:
            AntiLockBrakeStatus.encode(encoding_rule, value['scs'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'brakeBoost' in value:
            BrakeBoostApplied.encode(encoding_rule, value['brakeBoost'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'auxBrakes' in value:
            AuxiliaryBrakeStatus.encode(encoding_rule, value['auxBrakes'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = BrakeSystemStatus()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['wheelBrakes'] = BrakeAppliedStatus.decode(encoding_rule, stream, value_tracker)
        value['traction'] = AntiLockBrakeStatus.decode(encoding_rule, stream, value_tracker)
        value['abs'] = AntiLockBrakeStatus.decode(encoding_rule, stream, value_tracker)
        value['scs'] = AntiLockBrakeStatus.decode(encoding_rule, stream, value_tracker)
        value['brakeBoost'] = BrakeBoostApplied.decode(encoding_rule, stream, value_tracker)
        value['auxBrakes'] = AuxiliaryBrakeStatus.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = BrakeSystemStatus()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'wheelBrakes' in value:
            BrakeAppliedStatus.validate(value['wheelBrakes'], errors, '{}/{}'.format(comp_path ,'wheelBrakes'))
        elif 'wheelBrakes' not in value:
            report_missing_field(type(self).__name__, 'wheelBrakes', errors, comp_path)
        if 'traction' in value:
            AntiLockBrakeStatus.validate(value['traction'], errors, '{}/{}'.format(comp_path ,'traction'))
        elif 'traction' not in value:
            report_missing_field(type(self).__name__, 'traction', errors, comp_path)
        if 'abs' in value:
            AntiLockBrakeStatus.validate(value['abs'], errors, '{}/{}'.format(comp_path ,'abs'))
        elif 'abs' not in value:
            report_missing_field(type(self).__name__, 'abs', errors, comp_path)
        if 'scs' in value:
            AntiLockBrakeStatus.validate(value['scs'], errors, '{}/{}'.format(comp_path ,'scs'))
        elif 'scs' not in value:
            report_missing_field(type(self).__name__, 'scs', errors, comp_path)
        if 'brakeBoost' in value:
            BrakeBoostApplied.validate(value['brakeBoost'], errors, '{}/{}'.format(comp_path ,'brakeBoost'))
        elif 'brakeBoost' not in value:
            report_missing_field(type(self).__name__, 'brakeBoost', errors, comp_path)
        if 'auxBrakes' in value:
            AuxiliaryBrakeStatus.validate(value['auxBrakes'], errors, '{}/{}'.format(comp_path ,'auxBrakes'))
        elif 'auxBrakes' not in value:
            report_missing_field(type(self).__name__, 'auxBrakes', errors, comp_path)

        return errors

class BSMcoreData:
    def __init__(self):
        self._comp_types = {"msgCnt" : BumperHeight, "id" : TemporaryID, "secMark" : DSecond, "lat" : Latitude, "long" : Longitude, "elev" : Elevation, "accuracy" : PositionalAccuracy, "transmission" : TransmissionState, "speed" : Speed, "heading" : Angle, "angle" : SteeringWheelAngle, "accelSet" : AccelerationSet4Way, "brakes" : BrakeSystemStatus, "size" : VehicleSize}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.BSMcoreData"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = BSMcoreData()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'msgCnt' in value:
            BumperHeight.encode(encoding_rule, value['msgCnt'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'id' in value:
            TemporaryID.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'secMark' in value:
            DSecond.encode(encoding_rule, value['secMark'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            Latitude.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'long' in value:
            Longitude.encode(encoding_rule, value['long'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'elev' in value:
            Elevation.encode(encoding_rule, value['elev'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'accuracy' in value:
            PositionalAccuracy.encode(encoding_rule, value['accuracy'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'transmission' in value:
            TransmissionState.encode(encoding_rule, value['transmission'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'speed' in value:
            Speed.encode(encoding_rule, value['speed'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'heading' in value:
            Angle.encode(encoding_rule, value['heading'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'angle' in value:
            SteeringWheelAngle.encode(encoding_rule, value['angle'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'accelSet' in value:
            AccelerationSet4Way.encode(encoding_rule, value['accelSet'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'brakes' in value:
            BrakeSystemStatus.encode(encoding_rule, value['brakes'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'size' in value:
            VehicleSize.encode(encoding_rule, value['size'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = BSMcoreData()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['msgCnt'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        value['id'] = TemporaryID.decode(encoding_rule, stream, value_tracker)
        value['secMark'] = DSecond.decode(encoding_rule, stream, value_tracker)
        value['lat'] = Latitude.decode(encoding_rule, stream, value_tracker)
        value['long'] = Longitude.decode(encoding_rule, stream, value_tracker)
        value['elev'] = Elevation.decode(encoding_rule, stream, value_tracker)
        value['accuracy'] = PositionalAccuracy.decode(encoding_rule, stream, value_tracker)
        value['transmission'] = TransmissionState.decode(encoding_rule, stream, value_tracker)
        value['speed'] = Speed.decode(encoding_rule, stream, value_tracker)
        value['heading'] = Angle.decode(encoding_rule, stream, value_tracker)
        value['angle'] = SteeringWheelAngle.decode(encoding_rule, stream, value_tracker)
        value['accelSet'] = AccelerationSet4Way.decode(encoding_rule, stream, value_tracker)
        value['brakes'] = BrakeSystemStatus.decode(encoding_rule, stream, value_tracker)
        value['size'] = VehicleSize.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = BSMcoreData()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'msgCnt' in value:
            BumperHeight.validate(value['msgCnt'], errors, '{}/{}'.format(comp_path ,'msgCnt'))
        elif 'msgCnt' not in value:
            report_missing_field(type(self).__name__, 'msgCnt', errors, comp_path)
        if 'id' in value:
            TemporaryID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'secMark' in value:
            DSecond.validate(value['secMark'], errors, '{}/{}'.format(comp_path ,'secMark'))
        elif 'secMark' not in value:
            report_missing_field(type(self).__name__, 'secMark', errors, comp_path)
        if 'lat' in value:
            Latitude.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)
        if 'long' in value:
            Longitude.validate(value['long'], errors, '{}/{}'.format(comp_path ,'long'))
        elif 'long' not in value:
            report_missing_field(type(self).__name__, 'long', errors, comp_path)
        if 'elev' in value:
            Elevation.validate(value['elev'], errors, '{}/{}'.format(comp_path ,'elev'))
        elif 'elev' not in value:
            report_missing_field(type(self).__name__, 'elev', errors, comp_path)
        if 'accuracy' in value:
            PositionalAccuracy.validate(value['accuracy'], errors, '{}/{}'.format(comp_path ,'accuracy'))
        elif 'accuracy' not in value:
            report_missing_field(type(self).__name__, 'accuracy', errors, comp_path)
        if 'transmission' in value:
            TransmissionState.validate(value['transmission'], errors, '{}/{}'.format(comp_path ,'transmission'))
        elif 'transmission' not in value:
            report_missing_field(type(self).__name__, 'transmission', errors, comp_path)
        if 'speed' in value:
            Speed.validate(value['speed'], errors, '{}/{}'.format(comp_path ,'speed'))
        elif 'speed' not in value:
            report_missing_field(type(self).__name__, 'speed', errors, comp_path)
        if 'heading' in value:
            Angle.validate(value['heading'], errors, '{}/{}'.format(comp_path ,'heading'))
        elif 'heading' not in value:
            report_missing_field(type(self).__name__, 'heading', errors, comp_path)
        if 'angle' in value:
            SteeringWheelAngle.validate(value['angle'], errors, '{}/{}'.format(comp_path ,'angle'))
        elif 'angle' not in value:
            report_missing_field(type(self).__name__, 'angle', errors, comp_path)
        if 'accelSet' in value:
            AccelerationSet4Way.validate(value['accelSet'], errors, '{}/{}'.format(comp_path ,'accelSet'))
        elif 'accelSet' not in value:
            report_missing_field(type(self).__name__, 'accelSet', errors, comp_path)
        if 'brakes' in value:
            BrakeSystemStatus.validate(value['brakes'], errors, '{}/{}'.format(comp_path ,'brakes'))
        elif 'brakes' not in value:
            report_missing_field(type(self).__name__, 'brakes', errors, comp_path)
        if 'size' in value:
            VehicleSize.validate(value['size'], errors, '{}/{}'.format(comp_path ,'size'))
        elif 'size' not in value:
            report_missing_field(type(self).__name__, 'size', errors, comp_path)

        return errors

class BumperHeights:
    def __init__(self):
        self._comp_types = {"front" : BumperHeight, "rear" : BumperHeight}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.BumperHeights"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = BumperHeights()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'front' in value:
            BumperHeight.encode(encoding_rule, value['front'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'rear' in value:
            BumperHeight.encode(encoding_rule, value['rear'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = BumperHeights()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['front'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        value['rear'] = BumperHeight.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = BumperHeights()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'front' in value:
            BumperHeight.validate(value['front'], errors, '{}/{}'.format(comp_path ,'front'))
        elif 'front' not in value:
            report_missing_field(type(self).__name__, 'front', errors, comp_path)
        if 'rear' in value:
            BumperHeight.validate(value['rear'], errors, '{}/{}'.format(comp_path ,'rear'))
        elif 'rear' not in value:
            report_missing_field(type(self).__name__, 'rear', errors, comp_path)

        return errors

class Circle:
    def __init__(self):
        self._comp_types = {"center" : Position3D, "radius" : DYear, "units" : DistanceUnits}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Circle"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Circle()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'center' in value:
            Position3D.encode(encoding_rule, value['center'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'radius' in value:
            DYear.encode(encoding_rule, value['radius'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'units' in value:
            DistanceUnits.encode(encoding_rule, value['units'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Circle()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['center'] = Position3D.decode(encoding_rule, stream, value_tracker)
        value['radius'] = DYear.decode(encoding_rule, stream, value_tracker)
        value['units'] = DistanceUnits.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Circle()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'center' in value:
            Position3D.validate(value['center'], errors, '{}/{}'.format(comp_path ,'center'))
        elif 'center' not in value:
            report_missing_field(type(self).__name__, 'center', errors, comp_path)
        if 'radius' in value:
            DYear.validate(value['radius'], errors, '{}/{}'.format(comp_path ,'radius'))
        elif 'radius' not in value:
            report_missing_field(type(self).__name__, 'radius', errors, comp_path)
        if 'units' in value:
            DistanceUnits.validate(value['units'], errors, '{}/{}'.format(comp_path ,'units'))
        elif 'units' not in value:
            report_missing_field(type(self).__name__, 'units', errors, comp_path)

        return errors

class ComputedLane:
    def __init__(self):
        self._comp_types = {"referenceLaneId" : AmbientAirPressure, "offsetXaxis" : ComputedLane__4, "offsetYaxis" : ComputedLane__4, "rotateXY" : Angle, "scaleXaxis" : Offset_B12, "scaleYaxis" : Offset_B12, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.ComputedLane"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ComputedLane()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('rotateXY' in value and 'rotateXY' not in self._def_vals):
            preamble_bits[0] = True
        elif ('rotateXY' in value and 'rotateXY' in self._def_vals):
            if not value_tracker.are_def_eq(value['rotateXY'], self._def_vals['rotateXY'], self._comp_types['rotateXY']):
                preamble_bits[0] = True
        if ('scaleXaxis' in value and 'scaleXaxis' not in self._def_vals):
            preamble_bits[1] = True
        elif ('scaleXaxis' in value and 'scaleXaxis' in self._def_vals):
            if not value_tracker.are_def_eq(value['scaleXaxis'], self._def_vals['scaleXaxis'], self._comp_types['scaleXaxis']):
                preamble_bits[1] = True
        if ('scaleYaxis' in value and 'scaleYaxis' not in self._def_vals):
            preamble_bits[2] = True
        elif ('scaleYaxis' in value and 'scaleYaxis' in self._def_vals):
            if not value_tracker.are_def_eq(value['scaleYaxis'], self._def_vals['scaleYaxis'], self._comp_types['scaleYaxis']):
                preamble_bits[2] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[3] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'referenceLaneId' in value:
            AmbientAirPressure.encode(encoding_rule, value['referenceLaneId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'offsetXaxis' in value:
            ComputedLane__4.encode(encoding_rule, value['offsetXaxis'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'offsetYaxis' in value:
            ComputedLane__4.encode(encoding_rule, value['offsetYaxis'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            Angle.encode(encoding_rule, value['rotateXY'], value_tracker, stream)
        if preamble_bits[2]:
            Offset_B12.encode(encoding_rule, value['scaleXaxis'], value_tracker, stream)
        if preamble_bits[3]:
            Offset_B12.encode(encoding_rule, value['scaleYaxis'], value_tracker, stream)
        if preamble_bits[4]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ComputedLane()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['referenceLaneId'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['offsetXaxis'] = ComputedLane__4.decode(encoding_rule, stream, value_tracker)
        value['offsetYaxis'] = ComputedLane__4.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['rotateXY'] = Angle.decode(encoding_rule, stream, value_tracker)
        elif 'rotateXY' in self._def_vals:
            value['rotateXY'] = self._def_vals['rotateXY']
        if preamble_bits[2]:
            value['scaleXaxis'] = Offset_B12.decode(encoding_rule, stream, value_tracker)
        elif 'scaleXaxis' in self._def_vals:
            value['scaleXaxis'] = self._def_vals['scaleXaxis']
        if preamble_bits[3]:
            value['scaleYaxis'] = Offset_B12.decode(encoding_rule, stream, value_tracker)
        elif 'scaleYaxis' in self._def_vals:
            value['scaleYaxis'] = self._def_vals['scaleYaxis']
        if preamble_bits[4]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ComputedLane()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'referenceLaneId' in value:
            AmbientAirPressure.validate(value['referenceLaneId'], errors, '{}/{}'.format(comp_path ,'referenceLaneId'))
        elif 'referenceLaneId' not in value:
            report_missing_field(type(self).__name__, 'referenceLaneId', errors, comp_path)
        if 'offsetXaxis' in value:
            ComputedLane__4.validate(value['offsetXaxis'], errors, '{}/{}'.format(comp_path ,'offsetXaxis'))
        elif 'offsetXaxis' not in value:
            report_missing_field(type(self).__name__, 'offsetXaxis', errors, comp_path)
        if 'offsetYaxis' in value:
            ComputedLane__4.validate(value['offsetYaxis'], errors, '{}/{}'.format(comp_path ,'offsetYaxis'))
        elif 'offsetYaxis' not in value:
            report_missing_field(type(self).__name__, 'offsetYaxis', errors, comp_path)
        if 'rotateXY' in value:
            Angle.validate(value['rotateXY'], errors, '{}/{}'.format(comp_path ,'rotateXY'))
        if 'scaleXaxis' in value:
            Offset_B12.validate(value['scaleXaxis'], errors, '{}/{}'.format(comp_path ,'scaleXaxis'))
        if 'scaleYaxis' in value:
            Offset_B12.validate(value['scaleYaxis'], errors, '{}/{}'.format(comp_path ,'scaleYaxis'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class ComputedLane__4:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.ComputedLane.offsetXaxis"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"small": 0, "large": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = ComputedLane__4()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'small':
                DrivenLineOffsetSm.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'large':
                DrivenLineOffsetLg.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = ComputedLane__4()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'small':
                alternative = DrivenLineOffsetSm.decode(encoding_rule, stream, value_tracker)
            if identifier == 'large':
                alternative = DrivenLineOffsetLg.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = ComputedLane__4()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'small' in value:
            DrivenLineOffsetSm.validate(value['small'], errors, '{}/{}'.format(comp_path ,'small'))
            is_checked = True
        if 'large' in value:
            DrivenLineOffsetLg.validate(value['large'], errors, '{}/{}'.format(comp_path ,'large'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

ComputedLane__7 = ComputedLane__4

class ConfidenceSet:
    def __init__(self):
        self._comp_types = {"accelConfidence" : AccelSteerYawRateConfidence, "speedConfidence" : SpeedandHeadingandThrottleConfidence, "timeConfidence" : TimeConfidence, "posConfidence" : PositionConfidenceSet, "steerConfidence" : SteeringWheelAngleConfidence, "headingConfidence" : HeadingConfidence, "throttleConfidence" : ThrottleConfidence}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.ConfidenceSet"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ConfidenceSet()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 7

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('accelConfidence' in value and 'accelConfidence' not in self._def_vals):
            preamble_bits[0] = True
        elif ('accelConfidence' in value and 'accelConfidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['accelConfidence'], self._def_vals['accelConfidence'], self._comp_types['accelConfidence']):
                preamble_bits[0] = True
        if ('speedConfidence' in value and 'speedConfidence' not in self._def_vals):
            preamble_bits[1] = True
        elif ('speedConfidence' in value and 'speedConfidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['speedConfidence'], self._def_vals['speedConfidence'], self._comp_types['speedConfidence']):
                preamble_bits[1] = True
        if ('timeConfidence' in value and 'timeConfidence' not in self._def_vals):
            preamble_bits[2] = True
        elif ('timeConfidence' in value and 'timeConfidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeConfidence'], self._def_vals['timeConfidence'], self._comp_types['timeConfidence']):
                preamble_bits[2] = True
        if ('posConfidence' in value and 'posConfidence' not in self._def_vals):
            preamble_bits[3] = True
        elif ('posConfidence' in value and 'posConfidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['posConfidence'], self._def_vals['posConfidence'], self._comp_types['posConfidence']):
                preamble_bits[3] = True
        if ('steerConfidence' in value and 'steerConfidence' not in self._def_vals):
            preamble_bits[4] = True
        elif ('steerConfidence' in value and 'steerConfidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['steerConfidence'], self._def_vals['steerConfidence'], self._comp_types['steerConfidence']):
                preamble_bits[4] = True
        if ('headingConfidence' in value and 'headingConfidence' not in self._def_vals):
            preamble_bits[5] = True
        elif ('headingConfidence' in value and 'headingConfidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['headingConfidence'], self._def_vals['headingConfidence'], self._comp_types['headingConfidence']):
                preamble_bits[5] = True
        if ('throttleConfidence' in value and 'throttleConfidence' not in self._def_vals):
            preamble_bits[6] = True
        elif ('throttleConfidence' in value and 'throttleConfidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['throttleConfidence'], self._def_vals['throttleConfidence'], self._comp_types['throttleConfidence']):
                preamble_bits[6] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            AccelSteerYawRateConfidence.encode(encoding_rule, value['accelConfidence'], value_tracker, stream)
        if preamble_bits[2]:
            SpeedandHeadingandThrottleConfidence.encode(encoding_rule, value['speedConfidence'], value_tracker, stream)
        if preamble_bits[3]:
            TimeConfidence.encode(encoding_rule, value['timeConfidence'], value_tracker, stream)
        if preamble_bits[4]:
            PositionConfidenceSet.encode(encoding_rule, value['posConfidence'], value_tracker, stream)
        if preamble_bits[5]:
            SteeringWheelAngleConfidence.encode(encoding_rule, value['steerConfidence'], value_tracker, stream)
        if preamble_bits[6]:
            HeadingConfidence.encode(encoding_rule, value['headingConfidence'], value_tracker, stream)
        if preamble_bits[7]:
            ThrottleConfidence.encode(encoding_rule, value['throttleConfidence'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ConfidenceSet()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 7

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['accelConfidence'] = AccelSteerYawRateConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'accelConfidence' in self._def_vals:
            value['accelConfidence'] = self._def_vals['accelConfidence']
        if preamble_bits[2]:
            value['speedConfidence'] = SpeedandHeadingandThrottleConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'speedConfidence' in self._def_vals:
            value['speedConfidence'] = self._def_vals['speedConfidence']
        if preamble_bits[3]:
            value['timeConfidence'] = TimeConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'timeConfidence' in self._def_vals:
            value['timeConfidence'] = self._def_vals['timeConfidence']
        if preamble_bits[4]:
            value['posConfidence'] = PositionConfidenceSet.decode(encoding_rule, stream, value_tracker)
        elif 'posConfidence' in self._def_vals:
            value['posConfidence'] = self._def_vals['posConfidence']
        if preamble_bits[5]:
            value['steerConfidence'] = SteeringWheelAngleConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'steerConfidence' in self._def_vals:
            value['steerConfidence'] = self._def_vals['steerConfidence']
        if preamble_bits[6]:
            value['headingConfidence'] = HeadingConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'headingConfidence' in self._def_vals:
            value['headingConfidence'] = self._def_vals['headingConfidence']
        if preamble_bits[7]:
            value['throttleConfidence'] = ThrottleConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'throttleConfidence' in self._def_vals:
            value['throttleConfidence'] = self._def_vals['throttleConfidence']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ConfidenceSet()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'accelConfidence' in value:
            AccelSteerYawRateConfidence.validate(value['accelConfidence'], errors, '{}/{}'.format(comp_path ,'accelConfidence'))
        if 'speedConfidence' in value:
            SpeedandHeadingandThrottleConfidence.validate(value['speedConfidence'], errors, '{}/{}'.format(comp_path ,'speedConfidence'))
        if 'timeConfidence' in value:
            TimeConfidence.validate(value['timeConfidence'], errors, '{}/{}'.format(comp_path ,'timeConfidence'))
        if 'posConfidence' in value:
            PositionConfidenceSet.validate(value['posConfidence'], errors, '{}/{}'.format(comp_path ,'posConfidence'))
        if 'steerConfidence' in value:
            SteeringWheelAngleConfidence.validate(value['steerConfidence'], errors, '{}/{}'.format(comp_path ,'steerConfidence'))
        if 'headingConfidence' in value:
            HeadingConfidence.validate(value['headingConfidence'], errors, '{}/{}'.format(comp_path ,'headingConfidence'))
        if 'throttleConfidence' in value:
            ThrottleConfidence.validate(value['throttleConfidence'], errors, '{}/{}'.format(comp_path ,'throttleConfidence'))

        return errors

class ConnectingLane:
    def __init__(self):
        self._comp_types = {"lane" : AmbientAirPressure, "maneuver" : AllowedManeuvers}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.ConnectingLane"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ConnectingLane()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('maneuver' in value and 'maneuver' not in self._def_vals):
            preamble_bits[0] = True
        elif ('maneuver' in value and 'maneuver' in self._def_vals):
            if not value_tracker.are_def_eq(value['maneuver'], self._def_vals['maneuver'], self._comp_types['maneuver']):
                preamble_bits[0] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'lane' in value:
            AmbientAirPressure.encode(encoding_rule, value['lane'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            AllowedManeuvers.encode(encoding_rule, value['maneuver'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ConnectingLane()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['lane'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['maneuver'] = AllowedManeuvers.decode(encoding_rule, stream, value_tracker)
        elif 'maneuver' in self._def_vals:
            value['maneuver'] = self._def_vals['maneuver']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ConnectingLane()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lane' in value:
            AmbientAirPressure.validate(value['lane'], errors, '{}/{}'.format(comp_path ,'lane'))
        elif 'lane' not in value:
            report_missing_field(type(self).__name__, 'lane', errors, comp_path)
        if 'maneuver' in value:
            AllowedManeuvers.validate(value['maneuver'], errors, '{}/{}'.format(comp_path ,'maneuver'))

        return errors

class Connection:
    def __init__(self):
        self._comp_types = {"connectingLane" : ConnectingLane, "remoteIntersection" : IntersectionReferenceID, "signalGroup" : AmbientAirPressure, "userClass" : AmbientAirPressure, "connectionID" : AmbientAirPressure}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Connection"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Connection()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('remoteIntersection' in value and 'remoteIntersection' not in self._def_vals):
            preamble_bits[0] = True
        elif ('remoteIntersection' in value and 'remoteIntersection' in self._def_vals):
            if not value_tracker.are_def_eq(value['remoteIntersection'], self._def_vals['remoteIntersection'], self._comp_types['remoteIntersection']):
                preamble_bits[0] = True
        if ('signalGroup' in value and 'signalGroup' not in self._def_vals):
            preamble_bits[1] = True
        elif ('signalGroup' in value and 'signalGroup' in self._def_vals):
            if not value_tracker.are_def_eq(value['signalGroup'], self._def_vals['signalGroup'], self._comp_types['signalGroup']):
                preamble_bits[1] = True
        if ('userClass' in value and 'userClass' not in self._def_vals):
            preamble_bits[2] = True
        elif ('userClass' in value and 'userClass' in self._def_vals):
            if not value_tracker.are_def_eq(value['userClass'], self._def_vals['userClass'], self._comp_types['userClass']):
                preamble_bits[2] = True
        if ('connectionID' in value and 'connectionID' not in self._def_vals):
            preamble_bits[3] = True
        elif ('connectionID' in value and 'connectionID' in self._def_vals):
            if not value_tracker.are_def_eq(value['connectionID'], self._def_vals['connectionID'], self._comp_types['connectionID']):
                preamble_bits[3] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'connectingLane' in value:
            ConnectingLane.encode(encoding_rule, value['connectingLane'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            IntersectionReferenceID.encode(encoding_rule, value['remoteIntersection'], value_tracker, stream)
        if preamble_bits[1]:
            AmbientAirPressure.encode(encoding_rule, value['signalGroup'], value_tracker, stream)
        if preamble_bits[2]:
            AmbientAirPressure.encode(encoding_rule, value['userClass'], value_tracker, stream)
        if preamble_bits[3]:
            AmbientAirPressure.encode(encoding_rule, value['connectionID'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Connection()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['connectingLane'] = ConnectingLane.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['remoteIntersection'] = IntersectionReferenceID.decode(encoding_rule, stream, value_tracker)
        elif 'remoteIntersection' in self._def_vals:
            value['remoteIntersection'] = self._def_vals['remoteIntersection']
        if preamble_bits[1]:
            value['signalGroup'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'signalGroup' in self._def_vals:
            value['signalGroup'] = self._def_vals['signalGroup']
        if preamble_bits[2]:
            value['userClass'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'userClass' in self._def_vals:
            value['userClass'] = self._def_vals['userClass']
        if preamble_bits[3]:
            value['connectionID'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'connectionID' in self._def_vals:
            value['connectionID'] = self._def_vals['connectionID']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Connection()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'connectingLane' in value:
            ConnectingLane.validate(value['connectingLane'], errors, '{}/{}'.format(comp_path ,'connectingLane'))
        elif 'connectingLane' not in value:
            report_missing_field(type(self).__name__, 'connectingLane', errors, comp_path)
        if 'remoteIntersection' in value:
            IntersectionReferenceID.validate(value['remoteIntersection'], errors, '{}/{}'.format(comp_path ,'remoteIntersection'))
        if 'signalGroup' in value:
            AmbientAirPressure.validate(value['signalGroup'], errors, '{}/{}'.format(comp_path ,'signalGroup'))
        if 'userClass' in value:
            AmbientAirPressure.validate(value['userClass'], errors, '{}/{}'.format(comp_path ,'userClass'))
        if 'connectionID' in value:
            AmbientAirPressure.validate(value['connectionID'], errors, '{}/{}'.format(comp_path ,'connectionID'))

        return errors

class ConnectionManeuverAssist:
    def __init__(self):
        self._comp_types = {"connectionID" : AmbientAirPressure, "queueLength" : ZoneLength, "availableStorageLength" : ZoneLength, "waitOnStop" : IsDolly, "pedBicycleDetect" : IsDolly, "regional" : ConnectionManeuverAssist__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.ConnectionManeuverAssist"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ConnectionManeuverAssist()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('queueLength' in value and 'queueLength' not in self._def_vals):
            preamble_bits[0] = True
        elif ('queueLength' in value and 'queueLength' in self._def_vals):
            if not value_tracker.are_def_eq(value['queueLength'], self._def_vals['queueLength'], self._comp_types['queueLength']):
                preamble_bits[0] = True
        if ('availableStorageLength' in value and 'availableStorageLength' not in self._def_vals):
            preamble_bits[1] = True
        elif ('availableStorageLength' in value and 'availableStorageLength' in self._def_vals):
            if not value_tracker.are_def_eq(value['availableStorageLength'], self._def_vals['availableStorageLength'], self._comp_types['availableStorageLength']):
                preamble_bits[1] = True
        if ('waitOnStop' in value and 'waitOnStop' not in self._def_vals):
            preamble_bits[2] = True
        elif ('waitOnStop' in value and 'waitOnStop' in self._def_vals):
            if not value_tracker.are_def_eq(value['waitOnStop'], self._def_vals['waitOnStop'], self._comp_types['waitOnStop']):
                preamble_bits[2] = True
        if ('pedBicycleDetect' in value and 'pedBicycleDetect' not in self._def_vals):
            preamble_bits[3] = True
        elif ('pedBicycleDetect' in value and 'pedBicycleDetect' in self._def_vals):
            if not value_tracker.are_def_eq(value['pedBicycleDetect'], self._def_vals['pedBicycleDetect'], self._comp_types['pedBicycleDetect']):
                preamble_bits[3] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[4] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[4] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'connectionID' in value:
            AmbientAirPressure.encode(encoding_rule, value['connectionID'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            ZoneLength.encode(encoding_rule, value['queueLength'], value_tracker, stream)
        if preamble_bits[2]:
            ZoneLength.encode(encoding_rule, value['availableStorageLength'], value_tracker, stream)
        if preamble_bits[3]:
            IsDolly.encode(encoding_rule, value['waitOnStop'], value_tracker, stream)
        if preamble_bits[4]:
            IsDolly.encode(encoding_rule, value['pedBicycleDetect'], value_tracker, stream)
        if preamble_bits[5]:
            ConnectionManeuverAssist__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ConnectionManeuverAssist()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['connectionID'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['queueLength'] = ZoneLength.decode(encoding_rule, stream, value_tracker)
        elif 'queueLength' in self._def_vals:
            value['queueLength'] = self._def_vals['queueLength']
        if preamble_bits[2]:
            value['availableStorageLength'] = ZoneLength.decode(encoding_rule, stream, value_tracker)
        elif 'availableStorageLength' in self._def_vals:
            value['availableStorageLength'] = self._def_vals['availableStorageLength']
        if preamble_bits[3]:
            value['waitOnStop'] = IsDolly.decode(encoding_rule, stream, value_tracker)
        elif 'waitOnStop' in self._def_vals:
            value['waitOnStop'] = self._def_vals['waitOnStop']
        if preamble_bits[4]:
            value['pedBicycleDetect'] = IsDolly.decode(encoding_rule, stream, value_tracker)
        elif 'pedBicycleDetect' in self._def_vals:
            value['pedBicycleDetect'] = self._def_vals['pedBicycleDetect']
        if preamble_bits[5]:
            value['regional'] = ConnectionManeuverAssist__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ConnectionManeuverAssist()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'connectionID' in value:
            AmbientAirPressure.validate(value['connectionID'], errors, '{}/{}'.format(comp_path ,'connectionID'))
        elif 'connectionID' not in value:
            report_missing_field(type(self).__name__, 'connectionID', errors, comp_path)
        if 'queueLength' in value:
            ZoneLength.validate(value['queueLength'], errors, '{}/{}'.format(comp_path ,'queueLength'))
        if 'availableStorageLength' in value:
            ZoneLength.validate(value['availableStorageLength'], errors, '{}/{}'.format(comp_path ,'availableStorageLength'))
        if 'waitOnStop' in value:
            IsDolly.validate(value['waitOnStop'], errors, '{}/{}'.format(comp_path ,'waitOnStop'))
        if 'pedBicycleDetect' in value:
            IsDolly.validate(value['pedBicycleDetect'], errors, '{}/{}'.format(comp_path ,'pedBicycleDetect'))
        if 'regional' in value:
            ConnectionManeuverAssist__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class ConnectionManeuverAssist__7:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,4)]}}]
        self._unique_indetifier = "DSRC.ConnectionManeuverAssist.regional"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RegionalExtension_34.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RegionalExtension_34.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RegionalExtension_34.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = ConnectionManeuverAssist__7()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RegionalExtension_34.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = ConnectionManeuverAssist__7()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = ConnectionManeuverAssist__7()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RegionalExtension_34.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class ConnectsToList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,16)]}}]
        self._unique_indetifier = "DSRC.ConnectsToList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                Connection.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                Connection.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(Connection.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = ConnectsToList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(Connection.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = ConnectsToList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = ConnectsToList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                Connection.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class DataParameters:
    def __init__(self):
        self._comp_types = {"processMethod" : URL_Link, "processAgency" : URL_Link, "lastCheckedDate" : URL_Link, "geoidUsed" : URL_Link}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DataParameters"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DataParameters()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('processMethod' in value and 'processMethod' not in self._def_vals):
            preamble_bits[0] = True
        elif ('processMethod' in value and 'processMethod' in self._def_vals):
            if not value_tracker.are_def_eq(value['processMethod'], self._def_vals['processMethod'], self._comp_types['processMethod']):
                preamble_bits[0] = True
        if ('processAgency' in value and 'processAgency' not in self._def_vals):
            preamble_bits[1] = True
        elif ('processAgency' in value and 'processAgency' in self._def_vals):
            if not value_tracker.are_def_eq(value['processAgency'], self._def_vals['processAgency'], self._comp_types['processAgency']):
                preamble_bits[1] = True
        if ('lastCheckedDate' in value and 'lastCheckedDate' not in self._def_vals):
            preamble_bits[2] = True
        elif ('lastCheckedDate' in value and 'lastCheckedDate' in self._def_vals):
            if not value_tracker.are_def_eq(value['lastCheckedDate'], self._def_vals['lastCheckedDate'], self._comp_types['lastCheckedDate']):
                preamble_bits[2] = True
        if ('geoidUsed' in value and 'geoidUsed' not in self._def_vals):
            preamble_bits[3] = True
        elif ('geoidUsed' in value and 'geoidUsed' in self._def_vals):
            if not value_tracker.are_def_eq(value['geoidUsed'], self._def_vals['geoidUsed'], self._comp_types['geoidUsed']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            URL_Link.encode(encoding_rule, value['processMethod'], value_tracker, stream)
        if preamble_bits[2]:
            URL_Link.encode(encoding_rule, value['processAgency'], value_tracker, stream)
        if preamble_bits[3]:
            URL_Link.encode(encoding_rule, value['lastCheckedDate'], value_tracker, stream)
        if preamble_bits[4]:
            URL_Link.encode(encoding_rule, value['geoidUsed'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DataParameters()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['processMethod'] = URL_Link.decode(encoding_rule, stream, value_tracker)
        elif 'processMethod' in self._def_vals:
            value['processMethod'] = self._def_vals['processMethod']
        if preamble_bits[2]:
            value['processAgency'] = URL_Link.decode(encoding_rule, stream, value_tracker)
        elif 'processAgency' in self._def_vals:
            value['processAgency'] = self._def_vals['processAgency']
        if preamble_bits[3]:
            value['lastCheckedDate'] = URL_Link.decode(encoding_rule, stream, value_tracker)
        elif 'lastCheckedDate' in self._def_vals:
            value['lastCheckedDate'] = self._def_vals['lastCheckedDate']
        if preamble_bits[4]:
            value['geoidUsed'] = URL_Link.decode(encoding_rule, stream, value_tracker)
        elif 'geoidUsed' in self._def_vals:
            value['geoidUsed'] = self._def_vals['geoidUsed']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DataParameters()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'processMethod' in value:
            URL_Link.validate(value['processMethod'], errors, '{}/{}'.format(comp_path ,'processMethod'))
        if 'processAgency' in value:
            URL_Link.validate(value['processAgency'], errors, '{}/{}'.format(comp_path ,'processAgency'))
        if 'lastCheckedDate' in value:
            URL_Link.validate(value['lastCheckedDate'], errors, '{}/{}'.format(comp_path ,'lastCheckedDate'))
        if 'geoidUsed' in value:
            URL_Link.validate(value['geoidUsed'], errors, '{}/{}'.format(comp_path ,'geoidUsed'))

        return errors

class URL_Link:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"alphabet constraint","permitted":[[0,127]]}},{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1..255)","permitted":[(1,255)]}}]
        self._unique_indetifier = "DSRC.URL-Link"
        self._asn1Type = Asn1Type.String

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = URL_Link()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 255
        data_map['width_length_aligned'] = 8
        data_map['width_length_unaligned'] = 8
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        osspy.per.encode_string(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> str:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = URL_Link()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> str:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 255
        data_map['width_length_aligned'] = 8
        data_map['width_length_unaligned'] = 8
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        return osspy.per.decode_string(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = URL_Link()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

DataParameters__1 = URL_Link
DataParameters__3 = URL_Link
DataParameters__5 = URL_Link
DataParameters__7 = URL_Link

class DDate:
    def __init__(self):
        self._comp_types = {"year" : DYear, "month" : DMonth, "day" : DDay}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DDate"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DDate()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'year' in value:
            DYear.encode(encoding_rule, value['year'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'month' in value:
            DMonth.encode(encoding_rule, value['month'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'day' in value:
            DDay.encode(encoding_rule, value['day'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DDate()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['year'] = DYear.decode(encoding_rule, stream, value_tracker)
        value['month'] = DMonth.decode(encoding_rule, stream, value_tracker)
        value['day'] = DDay.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DDate()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'year' in value:
            DYear.validate(value['year'], errors, '{}/{}'.format(comp_path ,'year'))
        elif 'year' not in value:
            report_missing_field(type(self).__name__, 'year', errors, comp_path)
        if 'month' in value:
            DMonth.validate(value['month'], errors, '{}/{}'.format(comp_path ,'month'))
        elif 'month' not in value:
            report_missing_field(type(self).__name__, 'month', errors, comp_path)
        if 'day' in value:
            DDay.validate(value['day'], errors, '{}/{}'.format(comp_path ,'day'))
        elif 'day' not in value:
            report_missing_field(type(self).__name__, 'day', errors, comp_path)

        return errors

class DDateTime:
    def __init__(self):
        self._comp_types = {"year" : DYear, "month" : DMonth, "day" : DDay, "hour" : DDay, "minute" : DMinute, "second" : DSecond, "offset" : DOffset}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DDateTime"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DDateTime()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 7

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('year' in value and 'year' not in self._def_vals):
            preamble_bits[0] = True
        elif ('year' in value and 'year' in self._def_vals):
            if not value_tracker.are_def_eq(value['year'], self._def_vals['year'], self._comp_types['year']):
                preamble_bits[0] = True
        if ('month' in value and 'month' not in self._def_vals):
            preamble_bits[1] = True
        elif ('month' in value and 'month' in self._def_vals):
            if not value_tracker.are_def_eq(value['month'], self._def_vals['month'], self._comp_types['month']):
                preamble_bits[1] = True
        if ('day' in value and 'day' not in self._def_vals):
            preamble_bits[2] = True
        elif ('day' in value and 'day' in self._def_vals):
            if not value_tracker.are_def_eq(value['day'], self._def_vals['day'], self._comp_types['day']):
                preamble_bits[2] = True
        if ('hour' in value and 'hour' not in self._def_vals):
            preamble_bits[3] = True
        elif ('hour' in value and 'hour' in self._def_vals):
            if not value_tracker.are_def_eq(value['hour'], self._def_vals['hour'], self._comp_types['hour']):
                preamble_bits[3] = True
        if ('minute' in value and 'minute' not in self._def_vals):
            preamble_bits[4] = True
        elif ('minute' in value and 'minute' in self._def_vals):
            if not value_tracker.are_def_eq(value['minute'], self._def_vals['minute'], self._comp_types['minute']):
                preamble_bits[4] = True
        if ('second' in value and 'second' not in self._def_vals):
            preamble_bits[5] = True
        elif ('second' in value and 'second' in self._def_vals):
            if not value_tracker.are_def_eq(value['second'], self._def_vals['second'], self._comp_types['second']):
                preamble_bits[5] = True
        if ('offset' in value and 'offset' not in self._def_vals):
            preamble_bits[6] = True
        elif ('offset' in value and 'offset' in self._def_vals):
            if not value_tracker.are_def_eq(value['offset'], self._def_vals['offset'], self._comp_types['offset']):
                preamble_bits[6] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[0]:
            DYear.encode(encoding_rule, value['year'], value_tracker, stream)
        if preamble_bits[1]:
            DMonth.encode(encoding_rule, value['month'], value_tracker, stream)
        if preamble_bits[2]:
            DDay.encode(encoding_rule, value['day'], value_tracker, stream)
        if preamble_bits[3]:
            DDay.encode(encoding_rule, value['hour'], value_tracker, stream)
        if preamble_bits[4]:
            DMinute.encode(encoding_rule, value['minute'], value_tracker, stream)
        if preamble_bits[5]:
            DSecond.encode(encoding_rule, value['second'], value_tracker, stream)
        if preamble_bits[6]:
            DOffset.encode(encoding_rule, value['offset'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DDateTime()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 7

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[0]:
            value['year'] = DYear.decode(encoding_rule, stream, value_tracker)
        elif 'year' in self._def_vals:
            value['year'] = self._def_vals['year']
        if preamble_bits[1]:
            value['month'] = DMonth.decode(encoding_rule, stream, value_tracker)
        elif 'month' in self._def_vals:
            value['month'] = self._def_vals['month']
        if preamble_bits[2]:
            value['day'] = DDay.decode(encoding_rule, stream, value_tracker)
        elif 'day' in self._def_vals:
            value['day'] = self._def_vals['day']
        if preamble_bits[3]:
            value['hour'] = DDay.decode(encoding_rule, stream, value_tracker)
        elif 'hour' in self._def_vals:
            value['hour'] = self._def_vals['hour']
        if preamble_bits[4]:
            value['minute'] = DMinute.decode(encoding_rule, stream, value_tracker)
        elif 'minute' in self._def_vals:
            value['minute'] = self._def_vals['minute']
        if preamble_bits[5]:
            value['second'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'second' in self._def_vals:
            value['second'] = self._def_vals['second']
        if preamble_bits[6]:
            value['offset'] = DOffset.decode(encoding_rule, stream, value_tracker)
        elif 'offset' in self._def_vals:
            value['offset'] = self._def_vals['offset']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DDateTime()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'year' in value:
            DYear.validate(value['year'], errors, '{}/{}'.format(comp_path ,'year'))
        if 'month' in value:
            DMonth.validate(value['month'], errors, '{}/{}'.format(comp_path ,'month'))
        if 'day' in value:
            DDay.validate(value['day'], errors, '{}/{}'.format(comp_path ,'day'))
        if 'hour' in value:
            DDay.validate(value['hour'], errors, '{}/{}'.format(comp_path ,'hour'))
        if 'minute' in value:
            DMinute.validate(value['minute'], errors, '{}/{}'.format(comp_path ,'minute'))
        if 'second' in value:
            DSecond.validate(value['second'], errors, '{}/{}'.format(comp_path ,'second'))
        if 'offset' in value:
            DOffset.validate(value['offset'], errors, '{}/{}'.format(comp_path ,'offset'))

        return errors

class DFullTime:
    def __init__(self):
        self._comp_types = {"year" : DYear, "month" : DMonth, "day" : DDay, "hour" : DDay, "minute" : DMinute}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DFullTime"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DFullTime()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'year' in value:
            DYear.encode(encoding_rule, value['year'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'month' in value:
            DMonth.encode(encoding_rule, value['month'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'day' in value:
            DDay.encode(encoding_rule, value['day'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'hour' in value:
            DDay.encode(encoding_rule, value['hour'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'minute' in value:
            DMinute.encode(encoding_rule, value['minute'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DFullTime()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['year'] = DYear.decode(encoding_rule, stream, value_tracker)
        value['month'] = DMonth.decode(encoding_rule, stream, value_tracker)
        value['day'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['hour'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['minute'] = DMinute.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DFullTime()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'year' in value:
            DYear.validate(value['year'], errors, '{}/{}'.format(comp_path ,'year'))
        elif 'year' not in value:
            report_missing_field(type(self).__name__, 'year', errors, comp_path)
        if 'month' in value:
            DMonth.validate(value['month'], errors, '{}/{}'.format(comp_path ,'month'))
        elif 'month' not in value:
            report_missing_field(type(self).__name__, 'month', errors, comp_path)
        if 'day' in value:
            DDay.validate(value['day'], errors, '{}/{}'.format(comp_path ,'day'))
        elif 'day' not in value:
            report_missing_field(type(self).__name__, 'day', errors, comp_path)
        if 'hour' in value:
            DDay.validate(value['hour'], errors, '{}/{}'.format(comp_path ,'hour'))
        elif 'hour' not in value:
            report_missing_field(type(self).__name__, 'hour', errors, comp_path)
        if 'minute' in value:
            DMinute.validate(value['minute'], errors, '{}/{}'.format(comp_path ,'minute'))
        elif 'minute' not in value:
            report_missing_field(type(self).__name__, 'minute', errors, comp_path)

        return errors

class DMonthDay:
    def __init__(self):
        self._comp_types = {"month" : DMonth, "day" : DDay}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DMonthDay"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DMonthDay()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'month' in value:
            DMonth.encode(encoding_rule, value['month'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'day' in value:
            DDay.encode(encoding_rule, value['day'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DMonthDay()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['month'] = DMonth.decode(encoding_rule, stream, value_tracker)
        value['day'] = DDay.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DMonthDay()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'month' in value:
            DMonth.validate(value['month'], errors, '{}/{}'.format(comp_path ,'month'))
        elif 'month' not in value:
            report_missing_field(type(self).__name__, 'month', errors, comp_path)
        if 'day' in value:
            DDay.validate(value['day'], errors, '{}/{}'.format(comp_path ,'day'))
        elif 'day' not in value:
            report_missing_field(type(self).__name__, 'day', errors, comp_path)

        return errors

class DTime:
    def __init__(self):
        self._comp_types = {"hour" : DDay, "minute" : DMinute, "second" : DSecond, "offset" : DOffset}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DTime"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DTime()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('offset' in value and 'offset' not in self._def_vals):
            preamble_bits[0] = True
        elif ('offset' in value and 'offset' in self._def_vals):
            if not value_tracker.are_def_eq(value['offset'], self._def_vals['offset'], self._comp_types['offset']):
                preamble_bits[0] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'hour' in value:
            DDay.encode(encoding_rule, value['hour'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'minute' in value:
            DMinute.encode(encoding_rule, value['minute'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'second' in value:
            DSecond.encode(encoding_rule, value['second'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            DOffset.encode(encoding_rule, value['offset'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DTime()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['hour'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['minute'] = DMinute.decode(encoding_rule, stream, value_tracker)
        value['second'] = DSecond.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['offset'] = DOffset.decode(encoding_rule, stream, value_tracker)
        elif 'offset' in self._def_vals:
            value['offset'] = self._def_vals['offset']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DTime()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'hour' in value:
            DDay.validate(value['hour'], errors, '{}/{}'.format(comp_path ,'hour'))
        elif 'hour' not in value:
            report_missing_field(type(self).__name__, 'hour', errors, comp_path)
        if 'minute' in value:
            DMinute.validate(value['minute'], errors, '{}/{}'.format(comp_path ,'minute'))
        elif 'minute' not in value:
            report_missing_field(type(self).__name__, 'minute', errors, comp_path)
        if 'second' in value:
            DSecond.validate(value['second'], errors, '{}/{}'.format(comp_path ,'second'))
        elif 'second' not in value:
            report_missing_field(type(self).__name__, 'second', errors, comp_path)
        if 'offset' in value:
            DOffset.validate(value['offset'], errors, '{}/{}'.format(comp_path ,'offset'))

        return errors

class DYearMonth:
    def __init__(self):
        self._comp_types = {"year" : DYear, "month" : DMonth}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DYearMonth"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DYearMonth()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'year' in value:
            DYear.encode(encoding_rule, value['year'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'month' in value:
            DMonth.encode(encoding_rule, value['month'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DYearMonth()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['year'] = DYear.decode(encoding_rule, stream, value_tracker)
        value['month'] = DMonth.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DYearMonth()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'year' in value:
            DYear.validate(value['year'], errors, '{}/{}'.format(comp_path ,'year'))
        elif 'year' not in value:
            report_missing_field(type(self).__name__, 'year', errors, comp_path)
        if 'month' in value:
            DMonth.validate(value['month'], errors, '{}/{}'.format(comp_path ,'month'))
        elif 'month' not in value:
            report_missing_field(type(self).__name__, 'month', errors, comp_path)

        return errors

class DisabledVehicle:
    def __init__(self):
        self._comp_types = {"statusDetails" : DisabledVehicle__1, "locationDetails" : GenericLocations}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DisabledVehicle"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DisabledVehicle()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('locationDetails' in value and 'locationDetails' not in self._def_vals):
            preamble_bits[0] = True
        elif ('locationDetails' in value and 'locationDetails' in self._def_vals):
            if not value_tracker.are_def_eq(value['locationDetails'], self._def_vals['locationDetails'], self._comp_types['locationDetails']):
                preamble_bits[0] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'statusDetails' in value:
            DisabledVehicle__1.encode(encoding_rule, value['statusDetails'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            GenericLocations.encode(encoding_rule, value['locationDetails'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DisabledVehicle()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['statusDetails'] = DisabledVehicle__1.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['locationDetails'] = GenericLocations.decode(encoding_rule, stream, value_tracker)
        elif 'locationDetails' in self._def_vals:
            value['locationDetails'] = self._def_vals['locationDetails']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DisabledVehicle()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'statusDetails' in value:
            DisabledVehicle__1.validate(value['statusDetails'], errors, '{}/{}'.format(comp_path ,'statusDetails'))
        elif 'statusDetails' not in value:
            report_missing_field(type(self).__name__, 'statusDetails', errors, comp_path)
        if 'locationDetails' in value:
            GenericLocations.validate(value['locationDetails'], errors, '{}/{}'.format(comp_path ,'locationDetails'))

        return errors

class EmergencyDetails:
    def __init__(self):
        self._comp_types = {"sspRights" : DDay, "sirenUse" : SirenInUse, "lightsUse" : LightbarInUse, "multi" : MultiVehicleResponse, "events" : PrivilegedEvents, "responseType" : ResponseType}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.EmergencyDetails"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = EmergencyDetails()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('events' in value and 'events' not in self._def_vals):
            preamble_bits[0] = True
        elif ('events' in value and 'events' in self._def_vals):
            if not value_tracker.are_def_eq(value['events'], self._def_vals['events'], self._comp_types['events']):
                preamble_bits[0] = True
        if ('responseType' in value and 'responseType' not in self._def_vals):
            preamble_bits[1] = True
        elif ('responseType' in value and 'responseType' in self._def_vals):
            if not value_tracker.are_def_eq(value['responseType'], self._def_vals['responseType'], self._comp_types['responseType']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'sspRights' in value:
            DDay.encode(encoding_rule, value['sspRights'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'sirenUse' in value:
            SirenInUse.encode(encoding_rule, value['sirenUse'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lightsUse' in value:
            LightbarInUse.encode(encoding_rule, value['lightsUse'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'multi' in value:
            MultiVehicleResponse.encode(encoding_rule, value['multi'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            PrivilegedEvents.encode(encoding_rule, value['events'], value_tracker, stream)
        if preamble_bits[2]:
            ResponseType.encode(encoding_rule, value['responseType'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = EmergencyDetails()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['sspRights'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['sirenUse'] = SirenInUse.decode(encoding_rule, stream, value_tracker)
        value['lightsUse'] = LightbarInUse.decode(encoding_rule, stream, value_tracker)
        value['multi'] = MultiVehicleResponse.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['events'] = PrivilegedEvents.decode(encoding_rule, stream, value_tracker)
        elif 'events' in self._def_vals:
            value['events'] = self._def_vals['events']
        if preamble_bits[2]:
            value['responseType'] = ResponseType.decode(encoding_rule, stream, value_tracker)
        elif 'responseType' in self._def_vals:
            value['responseType'] = self._def_vals['responseType']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = EmergencyDetails()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'sspRights' in value:
            DDay.validate(value['sspRights'], errors, '{}/{}'.format(comp_path ,'sspRights'))
        elif 'sspRights' not in value:
            report_missing_field(type(self).__name__, 'sspRights', errors, comp_path)
        if 'sirenUse' in value:
            SirenInUse.validate(value['sirenUse'], errors, '{}/{}'.format(comp_path ,'sirenUse'))
        elif 'sirenUse' not in value:
            report_missing_field(type(self).__name__, 'sirenUse', errors, comp_path)
        if 'lightsUse' in value:
            LightbarInUse.validate(value['lightsUse'], errors, '{}/{}'.format(comp_path ,'lightsUse'))
        elif 'lightsUse' not in value:
            report_missing_field(type(self).__name__, 'lightsUse', errors, comp_path)
        if 'multi' in value:
            MultiVehicleResponse.validate(value['multi'], errors, '{}/{}'.format(comp_path ,'multi'))
        elif 'multi' not in value:
            report_missing_field(type(self).__name__, 'multi', errors, comp_path)
        if 'events' in value:
            PrivilegedEvents.validate(value['events'], errors, '{}/{}'.format(comp_path ,'events'))
        if 'responseType' in value:
            ResponseType.validate(value['responseType'], errors, '{}/{}'.format(comp_path ,'responseType'))

        return errors

class EnabledLaneList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,16)]}}]
        self._unique_indetifier = "DSRC.EnabledLaneList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                AmbientAirPressure.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                AmbientAirPressure.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(AmbientAirPressure.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = EnabledLaneList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(AmbientAirPressure.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = EnabledLaneList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = EnabledLaneList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                AmbientAirPressure.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class EventDescription:
    def __init__(self):
        self._comp_types = {"typeEvent" : DSecond, "description" : EventDescription__3, "priority" : Priority, "heading" : HeadingSlice, "extent" : Extent, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.EventDescription"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = EventDescription()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('description' in value and 'description' not in self._def_vals):
            preamble_bits[0] = True
        elif ('description' in value and 'description' in self._def_vals):
            if not value_tracker.are_def_eq(value['description'], self._def_vals['description'], self._comp_types['description']):
                preamble_bits[0] = True
        if ('priority' in value and 'priority' not in self._def_vals):
            preamble_bits[1] = True
        elif ('priority' in value and 'priority' in self._def_vals):
            if not value_tracker.are_def_eq(value['priority'], self._def_vals['priority'], self._comp_types['priority']):
                preamble_bits[1] = True
        if ('heading' in value and 'heading' not in self._def_vals):
            preamble_bits[2] = True
        elif ('heading' in value and 'heading' in self._def_vals):
            if not value_tracker.are_def_eq(value['heading'], self._def_vals['heading'], self._comp_types['heading']):
                preamble_bits[2] = True
        if ('extent' in value and 'extent' not in self._def_vals):
            preamble_bits[3] = True
        elif ('extent' in value and 'extent' in self._def_vals):
            if not value_tracker.are_def_eq(value['extent'], self._def_vals['extent'], self._comp_types['extent']):
                preamble_bits[3] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[4] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[4] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'typeEvent' in value:
            DSecond.encode(encoding_rule, value['typeEvent'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            EventDescription__3.encode(encoding_rule, value['description'], value_tracker, stream)
        if preamble_bits[2]:
            Priority.encode(encoding_rule, value['priority'], value_tracker, stream)
        if preamble_bits[3]:
            HeadingSlice.encode(encoding_rule, value['heading'], value_tracker, stream)
        if preamble_bits[4]:
            Extent.encode(encoding_rule, value['extent'], value_tracker, stream)
        if preamble_bits[5]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = EventDescription()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['typeEvent'] = DSecond.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['description'] = EventDescription__3.decode(encoding_rule, stream, value_tracker)
        elif 'description' in self._def_vals:
            value['description'] = self._def_vals['description']
        if preamble_bits[2]:
            value['priority'] = Priority.decode(encoding_rule, stream, value_tracker)
        elif 'priority' in self._def_vals:
            value['priority'] = self._def_vals['priority']
        if preamble_bits[3]:
            value['heading'] = HeadingSlice.decode(encoding_rule, stream, value_tracker)
        elif 'heading' in self._def_vals:
            value['heading'] = self._def_vals['heading']
        if preamble_bits[4]:
            value['extent'] = Extent.decode(encoding_rule, stream, value_tracker)
        elif 'extent' in self._def_vals:
            value['extent'] = self._def_vals['extent']
        if preamble_bits[5]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = EventDescription()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'typeEvent' in value:
            DSecond.validate(value['typeEvent'], errors, '{}/{}'.format(comp_path ,'typeEvent'))
        elif 'typeEvent' not in value:
            report_missing_field(type(self).__name__, 'typeEvent', errors, comp_path)
        if 'description' in value:
            EventDescription__3.validate(value['description'], errors, '{}/{}'.format(comp_path ,'description'))
        if 'priority' in value:
            Priority.validate(value['priority'], errors, '{}/{}'.format(comp_path ,'priority'))
        if 'heading' in value:
            HeadingSlice.validate(value['heading'], errors, '{}/{}'.format(comp_path ,'heading'))
        if 'extent' in value:
            Extent.validate(value['extent'], errors, '{}/{}'.format(comp_path ,'extent'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class EventDescription__3:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,8)]}}]
        self._unique_indetifier = "DSRC.EventDescription.description"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                DSecond.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                DSecond.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(DSecond.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = EventDescription__3()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(DSecond.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = EventDescription__3()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = EventDescription__3()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                DSecond.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

RoadSideAlert__5 = EventDescription__3

class FullPositionVector:
    def __init__(self):
        self._comp_types = {"utcTime" : DDateTime, "long" : Longitude, "lat" : Latitude, "elevation" : Elevation, "heading" : Angle, "speed" : TransmissionAndSpeed, "posAccuracy" : PositionalAccuracy, "timeConfidence" : TimeConfidence, "posConfidence" : PositionConfidenceSet, "speedConfidence" : SpeedandHeadingandThrottleConfidence}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.FullPositionVector"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = FullPositionVector()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 8

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('utcTime' in value and 'utcTime' not in self._def_vals):
            preamble_bits[0] = True
        elif ('utcTime' in value and 'utcTime' in self._def_vals):
            if not value_tracker.are_def_eq(value['utcTime'], self._def_vals['utcTime'], self._comp_types['utcTime']):
                preamble_bits[0] = True
        if ('elevation' in value and 'elevation' not in self._def_vals):
            preamble_bits[1] = True
        elif ('elevation' in value and 'elevation' in self._def_vals):
            if not value_tracker.are_def_eq(value['elevation'], self._def_vals['elevation'], self._comp_types['elevation']):
                preamble_bits[1] = True
        if ('heading' in value and 'heading' not in self._def_vals):
            preamble_bits[2] = True
        elif ('heading' in value and 'heading' in self._def_vals):
            if not value_tracker.are_def_eq(value['heading'], self._def_vals['heading'], self._comp_types['heading']):
                preamble_bits[2] = True
        if ('speed' in value and 'speed' not in self._def_vals):
            preamble_bits[3] = True
        elif ('speed' in value and 'speed' in self._def_vals):
            if not value_tracker.are_def_eq(value['speed'], self._def_vals['speed'], self._comp_types['speed']):
                preamble_bits[3] = True
        if ('posAccuracy' in value and 'posAccuracy' not in self._def_vals):
            preamble_bits[4] = True
        elif ('posAccuracy' in value and 'posAccuracy' in self._def_vals):
            if not value_tracker.are_def_eq(value['posAccuracy'], self._def_vals['posAccuracy'], self._comp_types['posAccuracy']):
                preamble_bits[4] = True
        if ('timeConfidence' in value and 'timeConfidence' not in self._def_vals):
            preamble_bits[5] = True
        elif ('timeConfidence' in value and 'timeConfidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeConfidence'], self._def_vals['timeConfidence'], self._comp_types['timeConfidence']):
                preamble_bits[5] = True
        if ('posConfidence' in value and 'posConfidence' not in self._def_vals):
            preamble_bits[6] = True
        elif ('posConfidence' in value and 'posConfidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['posConfidence'], self._def_vals['posConfidence'], self._comp_types['posConfidence']):
                preamble_bits[6] = True
        if ('speedConfidence' in value and 'speedConfidence' not in self._def_vals):
            preamble_bits[7] = True
        elif ('speedConfidence' in value and 'speedConfidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['speedConfidence'], self._def_vals['speedConfidence'], self._comp_types['speedConfidence']):
                preamble_bits[7] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            DDateTime.encode(encoding_rule, value['utcTime'], value_tracker, stream)
        if 'long' in value:
            Longitude.encode(encoding_rule, value['long'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            Latitude.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            Elevation.encode(encoding_rule, value['elevation'], value_tracker, stream)
        if preamble_bits[3]:
            Angle.encode(encoding_rule, value['heading'], value_tracker, stream)
        if preamble_bits[4]:
            TransmissionAndSpeed.encode(encoding_rule, value['speed'], value_tracker, stream)
        if preamble_bits[5]:
            PositionalAccuracy.encode(encoding_rule, value['posAccuracy'], value_tracker, stream)
        if preamble_bits[6]:
            TimeConfidence.encode(encoding_rule, value['timeConfidence'], value_tracker, stream)
        if preamble_bits[7]:
            PositionConfidenceSet.encode(encoding_rule, value['posConfidence'], value_tracker, stream)
        if preamble_bits[8]:
            SpeedandHeadingandThrottleConfidence.encode(encoding_rule, value['speedConfidence'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = FullPositionVector()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 8

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['utcTime'] = DDateTime.decode(encoding_rule, stream, value_tracker)
        elif 'utcTime' in self._def_vals:
            value['utcTime'] = self._def_vals['utcTime']
        value['long'] = Longitude.decode(encoding_rule, stream, value_tracker)
        value['lat'] = Latitude.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['elevation'] = Elevation.decode(encoding_rule, stream, value_tracker)
        elif 'elevation' in self._def_vals:
            value['elevation'] = self._def_vals['elevation']
        if preamble_bits[3]:
            value['heading'] = Angle.decode(encoding_rule, stream, value_tracker)
        elif 'heading' in self._def_vals:
            value['heading'] = self._def_vals['heading']
        if preamble_bits[4]:
            value['speed'] = TransmissionAndSpeed.decode(encoding_rule, stream, value_tracker)
        elif 'speed' in self._def_vals:
            value['speed'] = self._def_vals['speed']
        if preamble_bits[5]:
            value['posAccuracy'] = PositionalAccuracy.decode(encoding_rule, stream, value_tracker)
        elif 'posAccuracy' in self._def_vals:
            value['posAccuracy'] = self._def_vals['posAccuracy']
        if preamble_bits[6]:
            value['timeConfidence'] = TimeConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'timeConfidence' in self._def_vals:
            value['timeConfidence'] = self._def_vals['timeConfidence']
        if preamble_bits[7]:
            value['posConfidence'] = PositionConfidenceSet.decode(encoding_rule, stream, value_tracker)
        elif 'posConfidence' in self._def_vals:
            value['posConfidence'] = self._def_vals['posConfidence']
        if preamble_bits[8]:
            value['speedConfidence'] = SpeedandHeadingandThrottleConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'speedConfidence' in self._def_vals:
            value['speedConfidence'] = self._def_vals['speedConfidence']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = FullPositionVector()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'utcTime' in value:
            DDateTime.validate(value['utcTime'], errors, '{}/{}'.format(comp_path ,'utcTime'))
        if 'long' in value:
            Longitude.validate(value['long'], errors, '{}/{}'.format(comp_path ,'long'))
        elif 'long' not in value:
            report_missing_field(type(self).__name__, 'long', errors, comp_path)
        if 'lat' in value:
            Latitude.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)
        if 'elevation' in value:
            Elevation.validate(value['elevation'], errors, '{}/{}'.format(comp_path ,'elevation'))
        if 'heading' in value:
            Angle.validate(value['heading'], errors, '{}/{}'.format(comp_path ,'heading'))
        if 'speed' in value:
            TransmissionAndSpeed.validate(value['speed'], errors, '{}/{}'.format(comp_path ,'speed'))
        if 'posAccuracy' in value:
            PositionalAccuracy.validate(value['posAccuracy'], errors, '{}/{}'.format(comp_path ,'posAccuracy'))
        if 'timeConfidence' in value:
            TimeConfidence.validate(value['timeConfidence'], errors, '{}/{}'.format(comp_path ,'timeConfidence'))
        if 'posConfidence' in value:
            PositionConfidenceSet.validate(value['posConfidence'], errors, '{}/{}'.format(comp_path ,'posConfidence'))
        if 'speedConfidence' in value:
            SpeedandHeadingandThrottleConfidence.validate(value['speedConfidence'], errors, '{}/{}'.format(comp_path ,'speedConfidence'))

        return errors

class GenericLane:
    def __init__(self):
        self._comp_types = {"laneID" : AmbientAirPressure, "name" : DescriptiveName, "ingressApproach" : ApproachID, "egressApproach" : ApproachID, "laneAttributes" : LaneAttributes, "maneuvers" : AllowedManeuvers, "nodeList" : NodeListXY, "connectsTo" : ConnectsToList, "overlays" : OverlayLaneList, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.GenericLane"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = GenericLane()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 7

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('name' in value and 'name' not in self._def_vals):
            preamble_bits[0] = True
        elif ('name' in value and 'name' in self._def_vals):
            if not value_tracker.are_def_eq(value['name'], self._def_vals['name'], self._comp_types['name']):
                preamble_bits[0] = True
        if ('ingressApproach' in value and 'ingressApproach' not in self._def_vals):
            preamble_bits[1] = True
        elif ('ingressApproach' in value and 'ingressApproach' in self._def_vals):
            if not value_tracker.are_def_eq(value['ingressApproach'], self._def_vals['ingressApproach'], self._comp_types['ingressApproach']):
                preamble_bits[1] = True
        if ('egressApproach' in value and 'egressApproach' not in self._def_vals):
            preamble_bits[2] = True
        elif ('egressApproach' in value and 'egressApproach' in self._def_vals):
            if not value_tracker.are_def_eq(value['egressApproach'], self._def_vals['egressApproach'], self._comp_types['egressApproach']):
                preamble_bits[2] = True
        if ('maneuvers' in value and 'maneuvers' not in self._def_vals):
            preamble_bits[3] = True
        elif ('maneuvers' in value and 'maneuvers' in self._def_vals):
            if not value_tracker.are_def_eq(value['maneuvers'], self._def_vals['maneuvers'], self._comp_types['maneuvers']):
                preamble_bits[3] = True
        if ('connectsTo' in value and 'connectsTo' not in self._def_vals):
            preamble_bits[4] = True
        elif ('connectsTo' in value and 'connectsTo' in self._def_vals):
            if not value_tracker.are_def_eq(value['connectsTo'], self._def_vals['connectsTo'], self._comp_types['connectsTo']):
                preamble_bits[4] = True
        if ('overlays' in value and 'overlays' not in self._def_vals):
            preamble_bits[5] = True
        elif ('overlays' in value and 'overlays' in self._def_vals):
            if not value_tracker.are_def_eq(value['overlays'], self._def_vals['overlays'], self._comp_types['overlays']):
                preamble_bits[5] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[6] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[6] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'laneID' in value:
            AmbientAirPressure.encode(encoding_rule, value['laneID'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            DescriptiveName.encode(encoding_rule, value['name'], value_tracker, stream)
        if preamble_bits[2]:
            ApproachID.encode(encoding_rule, value['ingressApproach'], value_tracker, stream)
        if preamble_bits[3]:
            ApproachID.encode(encoding_rule, value['egressApproach'], value_tracker, stream)
        if 'laneAttributes' in value:
            LaneAttributes.encode(encoding_rule, value['laneAttributes'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[4]:
            AllowedManeuvers.encode(encoding_rule, value['maneuvers'], value_tracker, stream)
        if 'nodeList' in value:
            NodeListXY.encode(encoding_rule, value['nodeList'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[5]:
            ConnectsToList.encode(encoding_rule, value['connectsTo'], value_tracker, stream)
        if preamble_bits[6]:
            OverlayLaneList.encode(encoding_rule, value['overlays'], value_tracker, stream)
        if preamble_bits[7]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = GenericLane()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 7

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['laneID'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['name'] = DescriptiveName.decode(encoding_rule, stream, value_tracker)
        elif 'name' in self._def_vals:
            value['name'] = self._def_vals['name']
        if preamble_bits[2]:
            value['ingressApproach'] = ApproachID.decode(encoding_rule, stream, value_tracker)
        elif 'ingressApproach' in self._def_vals:
            value['ingressApproach'] = self._def_vals['ingressApproach']
        if preamble_bits[3]:
            value['egressApproach'] = ApproachID.decode(encoding_rule, stream, value_tracker)
        elif 'egressApproach' in self._def_vals:
            value['egressApproach'] = self._def_vals['egressApproach']
        value['laneAttributes'] = LaneAttributes.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[4]:
            value['maneuvers'] = AllowedManeuvers.decode(encoding_rule, stream, value_tracker)
        elif 'maneuvers' in self._def_vals:
            value['maneuvers'] = self._def_vals['maneuvers']
        value['nodeList'] = NodeListXY.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[5]:
            value['connectsTo'] = ConnectsToList.decode(encoding_rule, stream, value_tracker)
        elif 'connectsTo' in self._def_vals:
            value['connectsTo'] = self._def_vals['connectsTo']
        if preamble_bits[6]:
            value['overlays'] = OverlayLaneList.decode(encoding_rule, stream, value_tracker)
        elif 'overlays' in self._def_vals:
            value['overlays'] = self._def_vals['overlays']
        if preamble_bits[7]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = GenericLane()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'laneID' in value:
            AmbientAirPressure.validate(value['laneID'], errors, '{}/{}'.format(comp_path ,'laneID'))
        elif 'laneID' not in value:
            report_missing_field(type(self).__name__, 'laneID', errors, comp_path)
        if 'name' in value:
            DescriptiveName.validate(value['name'], errors, '{}/{}'.format(comp_path ,'name'))
        if 'ingressApproach' in value:
            ApproachID.validate(value['ingressApproach'], errors, '{}/{}'.format(comp_path ,'ingressApproach'))
        if 'egressApproach' in value:
            ApproachID.validate(value['egressApproach'], errors, '{}/{}'.format(comp_path ,'egressApproach'))
        if 'laneAttributes' in value:
            LaneAttributes.validate(value['laneAttributes'], errors, '{}/{}'.format(comp_path ,'laneAttributes'))
        elif 'laneAttributes' not in value:
            report_missing_field(type(self).__name__, 'laneAttributes', errors, comp_path)
        if 'maneuvers' in value:
            AllowedManeuvers.validate(value['maneuvers'], errors, '{}/{}'.format(comp_path ,'maneuvers'))
        if 'nodeList' in value:
            NodeListXY.validate(value['nodeList'], errors, '{}/{}'.format(comp_path ,'nodeList'))
        elif 'nodeList' not in value:
            report_missing_field(type(self).__name__, 'nodeList', errors, comp_path)
        if 'connectsTo' in value:
            ConnectsToList.validate(value['connectsTo'], errors, '{}/{}'.format(comp_path ,'connectsTo'))
        if 'overlays' in value:
            OverlayLaneList.validate(value['overlays'], errors, '{}/{}'.format(comp_path ,'overlays'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class GeographicalPath:
    def __init__(self):
        self._comp_types = {"name" : DescriptiveName, "id" : IntersectionReferenceID, "anchor" : Position3D, "laneWidth" : DSRCmsgID, "directionality" : DirectionOfUse, "closedPath" : IsDolly, "direction" : HeadingSlice, "description" : GeographicalPath__11, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.GeographicalPath"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = GeographicalPath()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 9

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('name' in value and 'name' not in self._def_vals):
            preamble_bits[0] = True
        elif ('name' in value and 'name' in self._def_vals):
            if not value_tracker.are_def_eq(value['name'], self._def_vals['name'], self._comp_types['name']):
                preamble_bits[0] = True
        if ('id' in value and 'id' not in self._def_vals):
            preamble_bits[1] = True
        elif ('id' in value and 'id' in self._def_vals):
            if not value_tracker.are_def_eq(value['id'], self._def_vals['id'], self._comp_types['id']):
                preamble_bits[1] = True
        if ('anchor' in value and 'anchor' not in self._def_vals):
            preamble_bits[2] = True
        elif ('anchor' in value and 'anchor' in self._def_vals):
            if not value_tracker.are_def_eq(value['anchor'], self._def_vals['anchor'], self._comp_types['anchor']):
                preamble_bits[2] = True
        if ('laneWidth' in value and 'laneWidth' not in self._def_vals):
            preamble_bits[3] = True
        elif ('laneWidth' in value and 'laneWidth' in self._def_vals):
            if not value_tracker.are_def_eq(value['laneWidth'], self._def_vals['laneWidth'], self._comp_types['laneWidth']):
                preamble_bits[3] = True
        if ('directionality' in value and 'directionality' not in self._def_vals):
            preamble_bits[4] = True
        elif ('directionality' in value and 'directionality' in self._def_vals):
            if not value_tracker.are_def_eq(value['directionality'], self._def_vals['directionality'], self._comp_types['directionality']):
                preamble_bits[4] = True
        if ('closedPath' in value and 'closedPath' not in self._def_vals):
            preamble_bits[5] = True
        elif ('closedPath' in value and 'closedPath' in self._def_vals):
            if not value_tracker.are_def_eq(value['closedPath'], self._def_vals['closedPath'], self._comp_types['closedPath']):
                preamble_bits[5] = True
        if ('direction' in value and 'direction' not in self._def_vals):
            preamble_bits[6] = True
        elif ('direction' in value and 'direction' in self._def_vals):
            if not value_tracker.are_def_eq(value['direction'], self._def_vals['direction'], self._comp_types['direction']):
                preamble_bits[6] = True
        if ('description' in value and 'description' not in self._def_vals):
            preamble_bits[7] = True
        elif ('description' in value and 'description' in self._def_vals):
            if not value_tracker.are_def_eq(value['description'], self._def_vals['description'], self._comp_types['description']):
                preamble_bits[7] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[8] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[8] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            DescriptiveName.encode(encoding_rule, value['name'], value_tracker, stream)
        if preamble_bits[2]:
            IntersectionReferenceID.encode(encoding_rule, value['id'], value_tracker, stream)
        if preamble_bits[3]:
            Position3D.encode(encoding_rule, value['anchor'], value_tracker, stream)
        if preamble_bits[4]:
            DSRCmsgID.encode(encoding_rule, value['laneWidth'], value_tracker, stream)
        if preamble_bits[5]:
            DirectionOfUse.encode(encoding_rule, value['directionality'], value_tracker, stream)
        if preamble_bits[6]:
            IsDolly.encode(encoding_rule, value['closedPath'], value_tracker, stream)
        if preamble_bits[7]:
            HeadingSlice.encode(encoding_rule, value['direction'], value_tracker, stream)
        if preamble_bits[8]:
            GeographicalPath__11.encode(encoding_rule, value['description'], value_tracker, stream)
        if preamble_bits[9]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = GeographicalPath()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 9

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['name'] = DescriptiveName.decode(encoding_rule, stream, value_tracker)
        elif 'name' in self._def_vals:
            value['name'] = self._def_vals['name']
        if preamble_bits[2]:
            value['id'] = IntersectionReferenceID.decode(encoding_rule, stream, value_tracker)
        elif 'id' in self._def_vals:
            value['id'] = self._def_vals['id']
        if preamble_bits[3]:
            value['anchor'] = Position3D.decode(encoding_rule, stream, value_tracker)
        elif 'anchor' in self._def_vals:
            value['anchor'] = self._def_vals['anchor']
        if preamble_bits[4]:
            value['laneWidth'] = DSRCmsgID.decode(encoding_rule, stream, value_tracker)
        elif 'laneWidth' in self._def_vals:
            value['laneWidth'] = self._def_vals['laneWidth']
        if preamble_bits[5]:
            value['directionality'] = DirectionOfUse.decode(encoding_rule, stream, value_tracker)
        elif 'directionality' in self._def_vals:
            value['directionality'] = self._def_vals['directionality']
        if preamble_bits[6]:
            value['closedPath'] = IsDolly.decode(encoding_rule, stream, value_tracker)
        elif 'closedPath' in self._def_vals:
            value['closedPath'] = self._def_vals['closedPath']
        if preamble_bits[7]:
            value['direction'] = HeadingSlice.decode(encoding_rule, stream, value_tracker)
        elif 'direction' in self._def_vals:
            value['direction'] = self._def_vals['direction']
        if preamble_bits[8]:
            value['description'] = GeographicalPath__11.decode(encoding_rule, stream, value_tracker)
        elif 'description' in self._def_vals:
            value['description'] = self._def_vals['description']
        if preamble_bits[9]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = GeographicalPath()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'name' in value:
            DescriptiveName.validate(value['name'], errors, '{}/{}'.format(comp_path ,'name'))
        if 'id' in value:
            IntersectionReferenceID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        if 'anchor' in value:
            Position3D.validate(value['anchor'], errors, '{}/{}'.format(comp_path ,'anchor'))
        if 'laneWidth' in value:
            DSRCmsgID.validate(value['laneWidth'], errors, '{}/{}'.format(comp_path ,'laneWidth'))
        if 'directionality' in value:
            DirectionOfUse.validate(value['directionality'], errors, '{}/{}'.format(comp_path ,'directionality'))
        if 'closedPath' in value:
            IsDolly.validate(value['closedPath'], errors, '{}/{}'.format(comp_path ,'closedPath'))
        if 'direction' in value:
            HeadingSlice.validate(value['direction'], errors, '{}/{}'.format(comp_path ,'direction'))
        if 'description' in value:
            GeographicalPath__11.validate(value['description'], errors, '{}/{}'.format(comp_path ,'description'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class GeographicalPath__11:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.GeographicalPath.description"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"path": 0, "geometry": 1, "oldRegion": 2}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = GeographicalPath__11()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 3
        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(idx > 63)

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'path':
                OffsetSystem.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'geometry':
                GeometricProjection.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'oldRegion':
                ValidRegion.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = GeographicalPath__11()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 3
        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'path':
                alternative = OffsetSystem.decode(encoding_rule, stream, value_tracker)
            if identifier == 'geometry':
                alternative = GeometricProjection.decode(encoding_rule, stream, value_tracker)
            if identifier == 'oldRegion':
                alternative = ValidRegion.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = GeographicalPath__11()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'path' in value:
            OffsetSystem.validate(value['path'], errors, '{}/{}'.format(comp_path ,'path'))
            is_checked = True
        if 'geometry' in value:
            GeometricProjection.validate(value['geometry'], errors, '{}/{}'.format(comp_path ,'geometry'))
            is_checked = True
        if 'oldRegion' in value:
            ValidRegion.validate(value['oldRegion'], errors, '{}/{}'.format(comp_path ,'oldRegion'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class GeometricProjection:
    def __init__(self):
        self._comp_types = {"direction" : HeadingSlice, "extent" : Extent, "laneWidth" : DSRCmsgID, "circle" : Circle, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.GeometricProjection"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = GeometricProjection()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('extent' in value and 'extent' not in self._def_vals):
            preamble_bits[0] = True
        elif ('extent' in value and 'extent' in self._def_vals):
            if not value_tracker.are_def_eq(value['extent'], self._def_vals['extent'], self._comp_types['extent']):
                preamble_bits[0] = True
        if ('laneWidth' in value and 'laneWidth' not in self._def_vals):
            preamble_bits[1] = True
        elif ('laneWidth' in value and 'laneWidth' in self._def_vals):
            if not value_tracker.are_def_eq(value['laneWidth'], self._def_vals['laneWidth'], self._comp_types['laneWidth']):
                preamble_bits[1] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[2] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[2] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'direction' in value:
            HeadingSlice.encode(encoding_rule, value['direction'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            Extent.encode(encoding_rule, value['extent'], value_tracker, stream)
        if preamble_bits[2]:
            DSRCmsgID.encode(encoding_rule, value['laneWidth'], value_tracker, stream)
        if 'circle' in value:
            Circle.encode(encoding_rule, value['circle'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[3]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = GeometricProjection()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['direction'] = HeadingSlice.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['extent'] = Extent.decode(encoding_rule, stream, value_tracker)
        elif 'extent' in self._def_vals:
            value['extent'] = self._def_vals['extent']
        if preamble_bits[2]:
            value['laneWidth'] = DSRCmsgID.decode(encoding_rule, stream, value_tracker)
        elif 'laneWidth' in self._def_vals:
            value['laneWidth'] = self._def_vals['laneWidth']
        value['circle'] = Circle.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[3]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = GeometricProjection()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'direction' in value:
            HeadingSlice.validate(value['direction'], errors, '{}/{}'.format(comp_path ,'direction'))
        elif 'direction' not in value:
            report_missing_field(type(self).__name__, 'direction', errors, comp_path)
        if 'extent' in value:
            Extent.validate(value['extent'], errors, '{}/{}'.format(comp_path ,'extent'))
        if 'laneWidth' in value:
            DSRCmsgID.validate(value['laneWidth'], errors, '{}/{}'.format(comp_path ,'laneWidth'))
        if 'circle' in value:
            Circle.validate(value['circle'], errors, '{}/{}'.format(comp_path ,'circle'))
        elif 'circle' not in value:
            report_missing_field(type(self).__name__, 'circle', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class Header:
    def __init__(self):
        self._comp_types = {"year" : DYear, "timeStamp" : MinuteOfTheYear, "secMark" : DSecond, "msgIssueRevision" : BumperHeight}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Header"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Header()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('year' in value and 'year' not in self._def_vals):
            preamble_bits[0] = True
        elif ('year' in value and 'year' in self._def_vals):
            if not value_tracker.are_def_eq(value['year'], self._def_vals['year'], self._comp_types['year']):
                preamble_bits[0] = True
        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[1] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[1] = True
        if ('secMark' in value and 'secMark' not in self._def_vals):
            preamble_bits[2] = True
        elif ('secMark' in value and 'secMark' in self._def_vals):
            if not value_tracker.are_def_eq(value['secMark'], self._def_vals['secMark'], self._comp_types['secMark']):
                preamble_bits[2] = True
        if ('msgIssueRevision' in value and 'msgIssueRevision' not in self._def_vals):
            preamble_bits[3] = True
        elif ('msgIssueRevision' in value and 'msgIssueRevision' in self._def_vals):
            if not value_tracker.are_def_eq(value['msgIssueRevision'], self._def_vals['msgIssueRevision'], self._comp_types['msgIssueRevision']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            DYear.encode(encoding_rule, value['year'], value_tracker, stream)
        if preamble_bits[2]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if preamble_bits[3]:
            DSecond.encode(encoding_rule, value['secMark'], value_tracker, stream)
        if preamble_bits[4]:
            BumperHeight.encode(encoding_rule, value['msgIssueRevision'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Header()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['year'] = DYear.decode(encoding_rule, stream, value_tracker)
        elif 'year' in self._def_vals:
            value['year'] = self._def_vals['year']
        if preamble_bits[2]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        if preamble_bits[3]:
            value['secMark'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'secMark' in self._def_vals:
            value['secMark'] = self._def_vals['secMark']
        if preamble_bits[4]:
            value['msgIssueRevision'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        elif 'msgIssueRevision' in self._def_vals:
            value['msgIssueRevision'] = self._def_vals['msgIssueRevision']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Header()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'year' in value:
            DYear.validate(value['year'], errors, '{}/{}'.format(comp_path ,'year'))
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'secMark' in value:
            DSecond.validate(value['secMark'], errors, '{}/{}'.format(comp_path ,'secMark'))
        if 'msgIssueRevision' in value:
            BumperHeight.validate(value['msgIssueRevision'], errors, '{}/{}'.format(comp_path ,'msgIssueRevision'))

        return errors

class IntersectionAccessPoint:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.IntersectionAccessPoint"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"lane": 0, "approach": 1, "connection": 2}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = IntersectionAccessPoint()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 3
        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(idx > 63)

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'lane':
                AmbientAirPressure.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'approach':
                ApproachID.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'connection':
                AmbientAirPressure.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = IntersectionAccessPoint()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 3
        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'lane':
                alternative = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
            if identifier == 'approach':
                alternative = ApproachID.decode(encoding_rule, stream, value_tracker)
            if identifier == 'connection':
                alternative = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = IntersectionAccessPoint()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lane' in value:
            AmbientAirPressure.validate(value['lane'], errors, '{}/{}'.format(comp_path ,'lane'))
            is_checked = True
        if 'approach' in value:
            ApproachID.validate(value['approach'], errors, '{}/{}'.format(comp_path ,'approach'))
            is_checked = True
        if 'connection' in value:
            AmbientAirPressure.validate(value['connection'], errors, '{}/{}'.format(comp_path ,'connection'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class IntersectionGeometry:
    def __init__(self):
        self._comp_types = {"name" : DescriptiveName, "id" : IntersectionReferenceID, "revision" : BumperHeight, "refPoint" : Position3D, "laneWidth" : DSRCmsgID, "speedLimits" : SpeedLimitList, "laneSet" : LaneList, "preemptPriorityData" : PreemptPriorityList, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.IntersectionGeometry"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = IntersectionGeometry()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('name' in value and 'name' not in self._def_vals):
            preamble_bits[0] = True
        elif ('name' in value and 'name' in self._def_vals):
            if not value_tracker.are_def_eq(value['name'], self._def_vals['name'], self._comp_types['name']):
                preamble_bits[0] = True
        if ('laneWidth' in value and 'laneWidth' not in self._def_vals):
            preamble_bits[1] = True
        elif ('laneWidth' in value and 'laneWidth' in self._def_vals):
            if not value_tracker.are_def_eq(value['laneWidth'], self._def_vals['laneWidth'], self._comp_types['laneWidth']):
                preamble_bits[1] = True
        if ('speedLimits' in value and 'speedLimits' not in self._def_vals):
            preamble_bits[2] = True
        elif ('speedLimits' in value and 'speedLimits' in self._def_vals):
            if not value_tracker.are_def_eq(value['speedLimits'], self._def_vals['speedLimits'], self._comp_types['speedLimits']):
                preamble_bits[2] = True
        if ('preemptPriorityData' in value and 'preemptPriorityData' not in self._def_vals):
            preamble_bits[3] = True
        elif ('preemptPriorityData' in value and 'preemptPriorityData' in self._def_vals):
            if not value_tracker.are_def_eq(value['preemptPriorityData'], self._def_vals['preemptPriorityData'], self._comp_types['preemptPriorityData']):
                preamble_bits[3] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[4] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[4] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            DescriptiveName.encode(encoding_rule, value['name'], value_tracker, stream)
        if 'id' in value:
            IntersectionReferenceID.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'revision' in value:
            BumperHeight.encode(encoding_rule, value['revision'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'refPoint' in value:
            Position3D.encode(encoding_rule, value['refPoint'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            DSRCmsgID.encode(encoding_rule, value['laneWidth'], value_tracker, stream)
        if preamble_bits[3]:
            SpeedLimitList.encode(encoding_rule, value['speedLimits'], value_tracker, stream)
        if 'laneSet' in value:
            LaneList.encode(encoding_rule, value['laneSet'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[4]:
            PreemptPriorityList.encode(encoding_rule, value['preemptPriorityData'], value_tracker, stream)
        if preamble_bits[5]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = IntersectionGeometry()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['name'] = DescriptiveName.decode(encoding_rule, stream, value_tracker)
        elif 'name' in self._def_vals:
            value['name'] = self._def_vals['name']
        value['id'] = IntersectionReferenceID.decode(encoding_rule, stream, value_tracker)
        value['revision'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        value['refPoint'] = Position3D.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['laneWidth'] = DSRCmsgID.decode(encoding_rule, stream, value_tracker)
        elif 'laneWidth' in self._def_vals:
            value['laneWidth'] = self._def_vals['laneWidth']
        if preamble_bits[3]:
            value['speedLimits'] = SpeedLimitList.decode(encoding_rule, stream, value_tracker)
        elif 'speedLimits' in self._def_vals:
            value['speedLimits'] = self._def_vals['speedLimits']
        value['laneSet'] = LaneList.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[4]:
            value['preemptPriorityData'] = PreemptPriorityList.decode(encoding_rule, stream, value_tracker)
        elif 'preemptPriorityData' in self._def_vals:
            value['preemptPriorityData'] = self._def_vals['preemptPriorityData']
        if preamble_bits[5]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = IntersectionGeometry()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'name' in value:
            DescriptiveName.validate(value['name'], errors, '{}/{}'.format(comp_path ,'name'))
        if 'id' in value:
            IntersectionReferenceID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'revision' in value:
            BumperHeight.validate(value['revision'], errors, '{}/{}'.format(comp_path ,'revision'))
        elif 'revision' not in value:
            report_missing_field(type(self).__name__, 'revision', errors, comp_path)
        if 'refPoint' in value:
            Position3D.validate(value['refPoint'], errors, '{}/{}'.format(comp_path ,'refPoint'))
        elif 'refPoint' not in value:
            report_missing_field(type(self).__name__, 'refPoint', errors, comp_path)
        if 'laneWidth' in value:
            DSRCmsgID.validate(value['laneWidth'], errors, '{}/{}'.format(comp_path ,'laneWidth'))
        if 'speedLimits' in value:
            SpeedLimitList.validate(value['speedLimits'], errors, '{}/{}'.format(comp_path ,'speedLimits'))
        if 'laneSet' in value:
            LaneList.validate(value['laneSet'], errors, '{}/{}'.format(comp_path ,'laneSet'))
        elif 'laneSet' not in value:
            report_missing_field(type(self).__name__, 'laneSet', errors, comp_path)
        if 'preemptPriorityData' in value:
            PreemptPriorityList.validate(value['preemptPriorityData'], errors, '{}/{}'.format(comp_path ,'preemptPriorityData'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class IntersectionGeometryList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,32)]}}]
        self._unique_indetifier = "DSRC.IntersectionGeometryList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                IntersectionGeometry.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                IntersectionGeometry.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(IntersectionGeometry.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = IntersectionGeometryList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(IntersectionGeometry.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = IntersectionGeometryList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = IntersectionGeometryList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                IntersectionGeometry.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class IntersectionState:
    def __init__(self):
        self._comp_types = {"name" : DescriptiveName, "id" : IntersectionReferenceID, "revision" : BumperHeight, "status" : HeadingSlice, "moy" : MinuteOfTheYear, "timeStamp" : DSecond, "enabledLanes" : EnabledLaneList, "states" : MovementList, "maneuverAssistList" : ManeuverAssistList, "regional" : IntersectionState__11}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.IntersectionState"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = IntersectionState()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 6

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('name' in value and 'name' not in self._def_vals):
            preamble_bits[0] = True
        elif ('name' in value and 'name' in self._def_vals):
            if not value_tracker.are_def_eq(value['name'], self._def_vals['name'], self._comp_types['name']):
                preamble_bits[0] = True
        if ('moy' in value and 'moy' not in self._def_vals):
            preamble_bits[1] = True
        elif ('moy' in value and 'moy' in self._def_vals):
            if not value_tracker.are_def_eq(value['moy'], self._def_vals['moy'], self._comp_types['moy']):
                preamble_bits[1] = True
        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[2] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[2] = True
        if ('enabledLanes' in value and 'enabledLanes' not in self._def_vals):
            preamble_bits[3] = True
        elif ('enabledLanes' in value and 'enabledLanes' in self._def_vals):
            if not value_tracker.are_def_eq(value['enabledLanes'], self._def_vals['enabledLanes'], self._comp_types['enabledLanes']):
                preamble_bits[3] = True
        if ('maneuverAssistList' in value and 'maneuverAssistList' not in self._def_vals):
            preamble_bits[4] = True
        elif ('maneuverAssistList' in value and 'maneuverAssistList' in self._def_vals):
            if not value_tracker.are_def_eq(value['maneuverAssistList'], self._def_vals['maneuverAssistList'], self._comp_types['maneuverAssistList']):
                preamble_bits[4] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[5] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[5] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            DescriptiveName.encode(encoding_rule, value['name'], value_tracker, stream)
        if 'id' in value:
            IntersectionReferenceID.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'revision' in value:
            BumperHeight.encode(encoding_rule, value['revision'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'status' in value:
            HeadingSlice.encode(encoding_rule, value['status'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            MinuteOfTheYear.encode(encoding_rule, value['moy'], value_tracker, stream)
        if preamble_bits[3]:
            DSecond.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if preamble_bits[4]:
            EnabledLaneList.encode(encoding_rule, value['enabledLanes'], value_tracker, stream)
        if 'states' in value:
            MovementList.encode(encoding_rule, value['states'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[5]:
            ManeuverAssistList.encode(encoding_rule, value['maneuverAssistList'], value_tracker, stream)
        if preamble_bits[6]:
            IntersectionState__11.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = IntersectionState()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 6

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['name'] = DescriptiveName.decode(encoding_rule, stream, value_tracker)
        elif 'name' in self._def_vals:
            value['name'] = self._def_vals['name']
        value['id'] = IntersectionReferenceID.decode(encoding_rule, stream, value_tracker)
        value['revision'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        value['status'] = HeadingSlice.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['moy'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'moy' in self._def_vals:
            value['moy'] = self._def_vals['moy']
        if preamble_bits[3]:
            value['timeStamp'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        if preamble_bits[4]:
            value['enabledLanes'] = EnabledLaneList.decode(encoding_rule, stream, value_tracker)
        elif 'enabledLanes' in self._def_vals:
            value['enabledLanes'] = self._def_vals['enabledLanes']
        value['states'] = MovementList.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[5]:
            value['maneuverAssistList'] = ManeuverAssistList.decode(encoding_rule, stream, value_tracker)
        elif 'maneuverAssistList' in self._def_vals:
            value['maneuverAssistList'] = self._def_vals['maneuverAssistList']
        if preamble_bits[6]:
            value['regional'] = IntersectionState__11.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = IntersectionState()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'name' in value:
            DescriptiveName.validate(value['name'], errors, '{}/{}'.format(comp_path ,'name'))
        if 'id' in value:
            IntersectionReferenceID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'revision' in value:
            BumperHeight.validate(value['revision'], errors, '{}/{}'.format(comp_path ,'revision'))
        elif 'revision' not in value:
            report_missing_field(type(self).__name__, 'revision', errors, comp_path)
        if 'status' in value:
            HeadingSlice.validate(value['status'], errors, '{}/{}'.format(comp_path ,'status'))
        elif 'status' not in value:
            report_missing_field(type(self).__name__, 'status', errors, comp_path)
        if 'moy' in value:
            MinuteOfTheYear.validate(value['moy'], errors, '{}/{}'.format(comp_path ,'moy'))
        if 'timeStamp' in value:
            DSecond.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'enabledLanes' in value:
            EnabledLaneList.validate(value['enabledLanes'], errors, '{}/{}'.format(comp_path ,'enabledLanes'))
        if 'states' in value:
            MovementList.validate(value['states'], errors, '{}/{}'.format(comp_path ,'states'))
        elif 'states' not in value:
            report_missing_field(type(self).__name__, 'states', errors, comp_path)
        if 'maneuverAssistList' in value:
            ManeuverAssistList.validate(value['maneuverAssistList'], errors, '{}/{}'.format(comp_path ,'maneuverAssistList'))
        if 'regional' in value:
            IntersectionState__11.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class IntersectionState__11:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,4)]}}]
        self._unique_indetifier = "DSRC.IntersectionState.regional"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RegionalExtension_40.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RegionalExtension_40.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RegionalExtension_40.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = IntersectionState__11()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RegionalExtension_40.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = IntersectionState__11()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = IntersectionState__11()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RegionalExtension_40.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class IntersectionStateList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,32)]}}]
        self._unique_indetifier = "DSRC.IntersectionStateList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                IntersectionState.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                IntersectionState.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(IntersectionState.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = IntersectionStateList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(IntersectionState.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = IntersectionStateList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = IntersectionStateList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                IntersectionState.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class ExitService:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,16)]}}]
        self._unique_indetifier = "DSRC.ExitService"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                ExitService__4.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                ExitService__4.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(ExitService__4.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = ExitService()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(ExitService__4.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = ExitService()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = ExitService()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                ExitService__4.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

GenericSignage = ExitService
SpeedLimit = ExitService
WorkZone = ExitService

class ExitService__4:
    def __init__(self):
        self._comp_types = {"item" : ExitService__3}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.ExitService.c"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ExitService__4()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'item' in value:
            ExitService__3.encode(encoding_rule, value['item'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ExitService__4()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['item'] = ExitService__3.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ExitService__4()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'item' in value:
            ExitService__3.validate(value['item'], errors, '{}/{}'.format(comp_path ,'item'))
        elif 'item' not in value:
            report_missing_field(type(self).__name__, 'item', errors, comp_path)

        return errors

GenericSignage__4 = ExitService__4
SpeedLimit__4 = ExitService__4
WorkZone__4 = ExitService__4

class ExitService__3:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.ExitService.c.item"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"itis": 0, "text": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = ExitService__3()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'itis':
                DSecond.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'text':
                ITIStextPhrase.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = ExitService__3()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'itis':
                alternative = DSecond.decode(encoding_rule, stream, value_tracker)
            if identifier == 'text':
                alternative = ITIStextPhrase.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = ExitService__3()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'itis' in value:
            DSecond.validate(value['itis'], errors, '{}/{}'.format(comp_path ,'itis'))
            is_checked = True
        if 'text' in value:
            ITIStextPhrase.validate(value['text'], errors, '{}/{}'.format(comp_path ,'text'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

GenericSignage__3 = ExitService__3
SpeedLimit__3 = ExitService__3
WorkZone__3 = ExitService__3

class J1939data:
    def __init__(self):
        self._comp_types = {"tires" : TireDataList, "axles" : AxleWeightList, "trailerWeight" : AxleWeight, "cargoWeight" : AxleWeight, "steeringAxleTemperature" : DriveAxleTemperature, "driveAxleLocation" : AmbientAirPressure, "driveAxleLiftAirPressure" : DriveAxleLiftAirPressure, "driveAxleTemperature" : DriveAxleTemperature, "driveAxleLubePressure" : DriveAxleLubePressure, "steeringAxleLubePressure" : DriveAxleLubePressure}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.J1939data"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = J1939data()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 10

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('tires' in value and 'tires' not in self._def_vals):
            preamble_bits[0] = True
        elif ('tires' in value and 'tires' in self._def_vals):
            if not value_tracker.are_def_eq(value['tires'], self._def_vals['tires'], self._comp_types['tires']):
                preamble_bits[0] = True
        if ('axles' in value and 'axles' not in self._def_vals):
            preamble_bits[1] = True
        elif ('axles' in value and 'axles' in self._def_vals):
            if not value_tracker.are_def_eq(value['axles'], self._def_vals['axles'], self._comp_types['axles']):
                preamble_bits[1] = True
        if ('trailerWeight' in value and 'trailerWeight' not in self._def_vals):
            preamble_bits[2] = True
        elif ('trailerWeight' in value and 'trailerWeight' in self._def_vals):
            if not value_tracker.are_def_eq(value['trailerWeight'], self._def_vals['trailerWeight'], self._comp_types['trailerWeight']):
                preamble_bits[2] = True
        if ('cargoWeight' in value and 'cargoWeight' not in self._def_vals):
            preamble_bits[3] = True
        elif ('cargoWeight' in value and 'cargoWeight' in self._def_vals):
            if not value_tracker.are_def_eq(value['cargoWeight'], self._def_vals['cargoWeight'], self._comp_types['cargoWeight']):
                preamble_bits[3] = True
        if ('steeringAxleTemperature' in value and 'steeringAxleTemperature' not in self._def_vals):
            preamble_bits[4] = True
        elif ('steeringAxleTemperature' in value and 'steeringAxleTemperature' in self._def_vals):
            if not value_tracker.are_def_eq(value['steeringAxleTemperature'], self._def_vals['steeringAxleTemperature'], self._comp_types['steeringAxleTemperature']):
                preamble_bits[4] = True
        if ('driveAxleLocation' in value and 'driveAxleLocation' not in self._def_vals):
            preamble_bits[5] = True
        elif ('driveAxleLocation' in value and 'driveAxleLocation' in self._def_vals):
            if not value_tracker.are_def_eq(value['driveAxleLocation'], self._def_vals['driveAxleLocation'], self._comp_types['driveAxleLocation']):
                preamble_bits[5] = True
        if ('driveAxleLiftAirPressure' in value and 'driveAxleLiftAirPressure' not in self._def_vals):
            preamble_bits[6] = True
        elif ('driveAxleLiftAirPressure' in value and 'driveAxleLiftAirPressure' in self._def_vals):
            if not value_tracker.are_def_eq(value['driveAxleLiftAirPressure'], self._def_vals['driveAxleLiftAirPressure'], self._comp_types['driveAxleLiftAirPressure']):
                preamble_bits[6] = True
        if ('driveAxleTemperature' in value and 'driveAxleTemperature' not in self._def_vals):
            preamble_bits[7] = True
        elif ('driveAxleTemperature' in value and 'driveAxleTemperature' in self._def_vals):
            if not value_tracker.are_def_eq(value['driveAxleTemperature'], self._def_vals['driveAxleTemperature'], self._comp_types['driveAxleTemperature']):
                preamble_bits[7] = True
        if ('driveAxleLubePressure' in value and 'driveAxleLubePressure' not in self._def_vals):
            preamble_bits[8] = True
        elif ('driveAxleLubePressure' in value and 'driveAxleLubePressure' in self._def_vals):
            if not value_tracker.are_def_eq(value['driveAxleLubePressure'], self._def_vals['driveAxleLubePressure'], self._comp_types['driveAxleLubePressure']):
                preamble_bits[8] = True
        if ('steeringAxleLubePressure' in value and 'steeringAxleLubePressure' not in self._def_vals):
            preamble_bits[9] = True
        elif ('steeringAxleLubePressure' in value and 'steeringAxleLubePressure' in self._def_vals):
            if not value_tracker.are_def_eq(value['steeringAxleLubePressure'], self._def_vals['steeringAxleLubePressure'], self._comp_types['steeringAxleLubePressure']):
                preamble_bits[9] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            TireDataList.encode(encoding_rule, value['tires'], value_tracker, stream)
        if preamble_bits[2]:
            AxleWeightList.encode(encoding_rule, value['axles'], value_tracker, stream)
        if preamble_bits[3]:
            AxleWeight.encode(encoding_rule, value['trailerWeight'], value_tracker, stream)
        if preamble_bits[4]:
            AxleWeight.encode(encoding_rule, value['cargoWeight'], value_tracker, stream)
        if preamble_bits[5]:
            DriveAxleTemperature.encode(encoding_rule, value['steeringAxleTemperature'], value_tracker, stream)
        if preamble_bits[6]:
            AmbientAirPressure.encode(encoding_rule, value['driveAxleLocation'], value_tracker, stream)
        if preamble_bits[7]:
            DriveAxleLiftAirPressure.encode(encoding_rule, value['driveAxleLiftAirPressure'], value_tracker, stream)
        if preamble_bits[8]:
            DriveAxleTemperature.encode(encoding_rule, value['driveAxleTemperature'], value_tracker, stream)
        if preamble_bits[9]:
            DriveAxleLubePressure.encode(encoding_rule, value['driveAxleLubePressure'], value_tracker, stream)
        if preamble_bits[10]:
            DriveAxleLubePressure.encode(encoding_rule, value['steeringAxleLubePressure'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = J1939data()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 10

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['tires'] = TireDataList.decode(encoding_rule, stream, value_tracker)
        elif 'tires' in self._def_vals:
            value['tires'] = self._def_vals['tires']
        if preamble_bits[2]:
            value['axles'] = AxleWeightList.decode(encoding_rule, stream, value_tracker)
        elif 'axles' in self._def_vals:
            value['axles'] = self._def_vals['axles']
        if preamble_bits[3]:
            value['trailerWeight'] = AxleWeight.decode(encoding_rule, stream, value_tracker)
        elif 'trailerWeight' in self._def_vals:
            value['trailerWeight'] = self._def_vals['trailerWeight']
        if preamble_bits[4]:
            value['cargoWeight'] = AxleWeight.decode(encoding_rule, stream, value_tracker)
        elif 'cargoWeight' in self._def_vals:
            value['cargoWeight'] = self._def_vals['cargoWeight']
        if preamble_bits[5]:
            value['steeringAxleTemperature'] = DriveAxleTemperature.decode(encoding_rule, stream, value_tracker)
        elif 'steeringAxleTemperature' in self._def_vals:
            value['steeringAxleTemperature'] = self._def_vals['steeringAxleTemperature']
        if preamble_bits[6]:
            value['driveAxleLocation'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'driveAxleLocation' in self._def_vals:
            value['driveAxleLocation'] = self._def_vals['driveAxleLocation']
        if preamble_bits[7]:
            value['driveAxleLiftAirPressure'] = DriveAxleLiftAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'driveAxleLiftAirPressure' in self._def_vals:
            value['driveAxleLiftAirPressure'] = self._def_vals['driveAxleLiftAirPressure']
        if preamble_bits[8]:
            value['driveAxleTemperature'] = DriveAxleTemperature.decode(encoding_rule, stream, value_tracker)
        elif 'driveAxleTemperature' in self._def_vals:
            value['driveAxleTemperature'] = self._def_vals['driveAxleTemperature']
        if preamble_bits[9]:
            value['driveAxleLubePressure'] = DriveAxleLubePressure.decode(encoding_rule, stream, value_tracker)
        elif 'driveAxleLubePressure' in self._def_vals:
            value['driveAxleLubePressure'] = self._def_vals['driveAxleLubePressure']
        if preamble_bits[10]:
            value['steeringAxleLubePressure'] = DriveAxleLubePressure.decode(encoding_rule, stream, value_tracker)
        elif 'steeringAxleLubePressure' in self._def_vals:
            value['steeringAxleLubePressure'] = self._def_vals['steeringAxleLubePressure']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = J1939data()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'tires' in value:
            TireDataList.validate(value['tires'], errors, '{}/{}'.format(comp_path ,'tires'))
        if 'axles' in value:
            AxleWeightList.validate(value['axles'], errors, '{}/{}'.format(comp_path ,'axles'))
        if 'trailerWeight' in value:
            AxleWeight.validate(value['trailerWeight'], errors, '{}/{}'.format(comp_path ,'trailerWeight'))
        if 'cargoWeight' in value:
            AxleWeight.validate(value['cargoWeight'], errors, '{}/{}'.format(comp_path ,'cargoWeight'))
        if 'steeringAxleTemperature' in value:
            DriveAxleTemperature.validate(value['steeringAxleTemperature'], errors, '{}/{}'.format(comp_path ,'steeringAxleTemperature'))
        if 'driveAxleLocation' in value:
            AmbientAirPressure.validate(value['driveAxleLocation'], errors, '{}/{}'.format(comp_path ,'driveAxleLocation'))
        if 'driveAxleLiftAirPressure' in value:
            DriveAxleLiftAirPressure.validate(value['driveAxleLiftAirPressure'], errors, '{}/{}'.format(comp_path ,'driveAxleLiftAirPressure'))
        if 'driveAxleTemperature' in value:
            DriveAxleTemperature.validate(value['driveAxleTemperature'], errors, '{}/{}'.format(comp_path ,'driveAxleTemperature'))
        if 'driveAxleLubePressure' in value:
            DriveAxleLubePressure.validate(value['driveAxleLubePressure'], errors, '{}/{}'.format(comp_path ,'driveAxleLubePressure'))
        if 'steeringAxleLubePressure' in value:
            DriveAxleLubePressure.validate(value['steeringAxleLubePressure'], errors, '{}/{}'.format(comp_path ,'steeringAxleLubePressure'))

        return errors

class TireDataList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,16)]}}]
        self._unique_indetifier = "DSRC.TireDataList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                TireData.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                TireData.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(TireData.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = TireDataList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(TireData.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = TireDataList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = TireDataList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                TireData.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class TireData:
    def __init__(self):
        self._comp_types = {"location" : AmbientAirPressure, "pressure" : DriveAxleLubePressure, "temp" : TireTemp, "wheelSensorStatus" : WheelSensorStatus, "wheelEndElectFault" : WheelEndElectFault, "leakageRate" : AxleWeight, "detection" : TirePressureThresholdDetection}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.TireData"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = TireData()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 7

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('location' in value and 'location' not in self._def_vals):
            preamble_bits[0] = True
        elif ('location' in value and 'location' in self._def_vals):
            if not value_tracker.are_def_eq(value['location'], self._def_vals['location'], self._comp_types['location']):
                preamble_bits[0] = True
        if ('pressure' in value and 'pressure' not in self._def_vals):
            preamble_bits[1] = True
        elif ('pressure' in value and 'pressure' in self._def_vals):
            if not value_tracker.are_def_eq(value['pressure'], self._def_vals['pressure'], self._comp_types['pressure']):
                preamble_bits[1] = True
        if ('temp' in value and 'temp' not in self._def_vals):
            preamble_bits[2] = True
        elif ('temp' in value and 'temp' in self._def_vals):
            if not value_tracker.are_def_eq(value['temp'], self._def_vals['temp'], self._comp_types['temp']):
                preamble_bits[2] = True
        if ('wheelSensorStatus' in value and 'wheelSensorStatus' not in self._def_vals):
            preamble_bits[3] = True
        elif ('wheelSensorStatus' in value and 'wheelSensorStatus' in self._def_vals):
            if not value_tracker.are_def_eq(value['wheelSensorStatus'], self._def_vals['wheelSensorStatus'], self._comp_types['wheelSensorStatus']):
                preamble_bits[3] = True
        if ('wheelEndElectFault' in value and 'wheelEndElectFault' not in self._def_vals):
            preamble_bits[4] = True
        elif ('wheelEndElectFault' in value and 'wheelEndElectFault' in self._def_vals):
            if not value_tracker.are_def_eq(value['wheelEndElectFault'], self._def_vals['wheelEndElectFault'], self._comp_types['wheelEndElectFault']):
                preamble_bits[4] = True
        if ('leakageRate' in value and 'leakageRate' not in self._def_vals):
            preamble_bits[5] = True
        elif ('leakageRate' in value and 'leakageRate' in self._def_vals):
            if not value_tracker.are_def_eq(value['leakageRate'], self._def_vals['leakageRate'], self._comp_types['leakageRate']):
                preamble_bits[5] = True
        if ('detection' in value and 'detection' not in self._def_vals):
            preamble_bits[6] = True
        elif ('detection' in value and 'detection' in self._def_vals):
            if not value_tracker.are_def_eq(value['detection'], self._def_vals['detection'], self._comp_types['detection']):
                preamble_bits[6] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            AmbientAirPressure.encode(encoding_rule, value['location'], value_tracker, stream)
        if preamble_bits[2]:
            DriveAxleLubePressure.encode(encoding_rule, value['pressure'], value_tracker, stream)
        if preamble_bits[3]:
            TireTemp.encode(encoding_rule, value['temp'], value_tracker, stream)
        if preamble_bits[4]:
            WheelSensorStatus.encode(encoding_rule, value['wheelSensorStatus'], value_tracker, stream)
        if preamble_bits[5]:
            WheelEndElectFault.encode(encoding_rule, value['wheelEndElectFault'], value_tracker, stream)
        if preamble_bits[6]:
            AxleWeight.encode(encoding_rule, value['leakageRate'], value_tracker, stream)
        if preamble_bits[7]:
            TirePressureThresholdDetection.encode(encoding_rule, value['detection'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = TireData()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 7

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['location'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'location' in self._def_vals:
            value['location'] = self._def_vals['location']
        if preamble_bits[2]:
            value['pressure'] = DriveAxleLubePressure.decode(encoding_rule, stream, value_tracker)
        elif 'pressure' in self._def_vals:
            value['pressure'] = self._def_vals['pressure']
        if preamble_bits[3]:
            value['temp'] = TireTemp.decode(encoding_rule, stream, value_tracker)
        elif 'temp' in self._def_vals:
            value['temp'] = self._def_vals['temp']
        if preamble_bits[4]:
            value['wheelSensorStatus'] = WheelSensorStatus.decode(encoding_rule, stream, value_tracker)
        elif 'wheelSensorStatus' in self._def_vals:
            value['wheelSensorStatus'] = self._def_vals['wheelSensorStatus']
        if preamble_bits[5]:
            value['wheelEndElectFault'] = WheelEndElectFault.decode(encoding_rule, stream, value_tracker)
        elif 'wheelEndElectFault' in self._def_vals:
            value['wheelEndElectFault'] = self._def_vals['wheelEndElectFault']
        if preamble_bits[6]:
            value['leakageRate'] = AxleWeight.decode(encoding_rule, stream, value_tracker)
        elif 'leakageRate' in self._def_vals:
            value['leakageRate'] = self._def_vals['leakageRate']
        if preamble_bits[7]:
            value['detection'] = TirePressureThresholdDetection.decode(encoding_rule, stream, value_tracker)
        elif 'detection' in self._def_vals:
            value['detection'] = self._def_vals['detection']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = TireData()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'location' in value:
            AmbientAirPressure.validate(value['location'], errors, '{}/{}'.format(comp_path ,'location'))
        if 'pressure' in value:
            DriveAxleLubePressure.validate(value['pressure'], errors, '{}/{}'.format(comp_path ,'pressure'))
        if 'temp' in value:
            TireTemp.validate(value['temp'], errors, '{}/{}'.format(comp_path ,'temp'))
        if 'wheelSensorStatus' in value:
            WheelSensorStatus.validate(value['wheelSensorStatus'], errors, '{}/{}'.format(comp_path ,'wheelSensorStatus'))
        if 'wheelEndElectFault' in value:
            WheelEndElectFault.validate(value['wheelEndElectFault'], errors, '{}/{}'.format(comp_path ,'wheelEndElectFault'))
        if 'leakageRate' in value:
            AxleWeight.validate(value['leakageRate'], errors, '{}/{}'.format(comp_path ,'leakageRate'))
        if 'detection' in value:
            TirePressureThresholdDetection.validate(value['detection'], errors, '{}/{}'.format(comp_path ,'detection'))

        return errors

class AxleWeightList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,16)]}}]
        self._unique_indetifier = "DSRC.AxleWeightList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                AxleWeightSet.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                AxleWeightSet.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(AxleWeightSet.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = AxleWeightList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(AxleWeightSet.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = AxleWeightList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = AxleWeightList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                AxleWeightSet.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class AxleWeightSet:
    def __init__(self):
        self._comp_types = {"location" : AmbientAirPressure, "weight" : AxleWeight}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.AxleWeightSet"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = AxleWeightSet()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('location' in value and 'location' not in self._def_vals):
            preamble_bits[0] = True
        elif ('location' in value and 'location' in self._def_vals):
            if not value_tracker.are_def_eq(value['location'], self._def_vals['location'], self._comp_types['location']):
                preamble_bits[0] = True
        if ('weight' in value and 'weight' not in self._def_vals):
            preamble_bits[1] = True
        elif ('weight' in value and 'weight' in self._def_vals):
            if not value_tracker.are_def_eq(value['weight'], self._def_vals['weight'], self._comp_types['weight']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            AmbientAirPressure.encode(encoding_rule, value['location'], value_tracker, stream)
        if preamble_bits[2]:
            AxleWeight.encode(encoding_rule, value['weight'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = AxleWeightSet()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['location'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'location' in self._def_vals:
            value['location'] = self._def_vals['location']
        if preamble_bits[2]:
            value['weight'] = AxleWeight.decode(encoding_rule, stream, value_tracker)
        elif 'weight' in self._def_vals:
            value['weight'] = self._def_vals['weight']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = AxleWeightSet()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'location' in value:
            AmbientAirPressure.validate(value['location'], errors, '{}/{}'.format(comp_path ,'location'))
        if 'weight' in value:
            AxleWeight.validate(value['weight'], errors, '{}/{}'.format(comp_path ,'weight'))

        return errors

class LaneAttributes:
    def __init__(self):
        self._comp_types = {"directionalUse" : LaneDirection, "sharedWith" : LaneSharing, "laneType" : LaneTypeAttributes, "regional" : RegionalExtension_1}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.LaneAttributes"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = LaneAttributes()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[0] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[0] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'directionalUse' in value:
            LaneDirection.encode(encoding_rule, value['directionalUse'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'sharedWith' in value:
            LaneSharing.encode(encoding_rule, value['sharedWith'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'laneType' in value:
            LaneTypeAttributes.encode(encoding_rule, value['laneType'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            RegionalExtension_1.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = LaneAttributes()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['directionalUse'] = LaneDirection.decode(encoding_rule, stream, value_tracker)
        value['sharedWith'] = LaneSharing.decode(encoding_rule, stream, value_tracker)
        value['laneType'] = LaneTypeAttributes.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['regional'] = RegionalExtension_1.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = LaneAttributes()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'directionalUse' in value:
            LaneDirection.validate(value['directionalUse'], errors, '{}/{}'.format(comp_path ,'directionalUse'))
        elif 'directionalUse' not in value:
            report_missing_field(type(self).__name__, 'directionalUse', errors, comp_path)
        if 'sharedWith' in value:
            LaneSharing.validate(value['sharedWith'], errors, '{}/{}'.format(comp_path ,'sharedWith'))
        elif 'sharedWith' not in value:
            report_missing_field(type(self).__name__, 'sharedWith', errors, comp_path)
        if 'laneType' in value:
            LaneTypeAttributes.validate(value['laneType'], errors, '{}/{}'.format(comp_path ,'laneType'))
        elif 'laneType' not in value:
            report_missing_field(type(self).__name__, 'laneType', errors, comp_path)
        if 'regional' in value:
            RegionalExtension_1.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class LaneDataAttribute:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.LaneDataAttribute"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"pathEndPointAngle": 0, "laneCrownPointCenter": 1, "laneCrownPointLeft": 2, "laneCrownPointRight": 3, "laneAngle": 4, "speedLimits": 5, "regional": 6}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = LaneDataAttribute()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 7
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(idx > 63)

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'pathEndPointAngle':
                DeltaAngle.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'laneCrownPointCenter':
                DrivingWheelAngle.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'laneCrownPointLeft':
                DrivingWheelAngle.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'laneCrownPointRight':
                DrivingWheelAngle.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'laneAngle':
                DegreesLong.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'speedLimits':
                SpeedLimitList.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'regional':
                LaneDataAttribute__8.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = LaneDataAttribute()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 7
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'pathEndPointAngle':
                alternative = DeltaAngle.decode(encoding_rule, stream, value_tracker)
            if identifier == 'laneCrownPointCenter':
                alternative = DrivingWheelAngle.decode(encoding_rule, stream, value_tracker)
            if identifier == 'laneCrownPointLeft':
                alternative = DrivingWheelAngle.decode(encoding_rule, stream, value_tracker)
            if identifier == 'laneCrownPointRight':
                alternative = DrivingWheelAngle.decode(encoding_rule, stream, value_tracker)
            if identifier == 'laneAngle':
                alternative = DegreesLong.decode(encoding_rule, stream, value_tracker)
            if identifier == 'speedLimits':
                alternative = SpeedLimitList.decode(encoding_rule, stream, value_tracker)
            if identifier == 'regional':
                alternative = LaneDataAttribute__8.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = LaneDataAttribute()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'pathEndPointAngle' in value:
            DeltaAngle.validate(value['pathEndPointAngle'], errors, '{}/{}'.format(comp_path ,'pathEndPointAngle'))
            is_checked = True
        if 'laneCrownPointCenter' in value:
            DrivingWheelAngle.validate(value['laneCrownPointCenter'], errors, '{}/{}'.format(comp_path ,'laneCrownPointCenter'))
            is_checked = True
        if 'laneCrownPointLeft' in value:
            DrivingWheelAngle.validate(value['laneCrownPointLeft'], errors, '{}/{}'.format(comp_path ,'laneCrownPointLeft'))
            is_checked = True
        if 'laneCrownPointRight' in value:
            DrivingWheelAngle.validate(value['laneCrownPointRight'], errors, '{}/{}'.format(comp_path ,'laneCrownPointRight'))
            is_checked = True
        if 'laneAngle' in value:
            DegreesLong.validate(value['laneAngle'], errors, '{}/{}'.format(comp_path ,'laneAngle'))
            is_checked = True
        if 'speedLimits' in value:
            SpeedLimitList.validate(value['speedLimits'], errors, '{}/{}'.format(comp_path ,'speedLimits'))
            is_checked = True
        if 'regional' in value:
            LaneDataAttribute__8.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class LaneDataAttribute__8:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,4)]}}]
        self._unique_indetifier = "DSRC.LaneDataAttribute.regional"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RegionalExtension_42.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RegionalExtension_42.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RegionalExtension_42.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = LaneDataAttribute__8()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RegionalExtension_42.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = LaneDataAttribute__8()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = LaneDataAttribute__8()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RegionalExtension_42.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class LaneDataAttributeList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,8)]}}]
        self._unique_indetifier = "DSRC.LaneDataAttributeList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                LaneDataAttribute.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                LaneDataAttribute.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(LaneDataAttribute.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = LaneDataAttributeList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(LaneDataAttribute.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = LaneDataAttributeList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = LaneDataAttributeList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                LaneDataAttribute.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class LaneTypeAttributes:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.LaneTypeAttributes"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"vehicle": 0, "crosswalk": 1, "bikeLane": 2, "sidewalk": 3, "median": 4, "striping": 5, "trackedVehicle": 6, "parking": 7}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = LaneTypeAttributes()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 8
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(idx > 63)

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'vehicle':
                LaneAttributes_Vehicle.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'crosswalk':
                HeadingSlice.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'bikeLane':
                HeadingSlice.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'sidewalk':
                HeadingSlice.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'median':
                HeadingSlice.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'striping':
                HeadingSlice.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'trackedVehicle':
                HeadingSlice.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'parking':
                HeadingSlice.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = LaneTypeAttributes()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 8
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'vehicle':
                alternative = LaneAttributes_Vehicle.decode(encoding_rule, stream, value_tracker)
            if identifier == 'crosswalk':
                alternative = HeadingSlice.decode(encoding_rule, stream, value_tracker)
            if identifier == 'bikeLane':
                alternative = HeadingSlice.decode(encoding_rule, stream, value_tracker)
            if identifier == 'sidewalk':
                alternative = HeadingSlice.decode(encoding_rule, stream, value_tracker)
            if identifier == 'median':
                alternative = HeadingSlice.decode(encoding_rule, stream, value_tracker)
            if identifier == 'striping':
                alternative = HeadingSlice.decode(encoding_rule, stream, value_tracker)
            if identifier == 'trackedVehicle':
                alternative = HeadingSlice.decode(encoding_rule, stream, value_tracker)
            if identifier == 'parking':
                alternative = HeadingSlice.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = LaneTypeAttributes()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'vehicle' in value:
            LaneAttributes_Vehicle.validate(value['vehicle'], errors, '{}/{}'.format(comp_path ,'vehicle'))
            is_checked = True
        if 'crosswalk' in value:
            HeadingSlice.validate(value['crosswalk'], errors, '{}/{}'.format(comp_path ,'crosswalk'))
            is_checked = True
        if 'bikeLane' in value:
            HeadingSlice.validate(value['bikeLane'], errors, '{}/{}'.format(comp_path ,'bikeLane'))
            is_checked = True
        if 'sidewalk' in value:
            HeadingSlice.validate(value['sidewalk'], errors, '{}/{}'.format(comp_path ,'sidewalk'))
            is_checked = True
        if 'median' in value:
            HeadingSlice.validate(value['median'], errors, '{}/{}'.format(comp_path ,'median'))
            is_checked = True
        if 'striping' in value:
            HeadingSlice.validate(value['striping'], errors, '{}/{}'.format(comp_path ,'striping'))
            is_checked = True
        if 'trackedVehicle' in value:
            HeadingSlice.validate(value['trackedVehicle'], errors, '{}/{}'.format(comp_path ,'trackedVehicle'))
            is_checked = True
        if 'parking' in value:
            HeadingSlice.validate(value['parking'], errors, '{}/{}'.format(comp_path ,'parking'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class ManeuverAssistList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,16)]}}]
        self._unique_indetifier = "DSRC.ManeuverAssistList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                ConnectionManeuverAssist.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                ConnectionManeuverAssist.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(ConnectionManeuverAssist.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = ManeuverAssistList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(ConnectionManeuverAssist.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = ManeuverAssistList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = ManeuverAssistList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                ConnectionManeuverAssist.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class MovementEventList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,16)]}}]
        self._unique_indetifier = "DSRC.MovementEventList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                MovementEvent.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                MovementEvent.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(MovementEvent.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = MovementEventList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(MovementEvent.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = MovementEventList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = MovementEventList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                MovementEvent.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class MovementEvent:
    def __init__(self):
        self._comp_types = {"eventState" : MovementPhaseState, "timing" : TimeChangeDetails, "speeds" : AdvisorySpeedList, "regional" : MovementEvent__5}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.MovementEvent"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = MovementEvent()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timing' in value and 'timing' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timing' in value and 'timing' in self._def_vals):
            if not value_tracker.are_def_eq(value['timing'], self._def_vals['timing'], self._comp_types['timing']):
                preamble_bits[0] = True
        if ('speeds' in value and 'speeds' not in self._def_vals):
            preamble_bits[1] = True
        elif ('speeds' in value and 'speeds' in self._def_vals):
            if not value_tracker.are_def_eq(value['speeds'], self._def_vals['speeds'], self._comp_types['speeds']):
                preamble_bits[1] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[2] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[2] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'eventState' in value:
            MovementPhaseState.encode(encoding_rule, value['eventState'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            TimeChangeDetails.encode(encoding_rule, value['timing'], value_tracker, stream)
        if preamble_bits[2]:
            AdvisorySpeedList.encode(encoding_rule, value['speeds'], value_tracker, stream)
        if preamble_bits[3]:
            MovementEvent__5.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = MovementEvent()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['eventState'] = MovementPhaseState.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['timing'] = TimeChangeDetails.decode(encoding_rule, stream, value_tracker)
        elif 'timing' in self._def_vals:
            value['timing'] = self._def_vals['timing']
        if preamble_bits[2]:
            value['speeds'] = AdvisorySpeedList.decode(encoding_rule, stream, value_tracker)
        elif 'speeds' in self._def_vals:
            value['speeds'] = self._def_vals['speeds']
        if preamble_bits[3]:
            value['regional'] = MovementEvent__5.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = MovementEvent()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'eventState' in value:
            MovementPhaseState.validate(value['eventState'], errors, '{}/{}'.format(comp_path ,'eventState'))
        elif 'eventState' not in value:
            report_missing_field(type(self).__name__, 'eventState', errors, comp_path)
        if 'timing' in value:
            TimeChangeDetails.validate(value['timing'], errors, '{}/{}'.format(comp_path ,'timing'))
        if 'speeds' in value:
            AdvisorySpeedList.validate(value['speeds'], errors, '{}/{}'.format(comp_path ,'speeds'))
        if 'regional' in value:
            MovementEvent__5.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class MovementEvent__5:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,4)]}}]
        self._unique_indetifier = "DSRC.MovementEvent.regional"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RegionalExtension_43.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RegionalExtension_43.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RegionalExtension_43.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = MovementEvent__5()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RegionalExtension_43.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = MovementEvent__5()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = MovementEvent__5()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RegionalExtension_43.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class MovementList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,255)]}}]
        self._unique_indetifier = "DSRC.MovementList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                MovementState.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                MovementState.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(MovementState.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = MovementList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 255
        data_map['width_length_unaligned'] = 8
        data_map['width_length_aligned'] = 8
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(MovementState.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = MovementList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 255
        data_map['width_length_unaligned'] = 8
        data_map['width_length_aligned'] = 8
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = MovementList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                MovementState.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class MovementState:
    def __init__(self):
        self._comp_types = {"movementName" : DescriptiveName, "signalGroup" : AmbientAirPressure, "state-time-speed" : MovementEventList, "maneuverAssistList" : ManeuverAssistList, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.MovementState"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = MovementState()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('movementName' in value and 'movementName' not in self._def_vals):
            preamble_bits[0] = True
        elif ('movementName' in value and 'movementName' in self._def_vals):
            if not value_tracker.are_def_eq(value['movementName'], self._def_vals['movementName'], self._comp_types['movementName']):
                preamble_bits[0] = True
        if ('maneuverAssistList' in value and 'maneuverAssistList' not in self._def_vals):
            preamble_bits[1] = True
        elif ('maneuverAssistList' in value and 'maneuverAssistList' in self._def_vals):
            if not value_tracker.are_def_eq(value['maneuverAssistList'], self._def_vals['maneuverAssistList'], self._comp_types['maneuverAssistList']):
                preamble_bits[1] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[2] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[2] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            DescriptiveName.encode(encoding_rule, value['movementName'], value_tracker, stream)
        if 'signalGroup' in value:
            AmbientAirPressure.encode(encoding_rule, value['signalGroup'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'state-time-speed' in value:
            MovementEventList.encode(encoding_rule, value['state-time-speed'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            ManeuverAssistList.encode(encoding_rule, value['maneuverAssistList'], value_tracker, stream)
        if preamble_bits[3]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = MovementState()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['movementName'] = DescriptiveName.decode(encoding_rule, stream, value_tracker)
        elif 'movementName' in self._def_vals:
            value['movementName'] = self._def_vals['movementName']
        value['signalGroup'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['state-time-speed'] = MovementEventList.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['maneuverAssistList'] = ManeuverAssistList.decode(encoding_rule, stream, value_tracker)
        elif 'maneuverAssistList' in self._def_vals:
            value['maneuverAssistList'] = self._def_vals['maneuverAssistList']
        if preamble_bits[3]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = MovementState()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'movementName' in value:
            DescriptiveName.validate(value['movementName'], errors, '{}/{}'.format(comp_path ,'movementName'))
        if 'signalGroup' in value:
            AmbientAirPressure.validate(value['signalGroup'], errors, '{}/{}'.format(comp_path ,'signalGroup'))
        elif 'signalGroup' not in value:
            report_missing_field(type(self).__name__, 'signalGroup', errors, comp_path)
        if 'state-time-speed' in value:
            MovementEventList.validate(value['state-time-speed'], errors, '{}/{}'.format(comp_path ,'state-time-speed'))
        elif 'state-time-speed' not in value:
            report_missing_field(type(self).__name__, 'state-time-speed', errors, comp_path)
        if 'maneuverAssistList' in value:
            ManeuverAssistList.validate(value['maneuverAssistList'], errors, '{}/{}'.format(comp_path ,'maneuverAssistList'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class Node_LL_24B:
    def __init__(self):
        self._comp_types = {"lon" : Offset_B12, "lat" : Offset_B12}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-LL-24B"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_LL_24B()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'lon' in value:
            Offset_B12.encode(encoding_rule, value['lon'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            Offset_B12.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_LL_24B()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['lon'] = Offset_B12.decode(encoding_rule, stream, value_tracker)
        value['lat'] = Offset_B12.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_LL_24B()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lon' in value:
            Offset_B12.validate(value['lon'], errors, '{}/{}'.format(comp_path ,'lon'))
        elif 'lon' not in value:
            report_missing_field(type(self).__name__, 'lon', errors, comp_path)
        if 'lat' in value:
            Offset_B12.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)

        return errors

class Node_LL_28B:
    def __init__(self):
        self._comp_types = {"lon" : Offset_B14, "lat" : Offset_B14}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-LL-28B"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_LL_28B()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'lon' in value:
            Offset_B14.encode(encoding_rule, value['lon'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            Offset_B14.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_LL_28B()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['lon'] = Offset_B14.decode(encoding_rule, stream, value_tracker)
        value['lat'] = Offset_B14.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_LL_28B()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lon' in value:
            Offset_B14.validate(value['lon'], errors, '{}/{}'.format(comp_path ,'lon'))
        elif 'lon' not in value:
            report_missing_field(type(self).__name__, 'lon', errors, comp_path)
        if 'lat' in value:
            Offset_B14.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)

        return errors

class Node_LL_32B:
    def __init__(self):
        self._comp_types = {"lon" : Elevation__A, "lat" : Elevation__A}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-LL-32B"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_LL_32B()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'lon' in value:
            Elevation__A.encode(encoding_rule, value['lon'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            Elevation__A.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_LL_32B()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['lon'] = Elevation__A.decode(encoding_rule, stream, value_tracker)
        value['lat'] = Elevation__A.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_LL_32B()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lon' in value:
            Elevation__A.validate(value['lon'], errors, '{}/{}'.format(comp_path ,'lon'))
        elif 'lon' not in value:
            report_missing_field(type(self).__name__, 'lon', errors, comp_path)
        if 'lat' in value:
            Elevation__A.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)

        return errors

class Node_LL_36B:
    def __init__(self):
        self._comp_types = {"lon" : OffsetLL_B18, "lat" : OffsetLL_B18}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-LL-36B"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_LL_36B()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'lon' in value:
            OffsetLL_B18.encode(encoding_rule, value['lon'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            OffsetLL_B18.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_LL_36B()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['lon'] = OffsetLL_B18.decode(encoding_rule, stream, value_tracker)
        value['lat'] = OffsetLL_B18.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_LL_36B()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lon' in value:
            OffsetLL_B18.validate(value['lon'], errors, '{}/{}'.format(comp_path ,'lon'))
        elif 'lon' not in value:
            report_missing_field(type(self).__name__, 'lon', errors, comp_path)
        if 'lat' in value:
            OffsetLL_B18.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)

        return errors

class Node_LL_44B:
    def __init__(self):
        self._comp_types = {"lon" : OffsetLL_B22, "lat" : OffsetLL_B22}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-LL-44B"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_LL_44B()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'lon' in value:
            OffsetLL_B22.encode(encoding_rule, value['lon'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            OffsetLL_B22.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_LL_44B()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['lon'] = OffsetLL_B22.decode(encoding_rule, stream, value_tracker)
        value['lat'] = OffsetLL_B22.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_LL_44B()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lon' in value:
            OffsetLL_B22.validate(value['lon'], errors, '{}/{}'.format(comp_path ,'lon'))
        elif 'lon' not in value:
            report_missing_field(type(self).__name__, 'lon', errors, comp_path)
        if 'lat' in value:
            OffsetLL_B22.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)

        return errors

class Node_LL_48B:
    def __init__(self):
        self._comp_types = {"lon" : OffsetLL_B24, "lat" : OffsetLL_B24}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-LL-48B"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_LL_48B()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'lon' in value:
            OffsetLL_B24.encode(encoding_rule, value['lon'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            OffsetLL_B24.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_LL_48B()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['lon'] = OffsetLL_B24.decode(encoding_rule, stream, value_tracker)
        value['lat'] = OffsetLL_B24.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_LL_48B()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lon' in value:
            OffsetLL_B24.validate(value['lon'], errors, '{}/{}'.format(comp_path ,'lon'))
        elif 'lon' not in value:
            report_missing_field(type(self).__name__, 'lon', errors, comp_path)
        if 'lat' in value:
            OffsetLL_B24.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)

        return errors

class Node_LLmD_64b:
    def __init__(self):
        self._comp_types = {"lon" : Longitude, "lat" : Latitude}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-LLmD-64b"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_LLmD_64b()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'lon' in value:
            Longitude.encode(encoding_rule, value['lon'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            Latitude.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_LLmD_64b()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['lon'] = Longitude.decode(encoding_rule, stream, value_tracker)
        value['lat'] = Latitude.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_LLmD_64b()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lon' in value:
            Longitude.validate(value['lon'], errors, '{}/{}'.format(comp_path ,'lon'))
        elif 'lon' not in value:
            report_missing_field(type(self).__name__, 'lon', errors, comp_path)
        if 'lat' in value:
            Latitude.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)

        return errors

class Node_XY_20b:
    def __init__(self):
        self._comp_types = {"x" : Offset_B10, "y" : Offset_B10}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-XY-20b"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_XY_20b()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'x' in value:
            Offset_B10.encode(encoding_rule, value['x'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'y' in value:
            Offset_B10.encode(encoding_rule, value['y'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_XY_20b()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['x'] = Offset_B10.decode(encoding_rule, stream, value_tracker)
        value['y'] = Offset_B10.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_XY_20b()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'x' in value:
            Offset_B10.validate(value['x'], errors, '{}/{}'.format(comp_path ,'x'))
        elif 'x' not in value:
            report_missing_field(type(self).__name__, 'x', errors, comp_path)
        if 'y' in value:
            Offset_B10.validate(value['y'], errors, '{}/{}'.format(comp_path ,'y'))
        elif 'y' not in value:
            report_missing_field(type(self).__name__, 'y', errors, comp_path)

        return errors

class Node_XY_22b:
    def __init__(self):
        self._comp_types = {"x" : Offset_B11, "y" : Offset_B11}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-XY-22b"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_XY_22b()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'x' in value:
            Offset_B11.encode(encoding_rule, value['x'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'y' in value:
            Offset_B11.encode(encoding_rule, value['y'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_XY_22b()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['x'] = Offset_B11.decode(encoding_rule, stream, value_tracker)
        value['y'] = Offset_B11.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_XY_22b()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'x' in value:
            Offset_B11.validate(value['x'], errors, '{}/{}'.format(comp_path ,'x'))
        elif 'x' not in value:
            report_missing_field(type(self).__name__, 'x', errors, comp_path)
        if 'y' in value:
            Offset_B11.validate(value['y'], errors, '{}/{}'.format(comp_path ,'y'))
        elif 'y' not in value:
            report_missing_field(type(self).__name__, 'y', errors, comp_path)

        return errors

class Node_XY_24b:
    def __init__(self):
        self._comp_types = {"x" : Offset_B12, "y" : Offset_B12}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-XY-24b"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_XY_24b()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'x' in value:
            Offset_B12.encode(encoding_rule, value['x'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'y' in value:
            Offset_B12.encode(encoding_rule, value['y'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_XY_24b()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['x'] = Offset_B12.decode(encoding_rule, stream, value_tracker)
        value['y'] = Offset_B12.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_XY_24b()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'x' in value:
            Offset_B12.validate(value['x'], errors, '{}/{}'.format(comp_path ,'x'))
        elif 'x' not in value:
            report_missing_field(type(self).__name__, 'x', errors, comp_path)
        if 'y' in value:
            Offset_B12.validate(value['y'], errors, '{}/{}'.format(comp_path ,'y'))
        elif 'y' not in value:
            report_missing_field(type(self).__name__, 'y', errors, comp_path)

        return errors

class Node_XY_26b:
    def __init__(self):
        self._comp_types = {"x" : Offset_B13, "y" : Offset_B13}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-XY-26b"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_XY_26b()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'x' in value:
            Offset_B13.encode(encoding_rule, value['x'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'y' in value:
            Offset_B13.encode(encoding_rule, value['y'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_XY_26b()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['x'] = Offset_B13.decode(encoding_rule, stream, value_tracker)
        value['y'] = Offset_B13.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_XY_26b()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'x' in value:
            Offset_B13.validate(value['x'], errors, '{}/{}'.format(comp_path ,'x'))
        elif 'x' not in value:
            report_missing_field(type(self).__name__, 'x', errors, comp_path)
        if 'y' in value:
            Offset_B13.validate(value['y'], errors, '{}/{}'.format(comp_path ,'y'))
        elif 'y' not in value:
            report_missing_field(type(self).__name__, 'y', errors, comp_path)

        return errors

class Node_XY_28b:
    def __init__(self):
        self._comp_types = {"x" : Offset_B14, "y" : Offset_B14}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-XY-28b"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_XY_28b()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'x' in value:
            Offset_B14.encode(encoding_rule, value['x'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'y' in value:
            Offset_B14.encode(encoding_rule, value['y'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_XY_28b()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['x'] = Offset_B14.decode(encoding_rule, stream, value_tracker)
        value['y'] = Offset_B14.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_XY_28b()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'x' in value:
            Offset_B14.validate(value['x'], errors, '{}/{}'.format(comp_path ,'x'))
        elif 'x' not in value:
            report_missing_field(type(self).__name__, 'x', errors, comp_path)
        if 'y' in value:
            Offset_B14.validate(value['y'], errors, '{}/{}'.format(comp_path ,'y'))
        elif 'y' not in value:
            report_missing_field(type(self).__name__, 'y', errors, comp_path)

        return errors

class Node_XY_32b:
    def __init__(self):
        self._comp_types = {"x" : Elevation__A, "y" : Elevation__A}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Node-XY-32b"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_XY_32b()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'x' in value:
            Elevation__A.encode(encoding_rule, value['x'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'y' in value:
            Elevation__A.encode(encoding_rule, value['y'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_XY_32b()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['x'] = Elevation__A.decode(encoding_rule, stream, value_tracker)
        value['y'] = Elevation__A.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_XY_32b()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'x' in value:
            Elevation__A.validate(value['x'], errors, '{}/{}'.format(comp_path ,'x'))
        elif 'x' not in value:
            report_missing_field(type(self).__name__, 'x', errors, comp_path)
        if 'y' in value:
            Elevation__A.validate(value['y'], errors, '{}/{}'.format(comp_path ,'y'))
        elif 'y' not in value:
            report_missing_field(type(self).__name__, 'y', errors, comp_path)

        return errors

class NodeAttributeSetLL:
    def __init__(self):
        self._comp_types = {"localNode" : NodeAttributeLLList, "disabled" : SegmentAttributeLLList, "enabled" : SegmentAttributeLLList, "data" : LaneDataAttributeList, "dWidth" : Offset_B10, "dElevation" : Offset_B10, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.NodeAttributeSetLL"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = NodeAttributeSetLL()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 7

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('localNode' in value and 'localNode' not in self._def_vals):
            preamble_bits[0] = True
        elif ('localNode' in value and 'localNode' in self._def_vals):
            if not value_tracker.are_def_eq(value['localNode'], self._def_vals['localNode'], self._comp_types['localNode']):
                preamble_bits[0] = True
        if ('disabled' in value and 'disabled' not in self._def_vals):
            preamble_bits[1] = True
        elif ('disabled' in value and 'disabled' in self._def_vals):
            if not value_tracker.are_def_eq(value['disabled'], self._def_vals['disabled'], self._comp_types['disabled']):
                preamble_bits[1] = True
        if ('enabled' in value and 'enabled' not in self._def_vals):
            preamble_bits[2] = True
        elif ('enabled' in value and 'enabled' in self._def_vals):
            if not value_tracker.are_def_eq(value['enabled'], self._def_vals['enabled'], self._comp_types['enabled']):
                preamble_bits[2] = True
        if ('data' in value and 'data' not in self._def_vals):
            preamble_bits[3] = True
        elif ('data' in value and 'data' in self._def_vals):
            if not value_tracker.are_def_eq(value['data'], self._def_vals['data'], self._comp_types['data']):
                preamble_bits[3] = True
        if ('dWidth' in value and 'dWidth' not in self._def_vals):
            preamble_bits[4] = True
        elif ('dWidth' in value and 'dWidth' in self._def_vals):
            if not value_tracker.are_def_eq(value['dWidth'], self._def_vals['dWidth'], self._comp_types['dWidth']):
                preamble_bits[4] = True
        if ('dElevation' in value and 'dElevation' not in self._def_vals):
            preamble_bits[5] = True
        elif ('dElevation' in value and 'dElevation' in self._def_vals):
            if not value_tracker.are_def_eq(value['dElevation'], self._def_vals['dElevation'], self._comp_types['dElevation']):
                preamble_bits[5] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[6] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[6] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            NodeAttributeLLList.encode(encoding_rule, value['localNode'], value_tracker, stream)
        if preamble_bits[2]:
            SegmentAttributeLLList.encode(encoding_rule, value['disabled'], value_tracker, stream)
        if preamble_bits[3]:
            SegmentAttributeLLList.encode(encoding_rule, value['enabled'], value_tracker, stream)
        if preamble_bits[4]:
            LaneDataAttributeList.encode(encoding_rule, value['data'], value_tracker, stream)
        if preamble_bits[5]:
            Offset_B10.encode(encoding_rule, value['dWidth'], value_tracker, stream)
        if preamble_bits[6]:
            Offset_B10.encode(encoding_rule, value['dElevation'], value_tracker, stream)
        if preamble_bits[7]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = NodeAttributeSetLL()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 7

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['localNode'] = NodeAttributeLLList.decode(encoding_rule, stream, value_tracker)
        elif 'localNode' in self._def_vals:
            value['localNode'] = self._def_vals['localNode']
        if preamble_bits[2]:
            value['disabled'] = SegmentAttributeLLList.decode(encoding_rule, stream, value_tracker)
        elif 'disabled' in self._def_vals:
            value['disabled'] = self._def_vals['disabled']
        if preamble_bits[3]:
            value['enabled'] = SegmentAttributeLLList.decode(encoding_rule, stream, value_tracker)
        elif 'enabled' in self._def_vals:
            value['enabled'] = self._def_vals['enabled']
        if preamble_bits[4]:
            value['data'] = LaneDataAttributeList.decode(encoding_rule, stream, value_tracker)
        elif 'data' in self._def_vals:
            value['data'] = self._def_vals['data']
        if preamble_bits[5]:
            value['dWidth'] = Offset_B10.decode(encoding_rule, stream, value_tracker)
        elif 'dWidth' in self._def_vals:
            value['dWidth'] = self._def_vals['dWidth']
        if preamble_bits[6]:
            value['dElevation'] = Offset_B10.decode(encoding_rule, stream, value_tracker)
        elif 'dElevation' in self._def_vals:
            value['dElevation'] = self._def_vals['dElevation']
        if preamble_bits[7]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = NodeAttributeSetLL()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'localNode' in value:
            NodeAttributeLLList.validate(value['localNode'], errors, '{}/{}'.format(comp_path ,'localNode'))
        if 'disabled' in value:
            SegmentAttributeLLList.validate(value['disabled'], errors, '{}/{}'.format(comp_path ,'disabled'))
        if 'enabled' in value:
            SegmentAttributeLLList.validate(value['enabled'], errors, '{}/{}'.format(comp_path ,'enabled'))
        if 'data' in value:
            LaneDataAttributeList.validate(value['data'], errors, '{}/{}'.format(comp_path ,'data'))
        if 'dWidth' in value:
            Offset_B10.validate(value['dWidth'], errors, '{}/{}'.format(comp_path ,'dWidth'))
        if 'dElevation' in value:
            Offset_B10.validate(value['dElevation'], errors, '{}/{}'.format(comp_path ,'dElevation'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

NodeAttributeSetXY = NodeAttributeSetLL

class NodeAttributeLLList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,8)]}}]
        self._unique_indetifier = "DSRC.NodeAttributeLLList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                NodeAttributeLL.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                NodeAttributeLL.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(NodeAttributeLL.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = NodeAttributeLLList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(NodeAttributeLL.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = NodeAttributeLLList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = NodeAttributeLLList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                NodeAttributeLL.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

NodeAttributeXYList = NodeAttributeLLList

class NodeListLL:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.NodeListLL"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"nodes": 0}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = NodeListLL()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 1
        data_map['width_index_unaligned'] = 0
        data_map['width_index_aligned'] = 0
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(idx > 63)

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'nodes':
                NodeSetLL.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = NodeListLL()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 1
        data_map['width_index_unaligned'] = 0
        data_map['width_index_aligned'] = 0
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'nodes':
                alternative = NodeSetLL.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = NodeListLL()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'nodes' in value:
            NodeSetLL.validate(value['nodes'], errors, '{}/{}'.format(comp_path ,'nodes'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class NodeListXY:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.NodeListXY"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"nodes": 0, "computed": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = NodeListXY()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(idx > 63)

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'nodes':
                NodeSetXY.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'computed':
                ComputedLane.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = NodeListXY()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'nodes':
                alternative = NodeSetXY.decode(encoding_rule, stream, value_tracker)
            if identifier == 'computed':
                alternative = ComputedLane.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = NodeListXY()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'nodes' in value:
            NodeSetXY.validate(value['nodes'], errors, '{}/{}'.format(comp_path ,'nodes'))
            is_checked = True
        if 'computed' in value:
            ComputedLane.validate(value['computed'], errors, '{}/{}'.format(comp_path ,'computed'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class NodeLL:
    def __init__(self):
        self._comp_types = {"delta" : NodeOffsetPointLL, "attributes" : NodeAttributeSetLL}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.NodeLL"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = NodeLL()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('attributes' in value and 'attributes' not in self._def_vals):
            preamble_bits[0] = True
        elif ('attributes' in value and 'attributes' in self._def_vals):
            if not value_tracker.are_def_eq(value['attributes'], self._def_vals['attributes'], self._comp_types['attributes']):
                preamble_bits[0] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'delta' in value:
            NodeOffsetPointLL.encode(encoding_rule, value['delta'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            NodeAttributeSetLL.encode(encoding_rule, value['attributes'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = NodeLL()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['delta'] = NodeOffsetPointLL.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['attributes'] = NodeAttributeSetLL.decode(encoding_rule, stream, value_tracker)
        elif 'attributes' in self._def_vals:
            value['attributes'] = self._def_vals['attributes']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = NodeLL()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'delta' in value:
            NodeOffsetPointLL.validate(value['delta'], errors, '{}/{}'.format(comp_path ,'delta'))
        elif 'delta' not in value:
            report_missing_field(type(self).__name__, 'delta', errors, comp_path)
        if 'attributes' in value:
            NodeAttributeSetLL.validate(value['attributes'], errors, '{}/{}'.format(comp_path ,'attributes'))

        return errors

class NodeOffsetPointLL:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.NodeOffsetPointLL"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"node-LL1": 0, "node-LL2": 1, "node-LL3": 2, "node-LL4": 3, "node-LL5": 4, "node-LL6": 5, "node-LatLon": 6, "regional": 7}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = NodeOffsetPointLL()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 8
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'node-LL1':
                Node_LL_24B.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-LL2':
                Node_LL_28B.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-LL3':
                Node_LL_32B.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-LL4':
                Node_LL_36B.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-LL5':
                Node_LL_44B.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-LL6':
                Node_LL_48B.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-LatLon':
                Node_LLmD_64b.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'regional':
                RegionalExtension_1.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = NodeOffsetPointLL()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 8
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'node-LL1':
                alternative = Node_LL_24B.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-LL2':
                alternative = Node_LL_28B.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-LL3':
                alternative = Node_LL_32B.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-LL4':
                alternative = Node_LL_36B.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-LL5':
                alternative = Node_LL_44B.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-LL6':
                alternative = Node_LL_48B.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-LatLon':
                alternative = Node_LLmD_64b.decode(encoding_rule, stream, value_tracker)
            if identifier == 'regional':
                alternative = RegionalExtension_1.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = NodeOffsetPointLL()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'node-LL1' in value:
            Node_LL_24B.validate(value['node-LL1'], errors, '{}/{}'.format(comp_path ,'node-LL1'))
            is_checked = True
        if 'node-LL2' in value:
            Node_LL_28B.validate(value['node-LL2'], errors, '{}/{}'.format(comp_path ,'node-LL2'))
            is_checked = True
        if 'node-LL3' in value:
            Node_LL_32B.validate(value['node-LL3'], errors, '{}/{}'.format(comp_path ,'node-LL3'))
            is_checked = True
        if 'node-LL4' in value:
            Node_LL_36B.validate(value['node-LL4'], errors, '{}/{}'.format(comp_path ,'node-LL4'))
            is_checked = True
        if 'node-LL5' in value:
            Node_LL_44B.validate(value['node-LL5'], errors, '{}/{}'.format(comp_path ,'node-LL5'))
            is_checked = True
        if 'node-LL6' in value:
            Node_LL_48B.validate(value['node-LL6'], errors, '{}/{}'.format(comp_path ,'node-LL6'))
            is_checked = True
        if 'node-LatLon' in value:
            Node_LLmD_64b.validate(value['node-LatLon'], errors, '{}/{}'.format(comp_path ,'node-LatLon'))
            is_checked = True
        if 'regional' in value:
            RegionalExtension_1.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class NodeOffsetPointXY:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.NodeOffsetPointXY"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"node-XY1": 0, "node-XY2": 1, "node-XY3": 2, "node-XY4": 3, "node-XY5": 4, "node-XY6": 5, "node-LatLon": 6, "regional": 7}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = NodeOffsetPointXY()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 8
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'node-XY1':
                Node_XY_20b.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-XY2':
                Node_XY_22b.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-XY3':
                Node_XY_24b.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-XY4':
                Node_XY_26b.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-XY5':
                Node_XY_28b.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-XY6':
                Node_XY_32b.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'node-LatLon':
                Node_LLmD_64b.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'regional':
                RegionalExtension_48.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = NodeOffsetPointXY()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 8
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'node-XY1':
                alternative = Node_XY_20b.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-XY2':
                alternative = Node_XY_22b.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-XY3':
                alternative = Node_XY_24b.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-XY4':
                alternative = Node_XY_26b.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-XY5':
                alternative = Node_XY_28b.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-XY6':
                alternative = Node_XY_32b.decode(encoding_rule, stream, value_tracker)
            if identifier == 'node-LatLon':
                alternative = Node_LLmD_64b.decode(encoding_rule, stream, value_tracker)
            if identifier == 'regional':
                alternative = RegionalExtension_48.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = NodeOffsetPointXY()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'node-XY1' in value:
            Node_XY_20b.validate(value['node-XY1'], errors, '{}/{}'.format(comp_path ,'node-XY1'))
            is_checked = True
        if 'node-XY2' in value:
            Node_XY_22b.validate(value['node-XY2'], errors, '{}/{}'.format(comp_path ,'node-XY2'))
            is_checked = True
        if 'node-XY3' in value:
            Node_XY_24b.validate(value['node-XY3'], errors, '{}/{}'.format(comp_path ,'node-XY3'))
            is_checked = True
        if 'node-XY4' in value:
            Node_XY_26b.validate(value['node-XY4'], errors, '{}/{}'.format(comp_path ,'node-XY4'))
            is_checked = True
        if 'node-XY5' in value:
            Node_XY_28b.validate(value['node-XY5'], errors, '{}/{}'.format(comp_path ,'node-XY5'))
            is_checked = True
        if 'node-XY6' in value:
            Node_XY_32b.validate(value['node-XY6'], errors, '{}/{}'.format(comp_path ,'node-XY6'))
            is_checked = True
        if 'node-LatLon' in value:
            Node_LLmD_64b.validate(value['node-LatLon'], errors, '{}/{}'.format(comp_path ,'node-LatLon'))
            is_checked = True
        if 'regional' in value:
            RegionalExtension_48.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class NodeSetLL:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(2,63)]}}]
        self._unique_indetifier = "DSRC.NodeSetLL"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                NodeLL.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                NodeLL.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(NodeLL.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = NodeSetLL()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 2
        data_map['maximum_root_size'] = 63
        data_map['width_length_unaligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(NodeLL.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = NodeSetLL()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 2
        data_map['maximum_root_size'] = 63
        data_map['width_length_unaligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = NodeSetLL()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                NodeLL.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class NodeSetXY:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(2,63)]}}]
        self._unique_indetifier = "DSRC.NodeSetXY"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                NodeXY.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                NodeXY.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(NodeXY.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = NodeSetXY()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 2
        data_map['maximum_root_size'] = 63
        data_map['width_length_unaligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(NodeXY.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = NodeSetXY()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 2
        data_map['maximum_root_size'] = 63
        data_map['width_length_unaligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = NodeSetXY()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                NodeXY.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class NodeXY:
    def __init__(self):
        self._comp_types = {"delta" : NodeOffsetPointXY, "attributes" : NodeAttributeSetLL}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.NodeXY"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = NodeXY()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('attributes' in value and 'attributes' not in self._def_vals):
            preamble_bits[0] = True
        elif ('attributes' in value and 'attributes' in self._def_vals):
            if not value_tracker.are_def_eq(value['attributes'], self._def_vals['attributes'], self._comp_types['attributes']):
                preamble_bits[0] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'delta' in value:
            NodeOffsetPointXY.encode(encoding_rule, value['delta'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            NodeAttributeSetLL.encode(encoding_rule, value['attributes'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = NodeXY()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['delta'] = NodeOffsetPointXY.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['attributes'] = NodeAttributeSetLL.decode(encoding_rule, stream, value_tracker)
        elif 'attributes' in self._def_vals:
            value['attributes'] = self._def_vals['attributes']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = NodeXY()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'delta' in value:
            NodeOffsetPointXY.validate(value['delta'], errors, '{}/{}'.format(comp_path ,'delta'))
        elif 'delta' not in value:
            report_missing_field(type(self).__name__, 'delta', errors, comp_path)
        if 'attributes' in value:
            NodeAttributeSetLL.validate(value['attributes'], errors, '{}/{}'.format(comp_path ,'attributes'))

        return errors

class ObstacleDetection:
    def __init__(self):
        self._comp_types = {"obDist" : DSRCmsgID, "obDirect" : Angle, "description" : DisabledVehicle__1, "locationDetails" : GenericLocations, "dateTime" : DDateTime, "vertEvent" : BrakeAppliedStatus}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.ObstacleDetection"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ObstacleDetection()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('description' in value and 'description' not in self._def_vals):
            preamble_bits[0] = True
        elif ('description' in value and 'description' in self._def_vals):
            if not value_tracker.are_def_eq(value['description'], self._def_vals['description'], self._comp_types['description']):
                preamble_bits[0] = True
        if ('locationDetails' in value and 'locationDetails' not in self._def_vals):
            preamble_bits[1] = True
        elif ('locationDetails' in value and 'locationDetails' in self._def_vals):
            if not value_tracker.are_def_eq(value['locationDetails'], self._def_vals['locationDetails'], self._comp_types['locationDetails']):
                preamble_bits[1] = True
        if ('vertEvent' in value and 'vertEvent' not in self._def_vals):
            preamble_bits[2] = True
        elif ('vertEvent' in value and 'vertEvent' in self._def_vals):
            if not value_tracker.are_def_eq(value['vertEvent'], self._def_vals['vertEvent'], self._comp_types['vertEvent']):
                preamble_bits[2] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'obDist' in value:
            DSRCmsgID.encode(encoding_rule, value['obDist'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'obDirect' in value:
            Angle.encode(encoding_rule, value['obDirect'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            DisabledVehicle__1.encode(encoding_rule, value['description'], value_tracker, stream)
        if preamble_bits[2]:
            GenericLocations.encode(encoding_rule, value['locationDetails'], value_tracker, stream)
        if 'dateTime' in value:
            DDateTime.encode(encoding_rule, value['dateTime'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[3]:
            BrakeAppliedStatus.encode(encoding_rule, value['vertEvent'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ObstacleDetection()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['obDist'] = DSRCmsgID.decode(encoding_rule, stream, value_tracker)
        value['obDirect'] = Angle.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['description'] = DisabledVehicle__1.decode(encoding_rule, stream, value_tracker)
        elif 'description' in self._def_vals:
            value['description'] = self._def_vals['description']
        if preamble_bits[2]:
            value['locationDetails'] = GenericLocations.decode(encoding_rule, stream, value_tracker)
        elif 'locationDetails' in self._def_vals:
            value['locationDetails'] = self._def_vals['locationDetails']
        value['dateTime'] = DDateTime.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[3]:
            value['vertEvent'] = BrakeAppliedStatus.decode(encoding_rule, stream, value_tracker)
        elif 'vertEvent' in self._def_vals:
            value['vertEvent'] = self._def_vals['vertEvent']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ObstacleDetection()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'obDist' in value:
            DSRCmsgID.validate(value['obDist'], errors, '{}/{}'.format(comp_path ,'obDist'))
        elif 'obDist' not in value:
            report_missing_field(type(self).__name__, 'obDist', errors, comp_path)
        if 'obDirect' in value:
            Angle.validate(value['obDirect'], errors, '{}/{}'.format(comp_path ,'obDirect'))
        elif 'obDirect' not in value:
            report_missing_field(type(self).__name__, 'obDirect', errors, comp_path)
        if 'description' in value:
            DisabledVehicle__1.validate(value['description'], errors, '{}/{}'.format(comp_path ,'description'))
        if 'locationDetails' in value:
            GenericLocations.validate(value['locationDetails'], errors, '{}/{}'.format(comp_path ,'locationDetails'))
        if 'dateTime' in value:
            DDateTime.validate(value['dateTime'], errors, '{}/{}'.format(comp_path ,'dateTime'))
        elif 'dateTime' not in value:
            report_missing_field(type(self).__name__, 'dateTime', errors, comp_path)
        if 'vertEvent' in value:
            BrakeAppliedStatus.validate(value['vertEvent'], errors, '{}/{}'.format(comp_path ,'vertEvent'))

        return errors

class DisabledVehicle__1:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..65535","permitted":[(0,65535)]}},{"type":"subtype constraint","root expression":{"type":"value range","definition": "523..541","permitted":[(523,541)]}}]
        self._unique_indetifier = "DSRC.DisabledVehicle.statusDetails"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DisabledVehicle__1()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 5
        data_map['width_value_unaligned'] = 5
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 523
        data_map['maximum'] = 541

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DisabledVehicle__1()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 5
        data_map['width_value_unaligned'] = 5
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 523
        data_map['maximum'] = 541

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DisabledVehicle__1()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

ObstacleDetection__3 = DisabledVehicle__1

class OffsetSystem:
    def __init__(self):
        self._comp_types = {"scale" : ApproachID, "offset" : OffsetSystem__4}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.OffsetSystem"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = OffsetSystem()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('scale' in value and 'scale' not in self._def_vals):
            preamble_bits[0] = True
        elif ('scale' in value and 'scale' in self._def_vals):
            if not value_tracker.are_def_eq(value['scale'], self._def_vals['scale'], self._comp_types['scale']):
                preamble_bits[0] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[0]:
            ApproachID.encode(encoding_rule, value['scale'], value_tracker, stream)
        if 'offset' in value:
            OffsetSystem__4.encode(encoding_rule, value['offset'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = OffsetSystem()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[0]:
            value['scale'] = ApproachID.decode(encoding_rule, stream, value_tracker)
        elif 'scale' in self._def_vals:
            value['scale'] = self._def_vals['scale']
        value['offset'] = OffsetSystem__4.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = OffsetSystem()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'scale' in value:
            ApproachID.validate(value['scale'], errors, '{}/{}'.format(comp_path ,'scale'))
        if 'offset' in value:
            OffsetSystem__4.validate(value['offset'], errors, '{}/{}'.format(comp_path ,'offset'))
        elif 'offset' not in value:
            report_missing_field(type(self).__name__, 'offset', errors, comp_path)

        return errors

class OffsetSystem__4:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.OffsetSystem.offset"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"xy": 0, "ll": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = OffsetSystem__4()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'xy':
                NodeListXY.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'll':
                NodeListLL.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = OffsetSystem__4()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'xy':
                alternative = NodeListXY.decode(encoding_rule, stream, value_tracker)
            if identifier == 'll':
                alternative = NodeListLL.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = OffsetSystem__4()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'xy' in value:
            NodeListXY.validate(value['xy'], errors, '{}/{}'.format(comp_path ,'xy'))
            is_checked = True
        if 'll' in value:
            NodeListLL.validate(value['ll'], errors, '{}/{}'.format(comp_path ,'ll'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class OverlayLaneList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,5)]}}]
        self._unique_indetifier = "DSRC.OverlayLaneList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                AmbientAirPressure.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                AmbientAirPressure.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(AmbientAirPressure.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = OverlayLaneList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 5
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(AmbientAirPressure.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = OverlayLaneList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 5
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = OverlayLaneList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                AmbientAirPressure.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class PathHistory:
    def __init__(self):
        self._comp_types = {"initialPosition" : FullPositionVector, "currGNSSstatus" : GNSSstatus, "crumbData" : PathHistoryPointList}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.PathHistory"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = PathHistory()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('initialPosition' in value and 'initialPosition' not in self._def_vals):
            preamble_bits[0] = True
        elif ('initialPosition' in value and 'initialPosition' in self._def_vals):
            if not value_tracker.are_def_eq(value['initialPosition'], self._def_vals['initialPosition'], self._comp_types['initialPosition']):
                preamble_bits[0] = True
        if ('currGNSSstatus' in value and 'currGNSSstatus' not in self._def_vals):
            preamble_bits[1] = True
        elif ('currGNSSstatus' in value and 'currGNSSstatus' in self._def_vals):
            if not value_tracker.are_def_eq(value['currGNSSstatus'], self._def_vals['currGNSSstatus'], self._comp_types['currGNSSstatus']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            FullPositionVector.encode(encoding_rule, value['initialPosition'], value_tracker, stream)
        if preamble_bits[2]:
            GNSSstatus.encode(encoding_rule, value['currGNSSstatus'], value_tracker, stream)
        if 'crumbData' in value:
            PathHistoryPointList.encode(encoding_rule, value['crumbData'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = PathHistory()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['initialPosition'] = FullPositionVector.decode(encoding_rule, stream, value_tracker)
        elif 'initialPosition' in self._def_vals:
            value['initialPosition'] = self._def_vals['initialPosition']
        if preamble_bits[2]:
            value['currGNSSstatus'] = GNSSstatus.decode(encoding_rule, stream, value_tracker)
        elif 'currGNSSstatus' in self._def_vals:
            value['currGNSSstatus'] = self._def_vals['currGNSSstatus']
        value['crumbData'] = PathHistoryPointList.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = PathHistory()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'initialPosition' in value:
            FullPositionVector.validate(value['initialPosition'], errors, '{}/{}'.format(comp_path ,'initialPosition'))
        if 'currGNSSstatus' in value:
            GNSSstatus.validate(value['currGNSSstatus'], errors, '{}/{}'.format(comp_path ,'currGNSSstatus'))
        if 'crumbData' in value:
            PathHistoryPointList.validate(value['crumbData'], errors, '{}/{}'.format(comp_path ,'crumbData'))
        elif 'crumbData' not in value:
            report_missing_field(type(self).__name__, 'crumbData', errors, comp_path)

        return errors

class PathHistoryPointList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,23)]}}]
        self._unique_indetifier = "DSRC.PathHistoryPointList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                PathHistoryPoint.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                PathHistoryPoint.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(PathHistoryPoint.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = PathHistoryPointList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 23
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(PathHistoryPoint.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = PathHistoryPointList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 23
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = PathHistoryPointList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                PathHistoryPoint.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class PathHistoryPoint:
    def __init__(self):
        self._comp_types = {"latOffset" : OffsetLL_B18, "lonOffset" : OffsetLL_B18, "elevationOffset" : Offset_B12, "timeOffset" : TimeOffset, "speed" : Speed, "posAccuracy" : PositionalAccuracy, "heading" : CoarseHeading}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.PathHistoryPoint"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = PathHistoryPoint()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('speed' in value and 'speed' not in self._def_vals):
            preamble_bits[0] = True
        elif ('speed' in value and 'speed' in self._def_vals):
            if not value_tracker.are_def_eq(value['speed'], self._def_vals['speed'], self._comp_types['speed']):
                preamble_bits[0] = True
        if ('posAccuracy' in value and 'posAccuracy' not in self._def_vals):
            preamble_bits[1] = True
        elif ('posAccuracy' in value and 'posAccuracy' in self._def_vals):
            if not value_tracker.are_def_eq(value['posAccuracy'], self._def_vals['posAccuracy'], self._comp_types['posAccuracy']):
                preamble_bits[1] = True
        if ('heading' in value and 'heading' not in self._def_vals):
            preamble_bits[2] = True
        elif ('heading' in value and 'heading' in self._def_vals):
            if not value_tracker.are_def_eq(value['heading'], self._def_vals['heading'], self._comp_types['heading']):
                preamble_bits[2] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'latOffset' in value:
            OffsetLL_B18.encode(encoding_rule, value['latOffset'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lonOffset' in value:
            OffsetLL_B18.encode(encoding_rule, value['lonOffset'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'elevationOffset' in value:
            Offset_B12.encode(encoding_rule, value['elevationOffset'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'timeOffset' in value:
            TimeOffset.encode(encoding_rule, value['timeOffset'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            Speed.encode(encoding_rule, value['speed'], value_tracker, stream)
        if preamble_bits[2]:
            PositionalAccuracy.encode(encoding_rule, value['posAccuracy'], value_tracker, stream)
        if preamble_bits[3]:
            CoarseHeading.encode(encoding_rule, value['heading'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = PathHistoryPoint()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['latOffset'] = OffsetLL_B18.decode(encoding_rule, stream, value_tracker)
        value['lonOffset'] = OffsetLL_B18.decode(encoding_rule, stream, value_tracker)
        value['elevationOffset'] = Offset_B12.decode(encoding_rule, stream, value_tracker)
        value['timeOffset'] = TimeOffset.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['speed'] = Speed.decode(encoding_rule, stream, value_tracker)
        elif 'speed' in self._def_vals:
            value['speed'] = self._def_vals['speed']
        if preamble_bits[2]:
            value['posAccuracy'] = PositionalAccuracy.decode(encoding_rule, stream, value_tracker)
        elif 'posAccuracy' in self._def_vals:
            value['posAccuracy'] = self._def_vals['posAccuracy']
        if preamble_bits[3]:
            value['heading'] = CoarseHeading.decode(encoding_rule, stream, value_tracker)
        elif 'heading' in self._def_vals:
            value['heading'] = self._def_vals['heading']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = PathHistoryPoint()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'latOffset' in value:
            OffsetLL_B18.validate(value['latOffset'], errors, '{}/{}'.format(comp_path ,'latOffset'))
        elif 'latOffset' not in value:
            report_missing_field(type(self).__name__, 'latOffset', errors, comp_path)
        if 'lonOffset' in value:
            OffsetLL_B18.validate(value['lonOffset'], errors, '{}/{}'.format(comp_path ,'lonOffset'))
        elif 'lonOffset' not in value:
            report_missing_field(type(self).__name__, 'lonOffset', errors, comp_path)
        if 'elevationOffset' in value:
            Offset_B12.validate(value['elevationOffset'], errors, '{}/{}'.format(comp_path ,'elevationOffset'))
        elif 'elevationOffset' not in value:
            report_missing_field(type(self).__name__, 'elevationOffset', errors, comp_path)
        if 'timeOffset' in value:
            TimeOffset.validate(value['timeOffset'], errors, '{}/{}'.format(comp_path ,'timeOffset'))
        elif 'timeOffset' not in value:
            report_missing_field(type(self).__name__, 'timeOffset', errors, comp_path)
        if 'speed' in value:
            Speed.validate(value['speed'], errors, '{}/{}'.format(comp_path ,'speed'))
        if 'posAccuracy' in value:
            PositionalAccuracy.validate(value['posAccuracy'], errors, '{}/{}'.format(comp_path ,'posAccuracy'))
        if 'heading' in value:
            CoarseHeading.validate(value['heading'], errors, '{}/{}'.format(comp_path ,'heading'))

        return errors

class PathPrediction:
    def __init__(self):
        self._comp_types = {"radiusOfCurve" : DrivenLineOffsetLg, "confidence" : AttachmentRadius}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.PathPrediction"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = PathPrediction()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'radiusOfCurve' in value:
            DrivenLineOffsetLg.encode(encoding_rule, value['radiusOfCurve'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'confidence' in value:
            AttachmentRadius.encode(encoding_rule, value['confidence'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = PathPrediction()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['radiusOfCurve'] = DrivenLineOffsetLg.decode(encoding_rule, stream, value_tracker)
        value['confidence'] = AttachmentRadius.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = PathPrediction()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'radiusOfCurve' in value:
            DrivenLineOffsetLg.validate(value['radiusOfCurve'], errors, '{}/{}'.format(comp_path ,'radiusOfCurve'))
        elif 'radiusOfCurve' not in value:
            report_missing_field(type(self).__name__, 'radiusOfCurve', errors, comp_path)
        if 'confidence' in value:
            AttachmentRadius.validate(value['confidence'], errors, '{}/{}'.format(comp_path ,'confidence'))
        elif 'confidence' not in value:
            report_missing_field(type(self).__name__, 'confidence', errors, comp_path)

        return errors

class PivotPointDescription:
    def __init__(self):
        self._comp_types = {"pivotOffset" : Offset_B11, "pivotAngle" : Angle, "pivots" : IsDolly}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.PivotPointDescription"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = PivotPointDescription()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'pivotOffset' in value:
            Offset_B11.encode(encoding_rule, value['pivotOffset'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'pivotAngle' in value:
            Angle.encode(encoding_rule, value['pivotAngle'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'pivots' in value:
            IsDolly.encode(encoding_rule, value['pivots'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = PivotPointDescription()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['pivotOffset'] = Offset_B11.decode(encoding_rule, stream, value_tracker)
        value['pivotAngle'] = Angle.decode(encoding_rule, stream, value_tracker)
        value['pivots'] = IsDolly.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = PivotPointDescription()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'pivotOffset' in value:
            Offset_B11.validate(value['pivotOffset'], errors, '{}/{}'.format(comp_path ,'pivotOffset'))
        elif 'pivotOffset' not in value:
            report_missing_field(type(self).__name__, 'pivotOffset', errors, comp_path)
        if 'pivotAngle' in value:
            Angle.validate(value['pivotAngle'], errors, '{}/{}'.format(comp_path ,'pivotAngle'))
        elif 'pivotAngle' not in value:
            report_missing_field(type(self).__name__, 'pivotAngle', errors, comp_path)
        if 'pivots' in value:
            IsDolly.validate(value['pivots'], errors, '{}/{}'.format(comp_path ,'pivots'))
        elif 'pivots' not in value:
            report_missing_field(type(self).__name__, 'pivots', errors, comp_path)

        return errors

class Position3D:
    def __init__(self):
        self._comp_types = {"lat" : Latitude, "long" : Longitude, "elevation" : Elevation, "regional" : Position3D__5}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Position3D"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Position3D()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('elevation' in value and 'elevation' not in self._def_vals):
            preamble_bits[0] = True
        elif ('elevation' in value and 'elevation' in self._def_vals):
            if not value_tracker.are_def_eq(value['elevation'], self._def_vals['elevation'], self._comp_types['elevation']):
                preamble_bits[0] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[1] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'lat' in value:
            Latitude.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'long' in value:
            Longitude.encode(encoding_rule, value['long'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            Elevation.encode(encoding_rule, value['elevation'], value_tracker, stream)
        if preamble_bits[2]:
            Position3D__5.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Position3D()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['lat'] = Latitude.decode(encoding_rule, stream, value_tracker)
        value['long'] = Longitude.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['elevation'] = Elevation.decode(encoding_rule, stream, value_tracker)
        elif 'elevation' in self._def_vals:
            value['elevation'] = self._def_vals['elevation']
        if preamble_bits[2]:
            value['regional'] = Position3D__5.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Position3D()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lat' in value:
            Latitude.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)
        if 'long' in value:
            Longitude.validate(value['long'], errors, '{}/{}'.format(comp_path ,'long'))
        elif 'long' not in value:
            report_missing_field(type(self).__name__, 'long', errors, comp_path)
        if 'elevation' in value:
            Elevation.validate(value['elevation'], errors, '{}/{}'.format(comp_path ,'elevation'))
        if 'regional' in value:
            Position3D__5.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class Position3D__5:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,4)]}}]
        self._unique_indetifier = "DSRC.Position3D.regional"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RegionalExtension_49.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RegionalExtension_49.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RegionalExtension_49.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = Position3D__5()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RegionalExtension_49.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = Position3D__5()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = Position3D__5()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RegionalExtension_49.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class PositionalAccuracy:
    def __init__(self):
        self._comp_types = {"semiMajor" : AmbientAirPressure, "semiMinor" : AmbientAirPressure, "orientation" : DSecond}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.PositionalAccuracy"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = PositionalAccuracy()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'semiMajor' in value:
            AmbientAirPressure.encode(encoding_rule, value['semiMajor'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'semiMinor' in value:
            AmbientAirPressure.encode(encoding_rule, value['semiMinor'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'orientation' in value:
            DSecond.encode(encoding_rule, value['orientation'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = PositionalAccuracy()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['semiMajor'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['semiMinor'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['orientation'] = DSecond.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = PositionalAccuracy()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'semiMajor' in value:
            AmbientAirPressure.validate(value['semiMajor'], errors, '{}/{}'.format(comp_path ,'semiMajor'))
        elif 'semiMajor' not in value:
            report_missing_field(type(self).__name__, 'semiMajor', errors, comp_path)
        if 'semiMinor' in value:
            AmbientAirPressure.validate(value['semiMinor'], errors, '{}/{}'.format(comp_path ,'semiMinor'))
        elif 'semiMinor' not in value:
            report_missing_field(type(self).__name__, 'semiMinor', errors, comp_path)
        if 'orientation' in value:
            DSecond.validate(value['orientation'], errors, '{}/{}'.format(comp_path ,'orientation'))
        elif 'orientation' not in value:
            report_missing_field(type(self).__name__, 'orientation', errors, comp_path)

        return errors

class PositionConfidenceSet:
    def __init__(self):
        self._comp_types = {"pos" : PositionConfidence, "elevation" : ElevationConfidence}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.PositionConfidenceSet"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = PositionConfidenceSet()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'pos' in value:
            PositionConfidence.encode(encoding_rule, value['pos'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'elevation' in value:
            ElevationConfidence.encode(encoding_rule, value['elevation'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = PositionConfidenceSet()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['pos'] = PositionConfidence.decode(encoding_rule, stream, value_tracker)
        value['elevation'] = ElevationConfidence.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = PositionConfidenceSet()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'pos' in value:
            PositionConfidence.validate(value['pos'], errors, '{}/{}'.format(comp_path ,'pos'))
        elif 'pos' not in value:
            report_missing_field(type(self).__name__, 'pos', errors, comp_path)
        if 'elevation' in value:
            ElevationConfidence.validate(value['elevation'], errors, '{}/{}'.format(comp_path ,'elevation'))
        elif 'elevation' not in value:
            report_missing_field(type(self).__name__, 'elevation', errors, comp_path)

        return errors

class PreemptPriorityList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,32)]}}]
        self._unique_indetifier = "DSRC.PreemptPriorityList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                SignalControlZone.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                SignalControlZone.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(SignalControlZone.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = PreemptPriorityList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(SignalControlZone.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = PreemptPriorityList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = PreemptPriorityList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                SignalControlZone.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class SignalControlZone:
    def __init__(self):
        self._comp_types = {"zone" : RegionalExtension_1}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SignalControlZone"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SignalControlZone()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'zone' in value:
            RegionalExtension_1.encode(encoding_rule, value['zone'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SignalControlZone()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['zone'] = RegionalExtension_1.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SignalControlZone()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'zone' in value:
            RegionalExtension_1.validate(value['zone'], errors, '{}/{}'.format(comp_path ,'zone'))
        elif 'zone' not in value:
            report_missing_field(type(self).__name__, 'zone', errors, comp_path)

        return errors

class PrivilegedEvents:
    def __init__(self):
        self._comp_types = {"sspRights" : DDay, "event" : HeadingSlice}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.PrivilegedEvents"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = PrivilegedEvents()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'sspRights' in value:
            DDay.encode(encoding_rule, value['sspRights'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'event' in value:
            HeadingSlice.encode(encoding_rule, value['event'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = PrivilegedEvents()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['sspRights'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['event'] = HeadingSlice.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = PrivilegedEvents()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'sspRights' in value:
            DDay.validate(value['sspRights'], errors, '{}/{}'.format(comp_path ,'sspRights'))
        elif 'sspRights' not in value:
            report_missing_field(type(self).__name__, 'sspRights', errors, comp_path)
        if 'event' in value:
            HeadingSlice.validate(value['event'], errors, '{}/{}'.format(comp_path ,'event'))
        elif 'event' not in value:
            report_missing_field(type(self).__name__, 'event', errors, comp_path)

        return errors

class PropelledInformation:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.PropelledInformation"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"human": 0, "animal": 1, "motor": 2}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = PropelledInformation()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 3
        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(idx > 63)

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'human':
                HumanPropelledType.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'animal':
                AnimalPropelledType.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'motor':
                MotorizedPropelledType.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = PropelledInformation()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 3
        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'human':
                alternative = HumanPropelledType.decode(encoding_rule, stream, value_tracker)
            if identifier == 'animal':
                alternative = AnimalPropelledType.decode(encoding_rule, stream, value_tracker)
            if identifier == 'motor':
                alternative = MotorizedPropelledType.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = PropelledInformation()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'human' in value:
            HumanPropelledType.validate(value['human'], errors, '{}/{}'.format(comp_path ,'human'))
            is_checked = True
        if 'animal' in value:
            AnimalPropelledType.validate(value['animal'], errors, '{}/{}'.format(comp_path ,'animal'))
            is_checked = True
        if 'motor' in value:
            MotorizedPropelledType.validate(value['motor'], errors, '{}/{}'.format(comp_path ,'motor'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class RegionList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,64)]}}]
        self._unique_indetifier = "DSRC.RegionList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RegionOffsets.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RegionOffsets.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RegionOffsets.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = RegionList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 64
        data_map['width_length_unaligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RegionOffsets.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = RegionList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 64
        data_map['width_length_unaligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = RegionList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RegionOffsets.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class RegionOffsets:
    def __init__(self):
        self._comp_types = {"xOffset" : Elevation__A, "yOffset" : Elevation__A, "zOffset" : Elevation__A}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RegionOffsets"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegionOffsets()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('zOffset' in value and 'zOffset' not in self._def_vals):
            preamble_bits[0] = True
        elif ('zOffset' in value and 'zOffset' in self._def_vals):
            if not value_tracker.are_def_eq(value['zOffset'], self._def_vals['zOffset'], self._comp_types['zOffset']):
                preamble_bits[0] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'xOffset' in value:
            Elevation__A.encode(encoding_rule, value['xOffset'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'yOffset' in value:
            Elevation__A.encode(encoding_rule, value['yOffset'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            Elevation__A.encode(encoding_rule, value['zOffset'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegionOffsets()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['xOffset'] = Elevation__A.decode(encoding_rule, stream, value_tracker)
        value['yOffset'] = Elevation__A.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['zOffset'] = Elevation__A.decode(encoding_rule, stream, value_tracker)
        elif 'zOffset' in self._def_vals:
            value['zOffset'] = self._def_vals['zOffset']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegionOffsets()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'xOffset' in value:
            Elevation__A.validate(value['xOffset'], errors, '{}/{}'.format(comp_path ,'xOffset'))
        elif 'xOffset' not in value:
            report_missing_field(type(self).__name__, 'xOffset', errors, comp_path)
        if 'yOffset' in value:
            Elevation__A.validate(value['yOffset'], errors, '{}/{}'.format(comp_path ,'yOffset'))
        elif 'yOffset' not in value:
            report_missing_field(type(self).__name__, 'yOffset', errors, comp_path)
        if 'zOffset' in value:
            Elevation__A.validate(value['zOffset'], errors, '{}/{}'.format(comp_path ,'zOffset'))

        return errors

class RegionPointSet:
    def __init__(self):
        self._comp_types = {"anchor" : Position3D, "scale" : ApproachID, "nodeList" : RegionList}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RegionPointSet"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegionPointSet()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('anchor' in value and 'anchor' not in self._def_vals):
            preamble_bits[0] = True
        elif ('anchor' in value and 'anchor' in self._def_vals):
            if not value_tracker.are_def_eq(value['anchor'], self._def_vals['anchor'], self._comp_types['anchor']):
                preamble_bits[0] = True
        if ('scale' in value and 'scale' not in self._def_vals):
            preamble_bits[1] = True
        elif ('scale' in value and 'scale' in self._def_vals):
            if not value_tracker.are_def_eq(value['scale'], self._def_vals['scale'], self._comp_types['scale']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            Position3D.encode(encoding_rule, value['anchor'], value_tracker, stream)
        if preamble_bits[2]:
            ApproachID.encode(encoding_rule, value['scale'], value_tracker, stream)
        if 'nodeList' in value:
            RegionList.encode(encoding_rule, value['nodeList'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegionPointSet()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['anchor'] = Position3D.decode(encoding_rule, stream, value_tracker)
        elif 'anchor' in self._def_vals:
            value['anchor'] = self._def_vals['anchor']
        if preamble_bits[2]:
            value['scale'] = ApproachID.decode(encoding_rule, stream, value_tracker)
        elif 'scale' in self._def_vals:
            value['scale'] = self._def_vals['scale']
        value['nodeList'] = RegionList.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegionPointSet()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'anchor' in value:
            Position3D.validate(value['anchor'], errors, '{}/{}'.format(comp_path ,'anchor'))
        if 'scale' in value:
            ApproachID.validate(value['scale'], errors, '{}/{}'.format(comp_path ,'scale'))
        if 'nodeList' in value:
            RegionList.validate(value['nodeList'], errors, '{}/{}'.format(comp_path ,'nodeList'))
        elif 'nodeList' not in value:
            report_missing_field(type(self).__name__, 'nodeList', errors, comp_path)

        return errors

class RegulatorySpeedLimit:
    def __init__(self):
        self._comp_types = {"type" : SpeedLimitType, "speed" : Speed}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RegulatorySpeedLimit"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegulatorySpeedLimit()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'type' in value:
            SpeedLimitType.encode(encoding_rule, value['type'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'speed' in value:
            Speed.encode(encoding_rule, value['speed'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegulatorySpeedLimit()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['type'] = SpeedLimitType.decode(encoding_rule, stream, value_tracker)
        value['speed'] = Speed.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegulatorySpeedLimit()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'type' in value:
            SpeedLimitType.validate(value['type'], errors, '{}/{}'.format(comp_path ,'type'))
        elif 'type' not in value:
            report_missing_field(type(self).__name__, 'type', errors, comp_path)
        if 'speed' in value:
            Speed.validate(value['speed'], errors, '{}/{}'.format(comp_path ,'speed'))
        elif 'speed' not in value:
            report_missing_field(type(self).__name__, 'speed', errors, comp_path)

        return errors

class RequestedItemList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,32)]}}]
        self._unique_indetifier = "DSRC.RequestedItemList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RequestedItem.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RequestedItem.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RequestedItem.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = RequestedItemList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RequestedItem.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = RequestedItemList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = RequestedItemList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RequestedItem.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class RequestorDescription:
    def __init__(self):
        self._comp_types = {"id" : VehicleID, "type" : RequestorType, "position" : RequestorPositionVector, "name" : DescriptiveName, "routeName" : DescriptiveName, "transitStatus" : GNSSstatus, "transitOccupancy" : TransitVehicleOccupancy, "transitSchedule" : DeltaTime, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RequestorDescription"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RequestorDescription()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 8

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('type' in value and 'type' not in self._def_vals):
            preamble_bits[0] = True
        elif ('type' in value and 'type' in self._def_vals):
            if not value_tracker.are_def_eq(value['type'], self._def_vals['type'], self._comp_types['type']):
                preamble_bits[0] = True
        if ('position' in value and 'position' not in self._def_vals):
            preamble_bits[1] = True
        elif ('position' in value and 'position' in self._def_vals):
            if not value_tracker.are_def_eq(value['position'], self._def_vals['position'], self._comp_types['position']):
                preamble_bits[1] = True
        if ('name' in value and 'name' not in self._def_vals):
            preamble_bits[2] = True
        elif ('name' in value and 'name' in self._def_vals):
            if not value_tracker.are_def_eq(value['name'], self._def_vals['name'], self._comp_types['name']):
                preamble_bits[2] = True
        if ('routeName' in value and 'routeName' not in self._def_vals):
            preamble_bits[3] = True
        elif ('routeName' in value and 'routeName' in self._def_vals):
            if not value_tracker.are_def_eq(value['routeName'], self._def_vals['routeName'], self._comp_types['routeName']):
                preamble_bits[3] = True
        if ('transitStatus' in value and 'transitStatus' not in self._def_vals):
            preamble_bits[4] = True
        elif ('transitStatus' in value and 'transitStatus' in self._def_vals):
            if not value_tracker.are_def_eq(value['transitStatus'], self._def_vals['transitStatus'], self._comp_types['transitStatus']):
                preamble_bits[4] = True
        if ('transitOccupancy' in value and 'transitOccupancy' not in self._def_vals):
            preamble_bits[5] = True
        elif ('transitOccupancy' in value and 'transitOccupancy' in self._def_vals):
            if not value_tracker.are_def_eq(value['transitOccupancy'], self._def_vals['transitOccupancy'], self._comp_types['transitOccupancy']):
                preamble_bits[5] = True
        if ('transitSchedule' in value and 'transitSchedule' not in self._def_vals):
            preamble_bits[6] = True
        elif ('transitSchedule' in value and 'transitSchedule' in self._def_vals):
            if not value_tracker.are_def_eq(value['transitSchedule'], self._def_vals['transitSchedule'], self._comp_types['transitSchedule']):
                preamble_bits[6] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[7] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[7] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'id' in value:
            VehicleID.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            RequestorType.encode(encoding_rule, value['type'], value_tracker, stream)
        if preamble_bits[2]:
            RequestorPositionVector.encode(encoding_rule, value['position'], value_tracker, stream)
        if preamble_bits[3]:
            DescriptiveName.encode(encoding_rule, value['name'], value_tracker, stream)
        if preamble_bits[4]:
            DescriptiveName.encode(encoding_rule, value['routeName'], value_tracker, stream)
        if preamble_bits[5]:
            GNSSstatus.encode(encoding_rule, value['transitStatus'], value_tracker, stream)
        if preamble_bits[6]:
            TransitVehicleOccupancy.encode(encoding_rule, value['transitOccupancy'], value_tracker, stream)
        if preamble_bits[7]:
            DeltaTime.encode(encoding_rule, value['transitSchedule'], value_tracker, stream)
        if preamble_bits[8]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RequestorDescription()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 8

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['id'] = VehicleID.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['type'] = RequestorType.decode(encoding_rule, stream, value_tracker)
        elif 'type' in self._def_vals:
            value['type'] = self._def_vals['type']
        if preamble_bits[2]:
            value['position'] = RequestorPositionVector.decode(encoding_rule, stream, value_tracker)
        elif 'position' in self._def_vals:
            value['position'] = self._def_vals['position']
        if preamble_bits[3]:
            value['name'] = DescriptiveName.decode(encoding_rule, stream, value_tracker)
        elif 'name' in self._def_vals:
            value['name'] = self._def_vals['name']
        if preamble_bits[4]:
            value['routeName'] = DescriptiveName.decode(encoding_rule, stream, value_tracker)
        elif 'routeName' in self._def_vals:
            value['routeName'] = self._def_vals['routeName']
        if preamble_bits[5]:
            value['transitStatus'] = GNSSstatus.decode(encoding_rule, stream, value_tracker)
        elif 'transitStatus' in self._def_vals:
            value['transitStatus'] = self._def_vals['transitStatus']
        if preamble_bits[6]:
            value['transitOccupancy'] = TransitVehicleOccupancy.decode(encoding_rule, stream, value_tracker)
        elif 'transitOccupancy' in self._def_vals:
            value['transitOccupancy'] = self._def_vals['transitOccupancy']
        if preamble_bits[7]:
            value['transitSchedule'] = DeltaTime.decode(encoding_rule, stream, value_tracker)
        elif 'transitSchedule' in self._def_vals:
            value['transitSchedule'] = self._def_vals['transitSchedule']
        if preamble_bits[8]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RequestorDescription()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'id' in value:
            VehicleID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'type' in value:
            RequestorType.validate(value['type'], errors, '{}/{}'.format(comp_path ,'type'))
        if 'position' in value:
            RequestorPositionVector.validate(value['position'], errors, '{}/{}'.format(comp_path ,'position'))
        if 'name' in value:
            DescriptiveName.validate(value['name'], errors, '{}/{}'.format(comp_path ,'name'))
        if 'routeName' in value:
            DescriptiveName.validate(value['routeName'], errors, '{}/{}'.format(comp_path ,'routeName'))
        if 'transitStatus' in value:
            GNSSstatus.validate(value['transitStatus'], errors, '{}/{}'.format(comp_path ,'transitStatus'))
        if 'transitOccupancy' in value:
            TransitVehicleOccupancy.validate(value['transitOccupancy'], errors, '{}/{}'.format(comp_path ,'transitOccupancy'))
        if 'transitSchedule' in value:
            DeltaTime.validate(value['transitSchedule'], errors, '{}/{}'.format(comp_path ,'transitSchedule'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class RequestorPositionVector:
    def __init__(self):
        self._comp_types = {"position" : Position3D, "heading" : Angle, "speed" : TransmissionAndSpeed}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RequestorPositionVector"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RequestorPositionVector()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('heading' in value and 'heading' not in self._def_vals):
            preamble_bits[0] = True
        elif ('heading' in value and 'heading' in self._def_vals):
            if not value_tracker.are_def_eq(value['heading'], self._def_vals['heading'], self._comp_types['heading']):
                preamble_bits[0] = True
        if ('speed' in value and 'speed' not in self._def_vals):
            preamble_bits[1] = True
        elif ('speed' in value and 'speed' in self._def_vals):
            if not value_tracker.are_def_eq(value['speed'], self._def_vals['speed'], self._comp_types['speed']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'position' in value:
            Position3D.encode(encoding_rule, value['position'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            Angle.encode(encoding_rule, value['heading'], value_tracker, stream)
        if preamble_bits[2]:
            TransmissionAndSpeed.encode(encoding_rule, value['speed'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RequestorPositionVector()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['position'] = Position3D.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['heading'] = Angle.decode(encoding_rule, stream, value_tracker)
        elif 'heading' in self._def_vals:
            value['heading'] = self._def_vals['heading']
        if preamble_bits[2]:
            value['speed'] = TransmissionAndSpeed.decode(encoding_rule, stream, value_tracker)
        elif 'speed' in self._def_vals:
            value['speed'] = self._def_vals['speed']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RequestorPositionVector()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'position' in value:
            Position3D.validate(value['position'], errors, '{}/{}'.format(comp_path ,'position'))
        elif 'position' not in value:
            report_missing_field(type(self).__name__, 'position', errors, comp_path)
        if 'heading' in value:
            Angle.validate(value['heading'], errors, '{}/{}'.format(comp_path ,'heading'))
        if 'speed' in value:
            TransmissionAndSpeed.validate(value['speed'], errors, '{}/{}'.format(comp_path ,'speed'))

        return errors

class RequestorType:
    def __init__(self):
        self._comp_types = {"role" : BasicVehicleRole, "subrole" : RequestSubRole, "request" : RequestImportanceLevel, "iso3883" : Iso3833VehicleType, "hpmsType" : VehicleType, "regional" : RegionalExtension_1}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RequestorType"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RequestorType()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('subrole' in value and 'subrole' not in self._def_vals):
            preamble_bits[0] = True
        elif ('subrole' in value and 'subrole' in self._def_vals):
            if not value_tracker.are_def_eq(value['subrole'], self._def_vals['subrole'], self._comp_types['subrole']):
                preamble_bits[0] = True
        if ('request' in value and 'request' not in self._def_vals):
            preamble_bits[1] = True
        elif ('request' in value and 'request' in self._def_vals):
            if not value_tracker.are_def_eq(value['request'], self._def_vals['request'], self._comp_types['request']):
                preamble_bits[1] = True
        if ('iso3883' in value and 'iso3883' not in self._def_vals):
            preamble_bits[2] = True
        elif ('iso3883' in value and 'iso3883' in self._def_vals):
            if not value_tracker.are_def_eq(value['iso3883'], self._def_vals['iso3883'], self._comp_types['iso3883']):
                preamble_bits[2] = True
        if ('hpmsType' in value and 'hpmsType' not in self._def_vals):
            preamble_bits[3] = True
        elif ('hpmsType' in value and 'hpmsType' in self._def_vals):
            if not value_tracker.are_def_eq(value['hpmsType'], self._def_vals['hpmsType'], self._comp_types['hpmsType']):
                preamble_bits[3] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[4] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[4] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'role' in value:
            BasicVehicleRole.encode(encoding_rule, value['role'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            RequestSubRole.encode(encoding_rule, value['subrole'], value_tracker, stream)
        if preamble_bits[2]:
            RequestImportanceLevel.encode(encoding_rule, value['request'], value_tracker, stream)
        if preamble_bits[3]:
            Iso3833VehicleType.encode(encoding_rule, value['iso3883'], value_tracker, stream)
        if preamble_bits[4]:
            VehicleType.encode(encoding_rule, value['hpmsType'], value_tracker, stream)
        if preamble_bits[5]:
            RegionalExtension_1.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RequestorType()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['role'] = BasicVehicleRole.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['subrole'] = RequestSubRole.decode(encoding_rule, stream, value_tracker)
        elif 'subrole' in self._def_vals:
            value['subrole'] = self._def_vals['subrole']
        if preamble_bits[2]:
            value['request'] = RequestImportanceLevel.decode(encoding_rule, stream, value_tracker)
        elif 'request' in self._def_vals:
            value['request'] = self._def_vals['request']
        if preamble_bits[3]:
            value['iso3883'] = Iso3833VehicleType.decode(encoding_rule, stream, value_tracker)
        elif 'iso3883' in self._def_vals:
            value['iso3883'] = self._def_vals['iso3883']
        if preamble_bits[4]:
            value['hpmsType'] = VehicleType.decode(encoding_rule, stream, value_tracker)
        elif 'hpmsType' in self._def_vals:
            value['hpmsType'] = self._def_vals['hpmsType']
        if preamble_bits[5]:
            value['regional'] = RegionalExtension_1.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RequestorType()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'role' in value:
            BasicVehicleRole.validate(value['role'], errors, '{}/{}'.format(comp_path ,'role'))
        elif 'role' not in value:
            report_missing_field(type(self).__name__, 'role', errors, comp_path)
        if 'subrole' in value:
            RequestSubRole.validate(value['subrole'], errors, '{}/{}'.format(comp_path ,'subrole'))
        if 'request' in value:
            RequestImportanceLevel.validate(value['request'], errors, '{}/{}'.format(comp_path ,'request'))
        if 'iso3883' in value:
            Iso3833VehicleType.validate(value['iso3883'], errors, '{}/{}'.format(comp_path ,'iso3883'))
        if 'hpmsType' in value:
            VehicleType.validate(value['hpmsType'], errors, '{}/{}'.format(comp_path ,'hpmsType'))
        if 'regional' in value:
            RegionalExtension_1.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class RestrictionClassAssignment:
    def __init__(self):
        self._comp_types = {"id" : AmbientAirPressure, "users" : RestrictionUserTypeList}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RestrictionClassAssignment"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RestrictionClassAssignment()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'id' in value:
            AmbientAirPressure.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'users' in value:
            RestrictionUserTypeList.encode(encoding_rule, value['users'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RestrictionClassAssignment()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['id'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['users'] = RestrictionUserTypeList.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RestrictionClassAssignment()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'id' in value:
            AmbientAirPressure.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'users' in value:
            RestrictionUserTypeList.validate(value['users'], errors, '{}/{}'.format(comp_path ,'users'))
        elif 'users' not in value:
            report_missing_field(type(self).__name__, 'users', errors, comp_path)

        return errors

class RestrictionClassList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,254)]}}]
        self._unique_indetifier = "DSRC.RestrictionClassList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RestrictionClassAssignment.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RestrictionClassAssignment.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RestrictionClassAssignment.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = RestrictionClassList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 254
        data_map['width_length_unaligned'] = 8
        data_map['width_length_aligned'] = 8
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RestrictionClassAssignment.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = RestrictionClassList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 254
        data_map['width_length_unaligned'] = 8
        data_map['width_length_aligned'] = 8
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = RestrictionClassList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RestrictionClassAssignment.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class RestrictionUserTypeList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,16)]}}]
        self._unique_indetifier = "DSRC.RestrictionUserTypeList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RestrictionUserType.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RestrictionUserType.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RestrictionUserType.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = RestrictionUserTypeList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RestrictionUserType.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = RestrictionUserTypeList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = RestrictionUserTypeList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RestrictionUserType.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class RestrictionUserType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RestrictionUserType"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"basicType": 0, "regional": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = RestrictionUserType()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(idx > 63)

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'basicType':
                RestrictionAppliesTo.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'regional':
                RestrictionUserType__3.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = RestrictionUserType()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'basicType':
                alternative = RestrictionAppliesTo.decode(encoding_rule, stream, value_tracker)
            if identifier == 'regional':
                alternative = RestrictionUserType__3.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = RestrictionUserType()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'basicType' in value:
            RestrictionAppliesTo.validate(value['basicType'], errors, '{}/{}'.format(comp_path ,'basicType'))
            is_checked = True
        if 'regional' in value:
            RestrictionUserType__3.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class RestrictionUserType__3:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,4)]}}]
        self._unique_indetifier = "DSRC.RestrictionUserType.regional"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RegionalExtension_53.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RegionalExtension_53.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RegionalExtension_53.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = RestrictionUserType__3()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RegionalExtension_53.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = RestrictionUserType__3()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = RestrictionUserType__3()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RegionalExtension_53.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class LaneList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,255)]}}]
        self._unique_indetifier = "DSRC.LaneList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                GenericLane.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                GenericLane.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(GenericLane.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = LaneList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 255
        data_map['width_length_unaligned'] = 8
        data_map['width_length_aligned'] = 8
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(GenericLane.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = LaneList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 255
        data_map['width_length_unaligned'] = 8
        data_map['width_length_aligned'] = 8
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = LaneList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                GenericLane.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

RoadLaneSetList = LaneList

class RoadSegmentList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,32)]}}]
        self._unique_indetifier = "DSRC.RoadSegmentList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RoadSegment.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RoadSegment.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RoadSegment.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = RoadSegmentList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RoadSegment.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = RoadSegmentList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = RoadSegmentList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RoadSegment.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class IntersectionReferenceID:
    def __init__(self):
        self._comp_types = {"region" : DSecond, "id" : DSecond}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.IntersectionReferenceID"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = IntersectionReferenceID()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('region' in value and 'region' not in self._def_vals):
            preamble_bits[0] = True
        elif ('region' in value and 'region' in self._def_vals):
            if not value_tracker.are_def_eq(value['region'], self._def_vals['region'], self._comp_types['region']):
                preamble_bits[0] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[0]:
            DSecond.encode(encoding_rule, value['region'], value_tracker, stream)
        if 'id' in value:
            DSecond.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = IntersectionReferenceID()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[0]:
            value['region'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'region' in self._def_vals:
            value['region'] = self._def_vals['region']
        value['id'] = DSecond.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = IntersectionReferenceID()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'region' in value:
            DSecond.validate(value['region'], errors, '{}/{}'.format(comp_path ,'region'))
        if 'id' in value:
            DSecond.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)

        return errors

RoadSegmentReferenceID = IntersectionReferenceID

class RoadSegment:
    def __init__(self):
        self._comp_types = {"name" : DescriptiveName, "id" : IntersectionReferenceID, "revision" : BumperHeight, "refPoint" : Position3D, "laneWidth" : DSRCmsgID, "speedLimits" : SpeedLimitList, "roadLaneSet" : LaneList, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RoadSegment"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RoadSegment()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('name' in value and 'name' not in self._def_vals):
            preamble_bits[0] = True
        elif ('name' in value and 'name' in self._def_vals):
            if not value_tracker.are_def_eq(value['name'], self._def_vals['name'], self._comp_types['name']):
                preamble_bits[0] = True
        if ('laneWidth' in value and 'laneWidth' not in self._def_vals):
            preamble_bits[1] = True
        elif ('laneWidth' in value and 'laneWidth' in self._def_vals):
            if not value_tracker.are_def_eq(value['laneWidth'], self._def_vals['laneWidth'], self._comp_types['laneWidth']):
                preamble_bits[1] = True
        if ('speedLimits' in value and 'speedLimits' not in self._def_vals):
            preamble_bits[2] = True
        elif ('speedLimits' in value and 'speedLimits' in self._def_vals):
            if not value_tracker.are_def_eq(value['speedLimits'], self._def_vals['speedLimits'], self._comp_types['speedLimits']):
                preamble_bits[2] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[3] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            DescriptiveName.encode(encoding_rule, value['name'], value_tracker, stream)
        if 'id' in value:
            IntersectionReferenceID.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'revision' in value:
            BumperHeight.encode(encoding_rule, value['revision'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'refPoint' in value:
            Position3D.encode(encoding_rule, value['refPoint'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            DSRCmsgID.encode(encoding_rule, value['laneWidth'], value_tracker, stream)
        if preamble_bits[3]:
            SpeedLimitList.encode(encoding_rule, value['speedLimits'], value_tracker, stream)
        if 'roadLaneSet' in value:
            LaneList.encode(encoding_rule, value['roadLaneSet'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[4]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RoadSegment()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['name'] = DescriptiveName.decode(encoding_rule, stream, value_tracker)
        elif 'name' in self._def_vals:
            value['name'] = self._def_vals['name']
        value['id'] = IntersectionReferenceID.decode(encoding_rule, stream, value_tracker)
        value['revision'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        value['refPoint'] = Position3D.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['laneWidth'] = DSRCmsgID.decode(encoding_rule, stream, value_tracker)
        elif 'laneWidth' in self._def_vals:
            value['laneWidth'] = self._def_vals['laneWidth']
        if preamble_bits[3]:
            value['speedLimits'] = SpeedLimitList.decode(encoding_rule, stream, value_tracker)
        elif 'speedLimits' in self._def_vals:
            value['speedLimits'] = self._def_vals['speedLimits']
        value['roadLaneSet'] = LaneList.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[4]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RoadSegment()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'name' in value:
            DescriptiveName.validate(value['name'], errors, '{}/{}'.format(comp_path ,'name'))
        if 'id' in value:
            IntersectionReferenceID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'revision' in value:
            BumperHeight.validate(value['revision'], errors, '{}/{}'.format(comp_path ,'revision'))
        elif 'revision' not in value:
            report_missing_field(type(self).__name__, 'revision', errors, comp_path)
        if 'refPoint' in value:
            Position3D.validate(value['refPoint'], errors, '{}/{}'.format(comp_path ,'refPoint'))
        elif 'refPoint' not in value:
            report_missing_field(type(self).__name__, 'refPoint', errors, comp_path)
        if 'laneWidth' in value:
            DSRCmsgID.validate(value['laneWidth'], errors, '{}/{}'.format(comp_path ,'laneWidth'))
        if 'speedLimits' in value:
            SpeedLimitList.validate(value['speedLimits'], errors, '{}/{}'.format(comp_path ,'speedLimits'))
        if 'roadLaneSet' in value:
            LaneList.validate(value['roadLaneSet'], errors, '{}/{}'.format(comp_path ,'roadLaneSet'))
        elif 'roadLaneSet' not in value:
            report_missing_field(type(self).__name__, 'roadLaneSet', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class RoadSignID:
    def __init__(self):
        self._comp_types = {"position" : Position3D, "viewAngle" : HeadingSlice, "mutcdCode" : MUTCDCode, "crc" : FurtherInfoID}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RoadSignID"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RoadSignID()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('mutcdCode' in value and 'mutcdCode' not in self._def_vals):
            preamble_bits[0] = True
        elif ('mutcdCode' in value and 'mutcdCode' in self._def_vals):
            if not value_tracker.are_def_eq(value['mutcdCode'], self._def_vals['mutcdCode'], self._comp_types['mutcdCode']):
                preamble_bits[0] = True
        if ('crc' in value and 'crc' not in self._def_vals):
            preamble_bits[1] = True
        elif ('crc' in value and 'crc' in self._def_vals):
            if not value_tracker.are_def_eq(value['crc'], self._def_vals['crc'], self._comp_types['crc']):
                preamble_bits[1] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'position' in value:
            Position3D.encode(encoding_rule, value['position'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'viewAngle' in value:
            HeadingSlice.encode(encoding_rule, value['viewAngle'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            MUTCDCode.encode(encoding_rule, value['mutcdCode'], value_tracker, stream)
        if preamble_bits[1]:
            FurtherInfoID.encode(encoding_rule, value['crc'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RoadSignID()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['position'] = Position3D.decode(encoding_rule, stream, value_tracker)
        value['viewAngle'] = HeadingSlice.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['mutcdCode'] = MUTCDCode.decode(encoding_rule, stream, value_tracker)
        elif 'mutcdCode' in self._def_vals:
            value['mutcdCode'] = self._def_vals['mutcdCode']
        if preamble_bits[1]:
            value['crc'] = FurtherInfoID.decode(encoding_rule, stream, value_tracker)
        elif 'crc' in self._def_vals:
            value['crc'] = self._def_vals['crc']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RoadSignID()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'position' in value:
            Position3D.validate(value['position'], errors, '{}/{}'.format(comp_path ,'position'))
        elif 'position' not in value:
            report_missing_field(type(self).__name__, 'position', errors, comp_path)
        if 'viewAngle' in value:
            HeadingSlice.validate(value['viewAngle'], errors, '{}/{}'.format(comp_path ,'viewAngle'))
        elif 'viewAngle' not in value:
            report_missing_field(type(self).__name__, 'viewAngle', errors, comp_path)
        if 'mutcdCode' in value:
            MUTCDCode.validate(value['mutcdCode'], errors, '{}/{}'.format(comp_path ,'mutcdCode'))
        if 'crc' in value:
            FurtherInfoID.validate(value['crc'], errors, '{}/{}'.format(comp_path ,'crc'))

        return errors

class RTCMheader:
    def __init__(self):
        self._comp_types = {"status" : GNSSstatus, "offsetSet" : AntennaOffsetSet}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RTCMheader"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RTCMheader()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'status' in value:
            GNSSstatus.encode(encoding_rule, value['status'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'offsetSet' in value:
            AntennaOffsetSet.encode(encoding_rule, value['offsetSet'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RTCMheader()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['status'] = GNSSstatus.decode(encoding_rule, stream, value_tracker)
        value['offsetSet'] = AntennaOffsetSet.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RTCMheader()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'status' in value:
            GNSSstatus.validate(value['status'], errors, '{}/{}'.format(comp_path ,'status'))
        elif 'status' not in value:
            report_missing_field(type(self).__name__, 'status', errors, comp_path)
        if 'offsetSet' in value:
            AntennaOffsetSet.validate(value['offsetSet'], errors, '{}/{}'.format(comp_path ,'offsetSet'))
        elif 'offsetSet' not in value:
            report_missing_field(type(self).__name__, 'offsetSet', errors, comp_path)

        return errors

class RTCMmessageList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,5)]}}]
        self._unique_indetifier = "DSRC.RTCMmessageList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                NMEA_Payload.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                NMEA_Payload.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(NMEA_Payload.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = RTCMmessageList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 5
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(NMEA_Payload.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = RTCMmessageList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 5
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = RTCMmessageList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                NMEA_Payload.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class RTCMPackage:
    def __init__(self):
        self._comp_types = {"rtcmHeader" : RTCMheader, "msgs" : RTCMmessageList}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.RTCMPackage"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RTCMPackage()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('rtcmHeader' in value and 'rtcmHeader' not in self._def_vals):
            preamble_bits[0] = True
        elif ('rtcmHeader' in value and 'rtcmHeader' in self._def_vals):
            if not value_tracker.are_def_eq(value['rtcmHeader'], self._def_vals['rtcmHeader'], self._comp_types['rtcmHeader']):
                preamble_bits[0] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            RTCMheader.encode(encoding_rule, value['rtcmHeader'], value_tracker, stream)
        if 'msgs' in value:
            RTCMmessageList.encode(encoding_rule, value['msgs'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RTCMPackage()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['rtcmHeader'] = RTCMheader.decode(encoding_rule, stream, value_tracker)
        elif 'rtcmHeader' in self._def_vals:
            value['rtcmHeader'] = self._def_vals['rtcmHeader']
        value['msgs'] = RTCMmessageList.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RTCMPackage()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'rtcmHeader' in value:
            RTCMheader.validate(value['rtcmHeader'], errors, '{}/{}'.format(comp_path ,'rtcmHeader'))
        if 'msgs' in value:
            RTCMmessageList.validate(value['msgs'], errors, '{}/{}'.format(comp_path ,'msgs'))
        elif 'msgs' not in value:
            report_missing_field(type(self).__name__, 'msgs', errors, comp_path)

        return errors

class Sample:
    def __init__(self):
        self._comp_types = {"sampleStart" : AmbientAirPressure, "sampleEnd" : AmbientAirPressure}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Sample"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Sample()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'sampleStart' in value:
            AmbientAirPressure.encode(encoding_rule, value['sampleStart'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'sampleEnd' in value:
            AmbientAirPressure.encode(encoding_rule, value['sampleEnd'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Sample()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['sampleStart'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['sampleEnd'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Sample()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'sampleStart' in value:
            AmbientAirPressure.validate(value['sampleStart'], errors, '{}/{}'.format(comp_path ,'sampleStart'))
        elif 'sampleStart' not in value:
            report_missing_field(type(self).__name__, 'sampleStart', errors, comp_path)
        if 'sampleEnd' in value:
            AmbientAirPressure.validate(value['sampleEnd'], errors, '{}/{}'.format(comp_path ,'sampleEnd'))
        elif 'sampleEnd' not in value:
            report_missing_field(type(self).__name__, 'sampleEnd', errors, comp_path)

        return errors

class SegmentAttributeLLList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,8)]}}]
        self._unique_indetifier = "DSRC.SegmentAttributeLLList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                SegmentAttributeLL.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                SegmentAttributeLL.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(SegmentAttributeLL.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = SegmentAttributeLLList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(SegmentAttributeLL.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = SegmentAttributeLLList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = SegmentAttributeLLList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                SegmentAttributeLL.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

SegmentAttributeXYList = SegmentAttributeLLList

class ShapePointSet:
    def __init__(self):
        self._comp_types = {"anchor" : Position3D, "laneWidth" : DSRCmsgID, "directionality" : DirectionOfUse, "nodeList" : NodeListXY}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.ShapePointSet"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ShapePointSet()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('anchor' in value and 'anchor' not in self._def_vals):
            preamble_bits[0] = True
        elif ('anchor' in value and 'anchor' in self._def_vals):
            if not value_tracker.are_def_eq(value['anchor'], self._def_vals['anchor'], self._comp_types['anchor']):
                preamble_bits[0] = True
        if ('laneWidth' in value and 'laneWidth' not in self._def_vals):
            preamble_bits[1] = True
        elif ('laneWidth' in value and 'laneWidth' in self._def_vals):
            if not value_tracker.are_def_eq(value['laneWidth'], self._def_vals['laneWidth'], self._comp_types['laneWidth']):
                preamble_bits[1] = True
        if ('directionality' in value and 'directionality' not in self._def_vals):
            preamble_bits[2] = True
        elif ('directionality' in value and 'directionality' in self._def_vals):
            if not value_tracker.are_def_eq(value['directionality'], self._def_vals['directionality'], self._comp_types['directionality']):
                preamble_bits[2] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            Position3D.encode(encoding_rule, value['anchor'], value_tracker, stream)
        if preamble_bits[2]:
            DSRCmsgID.encode(encoding_rule, value['laneWidth'], value_tracker, stream)
        if preamble_bits[3]:
            DirectionOfUse.encode(encoding_rule, value['directionality'], value_tracker, stream)
        if 'nodeList' in value:
            NodeListXY.encode(encoding_rule, value['nodeList'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ShapePointSet()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['anchor'] = Position3D.decode(encoding_rule, stream, value_tracker)
        elif 'anchor' in self._def_vals:
            value['anchor'] = self._def_vals['anchor']
        if preamble_bits[2]:
            value['laneWidth'] = DSRCmsgID.decode(encoding_rule, stream, value_tracker)
        elif 'laneWidth' in self._def_vals:
            value['laneWidth'] = self._def_vals['laneWidth']
        if preamble_bits[3]:
            value['directionality'] = DirectionOfUse.decode(encoding_rule, stream, value_tracker)
        elif 'directionality' in self._def_vals:
            value['directionality'] = self._def_vals['directionality']
        value['nodeList'] = NodeListXY.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ShapePointSet()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'anchor' in value:
            Position3D.validate(value['anchor'], errors, '{}/{}'.format(comp_path ,'anchor'))
        if 'laneWidth' in value:
            DSRCmsgID.validate(value['laneWidth'], errors, '{}/{}'.format(comp_path ,'laneWidth'))
        if 'directionality' in value:
            DirectionOfUse.validate(value['directionality'], errors, '{}/{}'.format(comp_path ,'directionality'))
        if 'nodeList' in value:
            NodeListXY.validate(value['nodeList'], errors, '{}/{}'.format(comp_path ,'nodeList'))
        elif 'nodeList' not in value:
            report_missing_field(type(self).__name__, 'nodeList', errors, comp_path)

        return errors

class SignalRequesterInfo:
    def __init__(self):
        self._comp_types = {"id" : VehicleID, "request" : AmbientAirPressure, "sequenceNumber" : BumperHeight, "role" : BasicVehicleRole, "typeData" : RequestorType}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SignalRequesterInfo"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SignalRequesterInfo()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('role' in value and 'role' not in self._def_vals):
            preamble_bits[0] = True
        elif ('role' in value and 'role' in self._def_vals):
            if not value_tracker.are_def_eq(value['role'], self._def_vals['role'], self._comp_types['role']):
                preamble_bits[0] = True
        if ('typeData' in value and 'typeData' not in self._def_vals):
            preamble_bits[1] = True
        elif ('typeData' in value and 'typeData' in self._def_vals):
            if not value_tracker.are_def_eq(value['typeData'], self._def_vals['typeData'], self._comp_types['typeData']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'id' in value:
            VehicleID.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'request' in value:
            AmbientAirPressure.encode(encoding_rule, value['request'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'sequenceNumber' in value:
            BumperHeight.encode(encoding_rule, value['sequenceNumber'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            BasicVehicleRole.encode(encoding_rule, value['role'], value_tracker, stream)
        if preamble_bits[2]:
            RequestorType.encode(encoding_rule, value['typeData'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SignalRequesterInfo()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['id'] = VehicleID.decode(encoding_rule, stream, value_tracker)
        value['request'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['sequenceNumber'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['role'] = BasicVehicleRole.decode(encoding_rule, stream, value_tracker)
        elif 'role' in self._def_vals:
            value['role'] = self._def_vals['role']
        if preamble_bits[2]:
            value['typeData'] = RequestorType.decode(encoding_rule, stream, value_tracker)
        elif 'typeData' in self._def_vals:
            value['typeData'] = self._def_vals['typeData']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SignalRequesterInfo()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'id' in value:
            VehicleID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'request' in value:
            AmbientAirPressure.validate(value['request'], errors, '{}/{}'.format(comp_path ,'request'))
        elif 'request' not in value:
            report_missing_field(type(self).__name__, 'request', errors, comp_path)
        if 'sequenceNumber' in value:
            BumperHeight.validate(value['sequenceNumber'], errors, '{}/{}'.format(comp_path ,'sequenceNumber'))
        elif 'sequenceNumber' not in value:
            report_missing_field(type(self).__name__, 'sequenceNumber', errors, comp_path)
        if 'role' in value:
            BasicVehicleRole.validate(value['role'], errors, '{}/{}'.format(comp_path ,'role'))
        if 'typeData' in value:
            RequestorType.validate(value['typeData'], errors, '{}/{}'.format(comp_path ,'typeData'))

        return errors

class SignalRequestList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,32)]}}]
        self._unique_indetifier = "DSRC.SignalRequestList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                SignalRequestPackage.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                SignalRequestPackage.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(SignalRequestPackage.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = SignalRequestList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(SignalRequestPackage.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = SignalRequestList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = SignalRequestList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                SignalRequestPackage.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class SignalRequestPackage:
    def __init__(self):
        self._comp_types = {"request" : SignalRequest, "minute" : MinuteOfTheYear, "second" : DSecond, "duration" : DSecond, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SignalRequestPackage"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SignalRequestPackage()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('minute' in value and 'minute' not in self._def_vals):
            preamble_bits[0] = True
        elif ('minute' in value and 'minute' in self._def_vals):
            if not value_tracker.are_def_eq(value['minute'], self._def_vals['minute'], self._comp_types['minute']):
                preamble_bits[0] = True
        if ('second' in value and 'second' not in self._def_vals):
            preamble_bits[1] = True
        elif ('second' in value and 'second' in self._def_vals):
            if not value_tracker.are_def_eq(value['second'], self._def_vals['second'], self._comp_types['second']):
                preamble_bits[1] = True
        if ('duration' in value and 'duration' not in self._def_vals):
            preamble_bits[2] = True
        elif ('duration' in value and 'duration' in self._def_vals):
            if not value_tracker.are_def_eq(value['duration'], self._def_vals['duration'], self._comp_types['duration']):
                preamble_bits[2] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[3] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'request' in value:
            SignalRequest.encode(encoding_rule, value['request'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            MinuteOfTheYear.encode(encoding_rule, value['minute'], value_tracker, stream)
        if preamble_bits[2]:
            DSecond.encode(encoding_rule, value['second'], value_tracker, stream)
        if preamble_bits[3]:
            DSecond.encode(encoding_rule, value['duration'], value_tracker, stream)
        if preamble_bits[4]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SignalRequestPackage()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['request'] = SignalRequest.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['minute'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'minute' in self._def_vals:
            value['minute'] = self._def_vals['minute']
        if preamble_bits[2]:
            value['second'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'second' in self._def_vals:
            value['second'] = self._def_vals['second']
        if preamble_bits[3]:
            value['duration'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'duration' in self._def_vals:
            value['duration'] = self._def_vals['duration']
        if preamble_bits[4]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SignalRequestPackage()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'request' in value:
            SignalRequest.validate(value['request'], errors, '{}/{}'.format(comp_path ,'request'))
        elif 'request' not in value:
            report_missing_field(type(self).__name__, 'request', errors, comp_path)
        if 'minute' in value:
            MinuteOfTheYear.validate(value['minute'], errors, '{}/{}'.format(comp_path ,'minute'))
        if 'second' in value:
            DSecond.validate(value['second'], errors, '{}/{}'.format(comp_path ,'second'))
        if 'duration' in value:
            DSecond.validate(value['duration'], errors, '{}/{}'.format(comp_path ,'duration'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class AdvisorySpeed__7:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,4)]}}]
        self._unique_indetifier = "DSRC.AdvisorySpeed.regional"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RegionalExtension_1.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RegionalExtension_1.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RegionalExtension_1.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = AdvisorySpeed__7()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RegionalExtension_1.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = AdvisorySpeed__7()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = AdvisorySpeed__7()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RegionalExtension_1.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

BasicSafetyMessage__6 = AdvisorySpeed__7
CommonSafetyRequest__6 = AdvisorySpeed__7
ComputedLane__12 = AdvisorySpeed__7
EmergencyVehicleAlert__12 = AdvisorySpeed__7
EventDescription__9 = AdvisorySpeed__7
GenericLane__11 = AdvisorySpeed__7
GeographicalPath__13 = AdvisorySpeed__7
GeometricProjection__6 = AdvisorySpeed__7
IntersectionCollision__11 = AdvisorySpeed__7
IntersectionGeometry__10 = AdvisorySpeed__7
MovementState__6 = AdvisorySpeed__7
NMEAcorrections__7 = AdvisorySpeed__7
NodeAttributeSetLL__8 = AdvisorySpeed__7
NodeAttributeSetXY__8 = AdvisorySpeed__7
PersonalSafetyMessage__27 = AdvisorySpeed__7
ProbeDataManagement__13 = AdvisorySpeed__7
ProbeVehicleData__10 = AdvisorySpeed__7
RequestorDescription__10 = AdvisorySpeed__7
RoadSegment__9 = AdvisorySpeed__7
RoadSideAlert__13 = AdvisorySpeed__7
RTCMcorrections__8 = AdvisorySpeed__7
SignalRequest__7 = AdvisorySpeed__7
SignalRequestMessage__7 = AdvisorySpeed__7
SignalRequestPackage__6 = AdvisorySpeed__7
SignalStatus__5 = AdvisorySpeed__7
SignalStatusMessage__6 = AdvisorySpeed__7
SignalStatusPackage__9 = AdvisorySpeed__7
SPAT__5 = AdvisorySpeed__7
SupplementalVehicleExtensions__11 = AdvisorySpeed__7
TravelerInformation__7 = AdvisorySpeed__7
VehicleClassification__10 = AdvisorySpeed__7

class SignalRequest:
    def __init__(self):
        self._comp_types = {"id" : IntersectionReferenceID, "requestID" : AmbientAirPressure, "requestType" : PriorityRequestType, "inBoundLane" : IntersectionAccessPoint, "outBoundLane" : IntersectionAccessPoint, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SignalRequest"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SignalRequest()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('outBoundLane' in value and 'outBoundLane' not in self._def_vals):
            preamble_bits[0] = True
        elif ('outBoundLane' in value and 'outBoundLane' in self._def_vals):
            if not value_tracker.are_def_eq(value['outBoundLane'], self._def_vals['outBoundLane'], self._comp_types['outBoundLane']):
                preamble_bits[0] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[1] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'id' in value:
            IntersectionReferenceID.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'requestID' in value:
            AmbientAirPressure.encode(encoding_rule, value['requestID'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'requestType' in value:
            PriorityRequestType.encode(encoding_rule, value['requestType'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'inBoundLane' in value:
            IntersectionAccessPoint.encode(encoding_rule, value['inBoundLane'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            IntersectionAccessPoint.encode(encoding_rule, value['outBoundLane'], value_tracker, stream)
        if preamble_bits[2]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SignalRequest()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['id'] = IntersectionReferenceID.decode(encoding_rule, stream, value_tracker)
        value['requestID'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['requestType'] = PriorityRequestType.decode(encoding_rule, stream, value_tracker)
        value['inBoundLane'] = IntersectionAccessPoint.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['outBoundLane'] = IntersectionAccessPoint.decode(encoding_rule, stream, value_tracker)
        elif 'outBoundLane' in self._def_vals:
            value['outBoundLane'] = self._def_vals['outBoundLane']
        if preamble_bits[2]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SignalRequest()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'id' in value:
            IntersectionReferenceID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'requestID' in value:
            AmbientAirPressure.validate(value['requestID'], errors, '{}/{}'.format(comp_path ,'requestID'))
        elif 'requestID' not in value:
            report_missing_field(type(self).__name__, 'requestID', errors, comp_path)
        if 'requestType' in value:
            PriorityRequestType.validate(value['requestType'], errors, '{}/{}'.format(comp_path ,'requestType'))
        elif 'requestType' not in value:
            report_missing_field(type(self).__name__, 'requestType', errors, comp_path)
        if 'inBoundLane' in value:
            IntersectionAccessPoint.validate(value['inBoundLane'], errors, '{}/{}'.format(comp_path ,'inBoundLane'))
        elif 'inBoundLane' not in value:
            report_missing_field(type(self).__name__, 'inBoundLane', errors, comp_path)
        if 'outBoundLane' in value:
            IntersectionAccessPoint.validate(value['outBoundLane'], errors, '{}/{}'.format(comp_path ,'outBoundLane'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class SignalStatusList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,32)]}}]
        self._unique_indetifier = "DSRC.SignalStatusList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                SignalStatus.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                SignalStatus.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(SignalStatus.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = SignalStatusList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(SignalStatus.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = SignalStatusList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = SignalStatusList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                SignalStatus.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class SignalStatusPackageList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,32)]}}]
        self._unique_indetifier = "DSRC.SignalStatusPackageList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                SignalStatusPackage.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                SignalStatusPackage.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(SignalStatusPackage.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = SignalStatusPackageList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(SignalStatusPackage.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = SignalStatusPackageList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = SignalStatusPackageList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                SignalStatusPackage.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class SignalStatusPackage:
    def __init__(self):
        self._comp_types = {"requester" : SignalRequesterInfo, "inboundOn" : IntersectionAccessPoint, "outboundOn" : IntersectionAccessPoint, "minute" : MinuteOfTheYear, "second" : DSecond, "duration" : DSecond, "status" : PrioritizationResponseStatus, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SignalStatusPackage"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SignalStatusPackage()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 6

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('requester' in value and 'requester' not in self._def_vals):
            preamble_bits[0] = True
        elif ('requester' in value and 'requester' in self._def_vals):
            if not value_tracker.are_def_eq(value['requester'], self._def_vals['requester'], self._comp_types['requester']):
                preamble_bits[0] = True
        if ('outboundOn' in value and 'outboundOn' not in self._def_vals):
            preamble_bits[1] = True
        elif ('outboundOn' in value and 'outboundOn' in self._def_vals):
            if not value_tracker.are_def_eq(value['outboundOn'], self._def_vals['outboundOn'], self._comp_types['outboundOn']):
                preamble_bits[1] = True
        if ('minute' in value and 'minute' not in self._def_vals):
            preamble_bits[2] = True
        elif ('minute' in value and 'minute' in self._def_vals):
            if not value_tracker.are_def_eq(value['minute'], self._def_vals['minute'], self._comp_types['minute']):
                preamble_bits[2] = True
        if ('second' in value and 'second' not in self._def_vals):
            preamble_bits[3] = True
        elif ('second' in value and 'second' in self._def_vals):
            if not value_tracker.are_def_eq(value['second'], self._def_vals['second'], self._comp_types['second']):
                preamble_bits[3] = True
        if ('duration' in value and 'duration' not in self._def_vals):
            preamble_bits[4] = True
        elif ('duration' in value and 'duration' in self._def_vals):
            if not value_tracker.are_def_eq(value['duration'], self._def_vals['duration'], self._comp_types['duration']):
                preamble_bits[4] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[5] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[5] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            SignalRequesterInfo.encode(encoding_rule, value['requester'], value_tracker, stream)
        if 'inboundOn' in value:
            IntersectionAccessPoint.encode(encoding_rule, value['inboundOn'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            IntersectionAccessPoint.encode(encoding_rule, value['outboundOn'], value_tracker, stream)
        if preamble_bits[3]:
            MinuteOfTheYear.encode(encoding_rule, value['minute'], value_tracker, stream)
        if preamble_bits[4]:
            DSecond.encode(encoding_rule, value['second'], value_tracker, stream)
        if preamble_bits[5]:
            DSecond.encode(encoding_rule, value['duration'], value_tracker, stream)
        if 'status' in value:
            PrioritizationResponseStatus.encode(encoding_rule, value['status'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[6]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SignalStatusPackage()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 6

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['requester'] = SignalRequesterInfo.decode(encoding_rule, stream, value_tracker)
        elif 'requester' in self._def_vals:
            value['requester'] = self._def_vals['requester']
        value['inboundOn'] = IntersectionAccessPoint.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['outboundOn'] = IntersectionAccessPoint.decode(encoding_rule, stream, value_tracker)
        elif 'outboundOn' in self._def_vals:
            value['outboundOn'] = self._def_vals['outboundOn']
        if preamble_bits[3]:
            value['minute'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'minute' in self._def_vals:
            value['minute'] = self._def_vals['minute']
        if preamble_bits[4]:
            value['second'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'second' in self._def_vals:
            value['second'] = self._def_vals['second']
        if preamble_bits[5]:
            value['duration'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'duration' in self._def_vals:
            value['duration'] = self._def_vals['duration']
        value['status'] = PrioritizationResponseStatus.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[6]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SignalStatusPackage()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'requester' in value:
            SignalRequesterInfo.validate(value['requester'], errors, '{}/{}'.format(comp_path ,'requester'))
        if 'inboundOn' in value:
            IntersectionAccessPoint.validate(value['inboundOn'], errors, '{}/{}'.format(comp_path ,'inboundOn'))
        elif 'inboundOn' not in value:
            report_missing_field(type(self).__name__, 'inboundOn', errors, comp_path)
        if 'outboundOn' in value:
            IntersectionAccessPoint.validate(value['outboundOn'], errors, '{}/{}'.format(comp_path ,'outboundOn'))
        if 'minute' in value:
            MinuteOfTheYear.validate(value['minute'], errors, '{}/{}'.format(comp_path ,'minute'))
        if 'second' in value:
            DSecond.validate(value['second'], errors, '{}/{}'.format(comp_path ,'second'))
        if 'duration' in value:
            DSecond.validate(value['duration'], errors, '{}/{}'.format(comp_path ,'duration'))
        if 'status' in value:
            PrioritizationResponseStatus.validate(value['status'], errors, '{}/{}'.format(comp_path ,'status'))
        elif 'status' not in value:
            report_missing_field(type(self).__name__, 'status', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class SignalStatus:
    def __init__(self):
        self._comp_types = {"sequenceNumber" : BumperHeight, "id" : IntersectionReferenceID, "sigStatus" : SignalStatusPackageList, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SignalStatus"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SignalStatus()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[0] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[0] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'sequenceNumber' in value:
            BumperHeight.encode(encoding_rule, value['sequenceNumber'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'id' in value:
            IntersectionReferenceID.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'sigStatus' in value:
            SignalStatusPackageList.encode(encoding_rule, value['sigStatus'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SignalStatus()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['sequenceNumber'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        value['id'] = IntersectionReferenceID.decode(encoding_rule, stream, value_tracker)
        value['sigStatus'] = SignalStatusPackageList.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SignalStatus()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'sequenceNumber' in value:
            BumperHeight.validate(value['sequenceNumber'], errors, '{}/{}'.format(comp_path ,'sequenceNumber'))
        elif 'sequenceNumber' not in value:
            report_missing_field(type(self).__name__, 'sequenceNumber', errors, comp_path)
        if 'id' in value:
            IntersectionReferenceID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'sigStatus' in value:
            SignalStatusPackageList.validate(value['sigStatus'], errors, '{}/{}'.format(comp_path ,'sigStatus'))
        elif 'sigStatus' not in value:
            report_missing_field(type(self).__name__, 'sigStatus', errors, comp_path)
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class SnapshotDistance:
    def __init__(self):
        self._comp_types = {"distance1" : GrossDistance, "speed1" : DDay, "distance2" : GrossDistance, "speed2" : DDay}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SnapshotDistance"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SnapshotDistance()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'distance1' in value:
            GrossDistance.encode(encoding_rule, value['distance1'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'speed1' in value:
            DDay.encode(encoding_rule, value['speed1'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'distance2' in value:
            GrossDistance.encode(encoding_rule, value['distance2'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'speed2' in value:
            DDay.encode(encoding_rule, value['speed2'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SnapshotDistance()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['distance1'] = GrossDistance.decode(encoding_rule, stream, value_tracker)
        value['speed1'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['distance2'] = GrossDistance.decode(encoding_rule, stream, value_tracker)
        value['speed2'] = DDay.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SnapshotDistance()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'distance1' in value:
            GrossDistance.validate(value['distance1'], errors, '{}/{}'.format(comp_path ,'distance1'))
        elif 'distance1' not in value:
            report_missing_field(type(self).__name__, 'distance1', errors, comp_path)
        if 'speed1' in value:
            DDay.validate(value['speed1'], errors, '{}/{}'.format(comp_path ,'speed1'))
        elif 'speed1' not in value:
            report_missing_field(type(self).__name__, 'speed1', errors, comp_path)
        if 'distance2' in value:
            GrossDistance.validate(value['distance2'], errors, '{}/{}'.format(comp_path ,'distance2'))
        elif 'distance2' not in value:
            report_missing_field(type(self).__name__, 'distance2', errors, comp_path)
        if 'speed2' in value:
            DDay.validate(value['speed2'], errors, '{}/{}'.format(comp_path ,'speed2'))
        elif 'speed2' not in value:
            report_missing_field(type(self).__name__, 'speed2', errors, comp_path)

        return errors

class Snapshot:
    def __init__(self):
        self._comp_types = {"thePosition" : FullPositionVector, "safetyExt" : VehicleSafetyExtensions, "dataSet" : VehicleStatus}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.Snapshot"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Snapshot()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('safetyExt' in value and 'safetyExt' not in self._def_vals):
            preamble_bits[0] = True
        elif ('safetyExt' in value and 'safetyExt' in self._def_vals):
            if not value_tracker.are_def_eq(value['safetyExt'], self._def_vals['safetyExt'], self._comp_types['safetyExt']):
                preamble_bits[0] = True
        if ('dataSet' in value and 'dataSet' not in self._def_vals):
            preamble_bits[1] = True
        elif ('dataSet' in value and 'dataSet' in self._def_vals):
            if not value_tracker.are_def_eq(value['dataSet'], self._def_vals['dataSet'], self._comp_types['dataSet']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'thePosition' in value:
            FullPositionVector.encode(encoding_rule, value['thePosition'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            VehicleSafetyExtensions.encode(encoding_rule, value['safetyExt'], value_tracker, stream)
        if preamble_bits[2]:
            VehicleStatus.encode(encoding_rule, value['dataSet'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Snapshot()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['thePosition'] = FullPositionVector.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['safetyExt'] = VehicleSafetyExtensions.decode(encoding_rule, stream, value_tracker)
        elif 'safetyExt' in self._def_vals:
            value['safetyExt'] = self._def_vals['safetyExt']
        if preamble_bits[2]:
            value['dataSet'] = VehicleStatus.decode(encoding_rule, stream, value_tracker)
        elif 'dataSet' in self._def_vals:
            value['dataSet'] = self._def_vals['dataSet']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Snapshot()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'thePosition' in value:
            FullPositionVector.validate(value['thePosition'], errors, '{}/{}'.format(comp_path ,'thePosition'))
        elif 'thePosition' not in value:
            report_missing_field(type(self).__name__, 'thePosition', errors, comp_path)
        if 'safetyExt' in value:
            VehicleSafetyExtensions.validate(value['safetyExt'], errors, '{}/{}'.format(comp_path ,'safetyExt'))
        if 'dataSet' in value:
            VehicleStatus.validate(value['dataSet'], errors, '{}/{}'.format(comp_path ,'dataSet'))

        return errors

class SnapshotTime:
    def __init__(self):
        self._comp_types = {"speed1" : DDay, "time1" : SecondOfTime, "speed2" : DDay, "time2" : SecondOfTime}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SnapshotTime"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SnapshotTime()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'speed1' in value:
            DDay.encode(encoding_rule, value['speed1'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'time1' in value:
            SecondOfTime.encode(encoding_rule, value['time1'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'speed2' in value:
            DDay.encode(encoding_rule, value['speed2'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'time2' in value:
            SecondOfTime.encode(encoding_rule, value['time2'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SnapshotTime()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['speed1'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['time1'] = SecondOfTime.decode(encoding_rule, stream, value_tracker)
        value['speed2'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['time2'] = SecondOfTime.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SnapshotTime()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'speed1' in value:
            DDay.validate(value['speed1'], errors, '{}/{}'.format(comp_path ,'speed1'))
        elif 'speed1' not in value:
            report_missing_field(type(self).__name__, 'speed1', errors, comp_path)
        if 'time1' in value:
            SecondOfTime.validate(value['time1'], errors, '{}/{}'.format(comp_path ,'time1'))
        elif 'time1' not in value:
            report_missing_field(type(self).__name__, 'time1', errors, comp_path)
        if 'speed2' in value:
            DDay.validate(value['speed2'], errors, '{}/{}'.format(comp_path ,'speed2'))
        elif 'speed2' not in value:
            report_missing_field(type(self).__name__, 'speed2', errors, comp_path)
        if 'time2' in value:
            SecondOfTime.validate(value['time2'], errors, '{}/{}'.format(comp_path ,'time2'))
        elif 'time2' not in value:
            report_missing_field(type(self).__name__, 'time2', errors, comp_path)

        return errors

class SpecialVehicleExtensions:
    def __init__(self):
        self._comp_types = {"vehicleAlerts" : EmergencyDetails, "description" : EventDescription, "trailers" : TrailerData}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SpecialVehicleExtensions"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SpecialVehicleExtensions()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('vehicleAlerts' in value and 'vehicleAlerts' not in self._def_vals):
            preamble_bits[0] = True
        elif ('vehicleAlerts' in value and 'vehicleAlerts' in self._def_vals):
            if not value_tracker.are_def_eq(value['vehicleAlerts'], self._def_vals['vehicleAlerts'], self._comp_types['vehicleAlerts']):
                preamble_bits[0] = True
        if ('description' in value and 'description' not in self._def_vals):
            preamble_bits[1] = True
        elif ('description' in value and 'description' in self._def_vals):
            if not value_tracker.are_def_eq(value['description'], self._def_vals['description'], self._comp_types['description']):
                preamble_bits[1] = True
        if ('trailers' in value and 'trailers' not in self._def_vals):
            preamble_bits[2] = True
        elif ('trailers' in value and 'trailers' in self._def_vals):
            if not value_tracker.are_def_eq(value['trailers'], self._def_vals['trailers'], self._comp_types['trailers']):
                preamble_bits[2] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            EmergencyDetails.encode(encoding_rule, value['vehicleAlerts'], value_tracker, stream)
        if preamble_bits[2]:
            EventDescription.encode(encoding_rule, value['description'], value_tracker, stream)
        if preamble_bits[3]:
            TrailerData.encode(encoding_rule, value['trailers'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SpecialVehicleExtensions()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['vehicleAlerts'] = EmergencyDetails.decode(encoding_rule, stream, value_tracker)
        elif 'vehicleAlerts' in self._def_vals:
            value['vehicleAlerts'] = self._def_vals['vehicleAlerts']
        if preamble_bits[2]:
            value['description'] = EventDescription.decode(encoding_rule, stream, value_tracker)
        elif 'description' in self._def_vals:
            value['description'] = self._def_vals['description']
        if preamble_bits[3]:
            value['trailers'] = TrailerData.decode(encoding_rule, stream, value_tracker)
        elif 'trailers' in self._def_vals:
            value['trailers'] = self._def_vals['trailers']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SpecialVehicleExtensions()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'vehicleAlerts' in value:
            EmergencyDetails.validate(value['vehicleAlerts'], errors, '{}/{}'.format(comp_path ,'vehicleAlerts'))
        if 'description' in value:
            EventDescription.validate(value['description'], errors, '{}/{}'.format(comp_path ,'description'))
        if 'trailers' in value:
            TrailerData.validate(value['trailers'], errors, '{}/{}'.format(comp_path ,'trailers'))

        return errors

class SpeedandHeadingandThrottleConfidence:
    def __init__(self):
        self._comp_types = {"heading" : HeadingConfidence, "speed" : SpeedConfidence, "throttle" : ThrottleConfidence}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SpeedandHeadingandThrottleConfidence"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SpeedandHeadingandThrottleConfidence()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'heading' in value:
            HeadingConfidence.encode(encoding_rule, value['heading'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'speed' in value:
            SpeedConfidence.encode(encoding_rule, value['speed'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'throttle' in value:
            ThrottleConfidence.encode(encoding_rule, value['throttle'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SpeedandHeadingandThrottleConfidence()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['heading'] = HeadingConfidence.decode(encoding_rule, stream, value_tracker)
        value['speed'] = SpeedConfidence.decode(encoding_rule, stream, value_tracker)
        value['throttle'] = ThrottleConfidence.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SpeedandHeadingandThrottleConfidence()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'heading' in value:
            HeadingConfidence.validate(value['heading'], errors, '{}/{}'.format(comp_path ,'heading'))
        elif 'heading' not in value:
            report_missing_field(type(self).__name__, 'heading', errors, comp_path)
        if 'speed' in value:
            SpeedConfidence.validate(value['speed'], errors, '{}/{}'.format(comp_path ,'speed'))
        elif 'speed' not in value:
            report_missing_field(type(self).__name__, 'speed', errors, comp_path)
        if 'throttle' in value:
            ThrottleConfidence.validate(value['throttle'], errors, '{}/{}'.format(comp_path ,'throttle'))
        elif 'throttle' not in value:
            report_missing_field(type(self).__name__, 'throttle', errors, comp_path)

        return errors

class SpeedLimitList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,9)]}}]
        self._unique_indetifier = "DSRC.SpeedLimitList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                RegulatorySpeedLimit.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                RegulatorySpeedLimit.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(RegulatorySpeedLimit.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = SpeedLimitList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 9
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(RegulatorySpeedLimit.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = SpeedLimitList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 9
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = SpeedLimitList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                RegulatorySpeedLimit.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class SpeedProfileMeasurementList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,20)]}}]
        self._unique_indetifier = "DSRC.SpeedProfileMeasurementList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                DDay.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                DDay.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(DDay.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = SpeedProfileMeasurementList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 20
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(DDay.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = SpeedProfileMeasurementList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 20
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = SpeedProfileMeasurementList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                DDay.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class SpeedProfile:
    def __init__(self):
        self._comp_types = {"speedReports" : SpeedProfileMeasurementList}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SpeedProfile"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SpeedProfile()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'speedReports' in value:
            SpeedProfileMeasurementList.encode(encoding_rule, value['speedReports'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SpeedProfile()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['speedReports'] = SpeedProfileMeasurementList.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SpeedProfile()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'speedReports' in value:
            SpeedProfileMeasurementList.validate(value['speedReports'], errors, '{}/{}'.format(comp_path ,'speedReports'))
        elif 'speedReports' not in value:
            report_missing_field(type(self).__name__, 'speedReports', errors, comp_path)

        return errors

class SupplementalVehicleExtensions:
    def __init__(self):
        self._comp_types = {"classification" : AmbientAirPressure, "classDetails" : VehicleClassification, "vehicleData" : VehicleData, "weatherReport" : WeatherReport, "weatherProbe" : WeatherProbe, "obstacle" : ObstacleDetection, "status" : DisabledVehicle, "speedProfile" : SpeedProfile, "theRTCM" : RTCMPackage, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SupplementalVehicleExtensions"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SupplementalVehicleExtensions()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 10

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('classification' in value and 'classification' not in self._def_vals):
            preamble_bits[0] = True
        elif ('classification' in value and 'classification' in self._def_vals):
            if not value_tracker.are_def_eq(value['classification'], self._def_vals['classification'], self._comp_types['classification']):
                preamble_bits[0] = True
        if ('classDetails' in value and 'classDetails' not in self._def_vals):
            preamble_bits[1] = True
        elif ('classDetails' in value and 'classDetails' in self._def_vals):
            if not value_tracker.are_def_eq(value['classDetails'], self._def_vals['classDetails'], self._comp_types['classDetails']):
                preamble_bits[1] = True
        if ('vehicleData' in value and 'vehicleData' not in self._def_vals):
            preamble_bits[2] = True
        elif ('vehicleData' in value and 'vehicleData' in self._def_vals):
            if not value_tracker.are_def_eq(value['vehicleData'], self._def_vals['vehicleData'], self._comp_types['vehicleData']):
                preamble_bits[2] = True
        if ('weatherReport' in value and 'weatherReport' not in self._def_vals):
            preamble_bits[3] = True
        elif ('weatherReport' in value and 'weatherReport' in self._def_vals):
            if not value_tracker.are_def_eq(value['weatherReport'], self._def_vals['weatherReport'], self._comp_types['weatherReport']):
                preamble_bits[3] = True
        if ('weatherProbe' in value and 'weatherProbe' not in self._def_vals):
            preamble_bits[4] = True
        elif ('weatherProbe' in value and 'weatherProbe' in self._def_vals):
            if not value_tracker.are_def_eq(value['weatherProbe'], self._def_vals['weatherProbe'], self._comp_types['weatherProbe']):
                preamble_bits[4] = True
        if ('obstacle' in value and 'obstacle' not in self._def_vals):
            preamble_bits[5] = True
        elif ('obstacle' in value and 'obstacle' in self._def_vals):
            if not value_tracker.are_def_eq(value['obstacle'], self._def_vals['obstacle'], self._comp_types['obstacle']):
                preamble_bits[5] = True
        if ('status' in value and 'status' not in self._def_vals):
            preamble_bits[6] = True
        elif ('status' in value and 'status' in self._def_vals):
            if not value_tracker.are_def_eq(value['status'], self._def_vals['status'], self._comp_types['status']):
                preamble_bits[6] = True
        if ('speedProfile' in value and 'speedProfile' not in self._def_vals):
            preamble_bits[7] = True
        elif ('speedProfile' in value and 'speedProfile' in self._def_vals):
            if not value_tracker.are_def_eq(value['speedProfile'], self._def_vals['speedProfile'], self._comp_types['speedProfile']):
                preamble_bits[7] = True
        if ('theRTCM' in value and 'theRTCM' not in self._def_vals):
            preamble_bits[8] = True
        elif ('theRTCM' in value and 'theRTCM' in self._def_vals):
            if not value_tracker.are_def_eq(value['theRTCM'], self._def_vals['theRTCM'], self._comp_types['theRTCM']):
                preamble_bits[8] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[9] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[9] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            AmbientAirPressure.encode(encoding_rule, value['classification'], value_tracker, stream)
        if preamble_bits[2]:
            VehicleClassification.encode(encoding_rule, value['classDetails'], value_tracker, stream)
        if preamble_bits[3]:
            VehicleData.encode(encoding_rule, value['vehicleData'], value_tracker, stream)
        if preamble_bits[4]:
            WeatherReport.encode(encoding_rule, value['weatherReport'], value_tracker, stream)
        if preamble_bits[5]:
            WeatherProbe.encode(encoding_rule, value['weatherProbe'], value_tracker, stream)
        if preamble_bits[6]:
            ObstacleDetection.encode(encoding_rule, value['obstacle'], value_tracker, stream)
        if preamble_bits[7]:
            DisabledVehicle.encode(encoding_rule, value['status'], value_tracker, stream)
        if preamble_bits[8]:
            SpeedProfile.encode(encoding_rule, value['speedProfile'], value_tracker, stream)
        if preamble_bits[9]:
            RTCMPackage.encode(encoding_rule, value['theRTCM'], value_tracker, stream)
        if preamble_bits[10]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SupplementalVehicleExtensions()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 10

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['classification'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'classification' in self._def_vals:
            value['classification'] = self._def_vals['classification']
        if preamble_bits[2]:
            value['classDetails'] = VehicleClassification.decode(encoding_rule, stream, value_tracker)
        elif 'classDetails' in self._def_vals:
            value['classDetails'] = self._def_vals['classDetails']
        if preamble_bits[3]:
            value['vehicleData'] = VehicleData.decode(encoding_rule, stream, value_tracker)
        elif 'vehicleData' in self._def_vals:
            value['vehicleData'] = self._def_vals['vehicleData']
        if preamble_bits[4]:
            value['weatherReport'] = WeatherReport.decode(encoding_rule, stream, value_tracker)
        elif 'weatherReport' in self._def_vals:
            value['weatherReport'] = self._def_vals['weatherReport']
        if preamble_bits[5]:
            value['weatherProbe'] = WeatherProbe.decode(encoding_rule, stream, value_tracker)
        elif 'weatherProbe' in self._def_vals:
            value['weatherProbe'] = self._def_vals['weatherProbe']
        if preamble_bits[6]:
            value['obstacle'] = ObstacleDetection.decode(encoding_rule, stream, value_tracker)
        elif 'obstacle' in self._def_vals:
            value['obstacle'] = self._def_vals['obstacle']
        if preamble_bits[7]:
            value['status'] = DisabledVehicle.decode(encoding_rule, stream, value_tracker)
        elif 'status' in self._def_vals:
            value['status'] = self._def_vals['status']
        if preamble_bits[8]:
            value['speedProfile'] = SpeedProfile.decode(encoding_rule, stream, value_tracker)
        elif 'speedProfile' in self._def_vals:
            value['speedProfile'] = self._def_vals['speedProfile']
        if preamble_bits[9]:
            value['theRTCM'] = RTCMPackage.decode(encoding_rule, stream, value_tracker)
        elif 'theRTCM' in self._def_vals:
            value['theRTCM'] = self._def_vals['theRTCM']
        if preamble_bits[10]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SupplementalVehicleExtensions()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'classification' in value:
            AmbientAirPressure.validate(value['classification'], errors, '{}/{}'.format(comp_path ,'classification'))
        if 'classDetails' in value:
            VehicleClassification.validate(value['classDetails'], errors, '{}/{}'.format(comp_path ,'classDetails'))
        if 'vehicleData' in value:
            VehicleData.validate(value['vehicleData'], errors, '{}/{}'.format(comp_path ,'vehicleData'))
        if 'weatherReport' in value:
            WeatherReport.validate(value['weatherReport'], errors, '{}/{}'.format(comp_path ,'weatherReport'))
        if 'weatherProbe' in value:
            WeatherProbe.validate(value['weatherProbe'], errors, '{}/{}'.format(comp_path ,'weatherProbe'))
        if 'obstacle' in value:
            ObstacleDetection.validate(value['obstacle'], errors, '{}/{}'.format(comp_path ,'obstacle'))
        if 'status' in value:
            DisabledVehicle.validate(value['status'], errors, '{}/{}'.format(comp_path ,'status'))
        if 'speedProfile' in value:
            SpeedProfile.validate(value['speedProfile'], errors, '{}/{}'.format(comp_path ,'speedProfile'))
        if 'theRTCM' in value:
            RTCMPackage.validate(value['theRTCM'], errors, '{}/{}'.format(comp_path ,'theRTCM'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class TimeChangeDetails:
    def __init__(self):
        self._comp_types = {"startTime" : TimeMark, "minEndTime" : TimeMark, "maxEndTime" : TimeMark, "likelyTime" : TimeMark, "confidence" : ApproachID, "nextTime" : TimeMark}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.TimeChangeDetails"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = TimeChangeDetails()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('startTime' in value and 'startTime' not in self._def_vals):
            preamble_bits[0] = True
        elif ('startTime' in value and 'startTime' in self._def_vals):
            if not value_tracker.are_def_eq(value['startTime'], self._def_vals['startTime'], self._comp_types['startTime']):
                preamble_bits[0] = True
        if ('maxEndTime' in value and 'maxEndTime' not in self._def_vals):
            preamble_bits[1] = True
        elif ('maxEndTime' in value and 'maxEndTime' in self._def_vals):
            if not value_tracker.are_def_eq(value['maxEndTime'], self._def_vals['maxEndTime'], self._comp_types['maxEndTime']):
                preamble_bits[1] = True
        if ('likelyTime' in value and 'likelyTime' not in self._def_vals):
            preamble_bits[2] = True
        elif ('likelyTime' in value and 'likelyTime' in self._def_vals):
            if not value_tracker.are_def_eq(value['likelyTime'], self._def_vals['likelyTime'], self._comp_types['likelyTime']):
                preamble_bits[2] = True
        if ('confidence' in value and 'confidence' not in self._def_vals):
            preamble_bits[3] = True
        elif ('confidence' in value and 'confidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['confidence'], self._def_vals['confidence'], self._comp_types['confidence']):
                preamble_bits[3] = True
        if ('nextTime' in value and 'nextTime' not in self._def_vals):
            preamble_bits[4] = True
        elif ('nextTime' in value and 'nextTime' in self._def_vals):
            if not value_tracker.are_def_eq(value['nextTime'], self._def_vals['nextTime'], self._comp_types['nextTime']):
                preamble_bits[4] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[0]:
            TimeMark.encode(encoding_rule, value['startTime'], value_tracker, stream)
        if 'minEndTime' in value:
            TimeMark.encode(encoding_rule, value['minEndTime'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            TimeMark.encode(encoding_rule, value['maxEndTime'], value_tracker, stream)
        if preamble_bits[2]:
            TimeMark.encode(encoding_rule, value['likelyTime'], value_tracker, stream)
        if preamble_bits[3]:
            ApproachID.encode(encoding_rule, value['confidence'], value_tracker, stream)
        if preamble_bits[4]:
            TimeMark.encode(encoding_rule, value['nextTime'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = TimeChangeDetails()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[0]:
            value['startTime'] = TimeMark.decode(encoding_rule, stream, value_tracker)
        elif 'startTime' in self._def_vals:
            value['startTime'] = self._def_vals['startTime']
        value['minEndTime'] = TimeMark.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['maxEndTime'] = TimeMark.decode(encoding_rule, stream, value_tracker)
        elif 'maxEndTime' in self._def_vals:
            value['maxEndTime'] = self._def_vals['maxEndTime']
        if preamble_bits[2]:
            value['likelyTime'] = TimeMark.decode(encoding_rule, stream, value_tracker)
        elif 'likelyTime' in self._def_vals:
            value['likelyTime'] = self._def_vals['likelyTime']
        if preamble_bits[3]:
            value['confidence'] = ApproachID.decode(encoding_rule, stream, value_tracker)
        elif 'confidence' in self._def_vals:
            value['confidence'] = self._def_vals['confidence']
        if preamble_bits[4]:
            value['nextTime'] = TimeMark.decode(encoding_rule, stream, value_tracker)
        elif 'nextTime' in self._def_vals:
            value['nextTime'] = self._def_vals['nextTime']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = TimeChangeDetails()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'startTime' in value:
            TimeMark.validate(value['startTime'], errors, '{}/{}'.format(comp_path ,'startTime'))
        if 'minEndTime' in value:
            TimeMark.validate(value['minEndTime'], errors, '{}/{}'.format(comp_path ,'minEndTime'))
        elif 'minEndTime' not in value:
            report_missing_field(type(self).__name__, 'minEndTime', errors, comp_path)
        if 'maxEndTime' in value:
            TimeMark.validate(value['maxEndTime'], errors, '{}/{}'.format(comp_path ,'maxEndTime'))
        if 'likelyTime' in value:
            TimeMark.validate(value['likelyTime'], errors, '{}/{}'.format(comp_path ,'likelyTime'))
        if 'confidence' in value:
            ApproachID.validate(value['confidence'], errors, '{}/{}'.format(comp_path ,'confidence'))
        if 'nextTime' in value:
            TimeMark.validate(value['nextTime'], errors, '{}/{}'.format(comp_path ,'nextTime'))

        return errors

class TrailerData:
    def __init__(self):
        self._comp_types = {"sspRights" : DDay, "connection" : PivotPointDescription, "units" : TrailerUnitDescriptionList}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.TrailerData"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = TrailerData()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'sspRights' in value:
            DDay.encode(encoding_rule, value['sspRights'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'connection' in value:
            PivotPointDescription.encode(encoding_rule, value['connection'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'units' in value:
            TrailerUnitDescriptionList.encode(encoding_rule, value['units'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = TrailerData()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['sspRights'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['connection'] = PivotPointDescription.decode(encoding_rule, stream, value_tracker)
        value['units'] = TrailerUnitDescriptionList.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = TrailerData()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'sspRights' in value:
            DDay.validate(value['sspRights'], errors, '{}/{}'.format(comp_path ,'sspRights'))
        elif 'sspRights' not in value:
            report_missing_field(type(self).__name__, 'sspRights', errors, comp_path)
        if 'connection' in value:
            PivotPointDescription.validate(value['connection'], errors, '{}/{}'.format(comp_path ,'connection'))
        elif 'connection' not in value:
            report_missing_field(type(self).__name__, 'connection', errors, comp_path)
        if 'units' in value:
            TrailerUnitDescriptionList.validate(value['units'], errors, '{}/{}'.format(comp_path ,'units'))
        elif 'units' not in value:
            report_missing_field(type(self).__name__, 'units', errors, comp_path)

        return errors

class TrailerHistoryPointList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,23)]}}]
        self._unique_indetifier = "DSRC.TrailerHistoryPointList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                TrailerHistoryPoint.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                TrailerHistoryPoint.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(TrailerHistoryPoint.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = TrailerHistoryPointList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 23
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(TrailerHistoryPoint.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = TrailerHistoryPointList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 23
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = TrailerHistoryPointList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                TrailerHistoryPoint.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class TrailerHistoryPoint:
    def __init__(self):
        self._comp_types = {"pivotAngle" : Angle, "timeOffset" : TimeOffset, "positionOffset" : Node_XY_24b, "elevationOffset" : VertOffset_B07, "heading" : CoarseHeading}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.TrailerHistoryPoint"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = TrailerHistoryPoint()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('elevationOffset' in value and 'elevationOffset' not in self._def_vals):
            preamble_bits[0] = True
        elif ('elevationOffset' in value and 'elevationOffset' in self._def_vals):
            if not value_tracker.are_def_eq(value['elevationOffset'], self._def_vals['elevationOffset'], self._comp_types['elevationOffset']):
                preamble_bits[0] = True
        if ('heading' in value and 'heading' not in self._def_vals):
            preamble_bits[1] = True
        elif ('heading' in value and 'heading' in self._def_vals):
            if not value_tracker.are_def_eq(value['heading'], self._def_vals['heading'], self._comp_types['heading']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'pivotAngle' in value:
            Angle.encode(encoding_rule, value['pivotAngle'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'timeOffset' in value:
            TimeOffset.encode(encoding_rule, value['timeOffset'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'positionOffset' in value:
            Node_XY_24b.encode(encoding_rule, value['positionOffset'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            VertOffset_B07.encode(encoding_rule, value['elevationOffset'], value_tracker, stream)
        if preamble_bits[2]:
            CoarseHeading.encode(encoding_rule, value['heading'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = TrailerHistoryPoint()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['pivotAngle'] = Angle.decode(encoding_rule, stream, value_tracker)
        value['timeOffset'] = TimeOffset.decode(encoding_rule, stream, value_tracker)
        value['positionOffset'] = Node_XY_24b.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['elevationOffset'] = VertOffset_B07.decode(encoding_rule, stream, value_tracker)
        elif 'elevationOffset' in self._def_vals:
            value['elevationOffset'] = self._def_vals['elevationOffset']
        if preamble_bits[2]:
            value['heading'] = CoarseHeading.decode(encoding_rule, stream, value_tracker)
        elif 'heading' in self._def_vals:
            value['heading'] = self._def_vals['heading']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = TrailerHistoryPoint()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'pivotAngle' in value:
            Angle.validate(value['pivotAngle'], errors, '{}/{}'.format(comp_path ,'pivotAngle'))
        elif 'pivotAngle' not in value:
            report_missing_field(type(self).__name__, 'pivotAngle', errors, comp_path)
        if 'timeOffset' in value:
            TimeOffset.validate(value['timeOffset'], errors, '{}/{}'.format(comp_path ,'timeOffset'))
        elif 'timeOffset' not in value:
            report_missing_field(type(self).__name__, 'timeOffset', errors, comp_path)
        if 'positionOffset' in value:
            Node_XY_24b.validate(value['positionOffset'], errors, '{}/{}'.format(comp_path ,'positionOffset'))
        elif 'positionOffset' not in value:
            report_missing_field(type(self).__name__, 'positionOffset', errors, comp_path)
        if 'elevationOffset' in value:
            VertOffset_B07.validate(value['elevationOffset'], errors, '{}/{}'.format(comp_path ,'elevationOffset'))
        if 'heading' in value:
            CoarseHeading.validate(value['heading'], errors, '{}/{}'.format(comp_path ,'heading'))

        return errors

class TrailerUnitDescriptionList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,8)]}}]
        self._unique_indetifier = "DSRC.TrailerUnitDescriptionList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                TrailerUnitDescription.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                TrailerUnitDescription.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(TrailerUnitDescription.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = TrailerUnitDescriptionList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(TrailerUnitDescription.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = TrailerUnitDescriptionList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = TrailerUnitDescriptionList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                TrailerUnitDescription.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class TrailerUnitDescription:
    def __init__(self):
        self._comp_types = {"isDolly" : IsDolly, "width" : GrossDistance, "length" : DYear, "height" : BumperHeight, "mass" : AmbientAirPressure, "bumperHeights" : BumperHeights, "centerOfGravity" : BumperHeight, "frontPivot" : PivotPointDescription, "rearPivot" : PivotPointDescription, "rearWheelOffset" : Offset_B12, "positionOffset" : Node_XY_24b, "elevationOffset" : VertOffset_B07, "crumbData" : TrailerHistoryPointList}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.TrailerUnitDescription"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = TrailerUnitDescription()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 8

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('height' in value and 'height' not in self._def_vals):
            preamble_bits[0] = True
        elif ('height' in value and 'height' in self._def_vals):
            if not value_tracker.are_def_eq(value['height'], self._def_vals['height'], self._comp_types['height']):
                preamble_bits[0] = True
        if ('mass' in value and 'mass' not in self._def_vals):
            preamble_bits[1] = True
        elif ('mass' in value and 'mass' in self._def_vals):
            if not value_tracker.are_def_eq(value['mass'], self._def_vals['mass'], self._comp_types['mass']):
                preamble_bits[1] = True
        if ('bumperHeights' in value and 'bumperHeights' not in self._def_vals):
            preamble_bits[2] = True
        elif ('bumperHeights' in value and 'bumperHeights' in self._def_vals):
            if not value_tracker.are_def_eq(value['bumperHeights'], self._def_vals['bumperHeights'], self._comp_types['bumperHeights']):
                preamble_bits[2] = True
        if ('centerOfGravity' in value and 'centerOfGravity' not in self._def_vals):
            preamble_bits[3] = True
        elif ('centerOfGravity' in value and 'centerOfGravity' in self._def_vals):
            if not value_tracker.are_def_eq(value['centerOfGravity'], self._def_vals['centerOfGravity'], self._comp_types['centerOfGravity']):
                preamble_bits[3] = True
        if ('rearPivot' in value and 'rearPivot' not in self._def_vals):
            preamble_bits[4] = True
        elif ('rearPivot' in value and 'rearPivot' in self._def_vals):
            if not value_tracker.are_def_eq(value['rearPivot'], self._def_vals['rearPivot'], self._comp_types['rearPivot']):
                preamble_bits[4] = True
        if ('rearWheelOffset' in value and 'rearWheelOffset' not in self._def_vals):
            preamble_bits[5] = True
        elif ('rearWheelOffset' in value and 'rearWheelOffset' in self._def_vals):
            if not value_tracker.are_def_eq(value['rearWheelOffset'], self._def_vals['rearWheelOffset'], self._comp_types['rearWheelOffset']):
                preamble_bits[5] = True
        if ('elevationOffset' in value and 'elevationOffset' not in self._def_vals):
            preamble_bits[6] = True
        elif ('elevationOffset' in value and 'elevationOffset' in self._def_vals):
            if not value_tracker.are_def_eq(value['elevationOffset'], self._def_vals['elevationOffset'], self._comp_types['elevationOffset']):
                preamble_bits[6] = True
        if ('crumbData' in value and 'crumbData' not in self._def_vals):
            preamble_bits[7] = True
        elif ('crumbData' in value and 'crumbData' in self._def_vals):
            if not value_tracker.are_def_eq(value['crumbData'], self._def_vals['crumbData'], self._comp_types['crumbData']):
                preamble_bits[7] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'isDolly' in value:
            IsDolly.encode(encoding_rule, value['isDolly'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'width' in value:
            GrossDistance.encode(encoding_rule, value['width'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'length' in value:
            DYear.encode(encoding_rule, value['length'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            BumperHeight.encode(encoding_rule, value['height'], value_tracker, stream)
        if preamble_bits[2]:
            AmbientAirPressure.encode(encoding_rule, value['mass'], value_tracker, stream)
        if preamble_bits[3]:
            BumperHeights.encode(encoding_rule, value['bumperHeights'], value_tracker, stream)
        if preamble_bits[4]:
            BumperHeight.encode(encoding_rule, value['centerOfGravity'], value_tracker, stream)
        if 'frontPivot' in value:
            PivotPointDescription.encode(encoding_rule, value['frontPivot'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[5]:
            PivotPointDescription.encode(encoding_rule, value['rearPivot'], value_tracker, stream)
        if preamble_bits[6]:
            Offset_B12.encode(encoding_rule, value['rearWheelOffset'], value_tracker, stream)
        if 'positionOffset' in value:
            Node_XY_24b.encode(encoding_rule, value['positionOffset'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[7]:
            VertOffset_B07.encode(encoding_rule, value['elevationOffset'], value_tracker, stream)
        if preamble_bits[8]:
            TrailerHistoryPointList.encode(encoding_rule, value['crumbData'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = TrailerUnitDescription()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 8

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['isDolly'] = IsDolly.decode(encoding_rule, stream, value_tracker)
        value['width'] = GrossDistance.decode(encoding_rule, stream, value_tracker)
        value['length'] = DYear.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['height'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        elif 'height' in self._def_vals:
            value['height'] = self._def_vals['height']
        if preamble_bits[2]:
            value['mass'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'mass' in self._def_vals:
            value['mass'] = self._def_vals['mass']
        if preamble_bits[3]:
            value['bumperHeights'] = BumperHeights.decode(encoding_rule, stream, value_tracker)
        elif 'bumperHeights' in self._def_vals:
            value['bumperHeights'] = self._def_vals['bumperHeights']
        if preamble_bits[4]:
            value['centerOfGravity'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        elif 'centerOfGravity' in self._def_vals:
            value['centerOfGravity'] = self._def_vals['centerOfGravity']
        value['frontPivot'] = PivotPointDescription.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[5]:
            value['rearPivot'] = PivotPointDescription.decode(encoding_rule, stream, value_tracker)
        elif 'rearPivot' in self._def_vals:
            value['rearPivot'] = self._def_vals['rearPivot']
        if preamble_bits[6]:
            value['rearWheelOffset'] = Offset_B12.decode(encoding_rule, stream, value_tracker)
        elif 'rearWheelOffset' in self._def_vals:
            value['rearWheelOffset'] = self._def_vals['rearWheelOffset']
        value['positionOffset'] = Node_XY_24b.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[7]:
            value['elevationOffset'] = VertOffset_B07.decode(encoding_rule, stream, value_tracker)
        elif 'elevationOffset' in self._def_vals:
            value['elevationOffset'] = self._def_vals['elevationOffset']
        if preamble_bits[8]:
            value['crumbData'] = TrailerHistoryPointList.decode(encoding_rule, stream, value_tracker)
        elif 'crumbData' in self._def_vals:
            value['crumbData'] = self._def_vals['crumbData']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = TrailerUnitDescription()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'isDolly' in value:
            IsDolly.validate(value['isDolly'], errors, '{}/{}'.format(comp_path ,'isDolly'))
        elif 'isDolly' not in value:
            report_missing_field(type(self).__name__, 'isDolly', errors, comp_path)
        if 'width' in value:
            GrossDistance.validate(value['width'], errors, '{}/{}'.format(comp_path ,'width'))
        elif 'width' not in value:
            report_missing_field(type(self).__name__, 'width', errors, comp_path)
        if 'length' in value:
            DYear.validate(value['length'], errors, '{}/{}'.format(comp_path ,'length'))
        elif 'length' not in value:
            report_missing_field(type(self).__name__, 'length', errors, comp_path)
        if 'height' in value:
            BumperHeight.validate(value['height'], errors, '{}/{}'.format(comp_path ,'height'))
        if 'mass' in value:
            AmbientAirPressure.validate(value['mass'], errors, '{}/{}'.format(comp_path ,'mass'))
        if 'bumperHeights' in value:
            BumperHeights.validate(value['bumperHeights'], errors, '{}/{}'.format(comp_path ,'bumperHeights'))
        if 'centerOfGravity' in value:
            BumperHeight.validate(value['centerOfGravity'], errors, '{}/{}'.format(comp_path ,'centerOfGravity'))
        if 'frontPivot' in value:
            PivotPointDescription.validate(value['frontPivot'], errors, '{}/{}'.format(comp_path ,'frontPivot'))
        elif 'frontPivot' not in value:
            report_missing_field(type(self).__name__, 'frontPivot', errors, comp_path)
        if 'rearPivot' in value:
            PivotPointDescription.validate(value['rearPivot'], errors, '{}/{}'.format(comp_path ,'rearPivot'))
        if 'rearWheelOffset' in value:
            Offset_B12.validate(value['rearWheelOffset'], errors, '{}/{}'.format(comp_path ,'rearWheelOffset'))
        if 'positionOffset' in value:
            Node_XY_24b.validate(value['positionOffset'], errors, '{}/{}'.format(comp_path ,'positionOffset'))
        elif 'positionOffset' not in value:
            report_missing_field(type(self).__name__, 'positionOffset', errors, comp_path)
        if 'elevationOffset' in value:
            VertOffset_B07.validate(value['elevationOffset'], errors, '{}/{}'.format(comp_path ,'elevationOffset'))
        if 'crumbData' in value:
            TrailerHistoryPointList.validate(value['crumbData'], errors, '{}/{}'.format(comp_path ,'crumbData'))

        return errors

class TransmissionAndSpeed:
    def __init__(self):
        self._comp_types = {"transmisson" : TransmissionState, "speed" : Speed}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.TransmissionAndSpeed"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = TransmissionAndSpeed()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'transmisson' in value:
            TransmissionState.encode(encoding_rule, value['transmisson'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'speed' in value:
            Speed.encode(encoding_rule, value['speed'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = TransmissionAndSpeed()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['transmisson'] = TransmissionState.decode(encoding_rule, stream, value_tracker)
        value['speed'] = Speed.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = TransmissionAndSpeed()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'transmisson' in value:
            TransmissionState.validate(value['transmisson'], errors, '{}/{}'.format(comp_path ,'transmisson'))
        elif 'transmisson' not in value:
            report_missing_field(type(self).__name__, 'transmisson', errors, comp_path)
        if 'speed' in value:
            Speed.validate(value['speed'], errors, '{}/{}'.format(comp_path ,'speed'))
        elif 'speed' not in value:
            report_missing_field(type(self).__name__, 'speed', errors, comp_path)

        return errors

class TravelerDataFrameList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,8)]}}]
        self._unique_indetifier = "DSRC.TravelerDataFrameList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                TravelerDataFrame.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                TravelerDataFrame.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(TravelerDataFrame.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = TravelerDataFrameList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(TravelerDataFrame.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = TravelerDataFrameList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 8
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = TravelerDataFrameList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                TravelerDataFrame.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class TravelerDataFrame:
    def __init__(self):
        self._comp_types = {"sspTimRights" : DDay, "frameType" : TravelerInfoType, "msgId" : TravelerDataFrame__5, "startYear" : DYear, "startTime" : MinuteOfTheYear, "duratonTime" : MinutesDuration, "priority" : SignPrority, "sspLocationRights" : DDay, "regions" : TravelerDataFrame__12, "sspMsgRights1" : DDay, "sspMsgRights2" : DDay, "content" : TravelerDataFrame__21, "url" : URL_Short}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.TravelerDataFrame"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = TravelerDataFrame()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('startYear' in value and 'startYear' not in self._def_vals):
            preamble_bits[0] = True
        elif ('startYear' in value and 'startYear' in self._def_vals):
            if not value_tracker.are_def_eq(value['startYear'], self._def_vals['startYear'], self._comp_types['startYear']):
                preamble_bits[0] = True
        if ('url' in value and 'url' not in self._def_vals):
            preamble_bits[1] = True
        elif ('url' in value and 'url' in self._def_vals):
            if not value_tracker.are_def_eq(value['url'], self._def_vals['url'], self._comp_types['url']):
                preamble_bits[1] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'sspTimRights' in value:
            DDay.encode(encoding_rule, value['sspTimRights'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'frameType' in value:
            TravelerInfoType.encode(encoding_rule, value['frameType'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'msgId' in value:
            TravelerDataFrame__5.encode(encoding_rule, value['msgId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            DYear.encode(encoding_rule, value['startYear'], value_tracker, stream)
        if 'startTime' in value:
            MinuteOfTheYear.encode(encoding_rule, value['startTime'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'duratonTime' in value:
            MinutesDuration.encode(encoding_rule, value['duratonTime'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'priority' in value:
            SignPrority.encode(encoding_rule, value['priority'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'sspLocationRights' in value:
            DDay.encode(encoding_rule, value['sspLocationRights'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'regions' in value:
            TravelerDataFrame__12.encode(encoding_rule, value['regions'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'sspMsgRights1' in value:
            DDay.encode(encoding_rule, value['sspMsgRights1'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'sspMsgRights2' in value:
            DDay.encode(encoding_rule, value['sspMsgRights2'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'content' in value:
            TravelerDataFrame__21.encode(encoding_rule, value['content'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            URL_Short.encode(encoding_rule, value['url'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = TravelerDataFrame()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['sspTimRights'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['frameType'] = TravelerInfoType.decode(encoding_rule, stream, value_tracker)
        value['msgId'] = TravelerDataFrame__5.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['startYear'] = DYear.decode(encoding_rule, stream, value_tracker)
        elif 'startYear' in self._def_vals:
            value['startYear'] = self._def_vals['startYear']
        value['startTime'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        value['duratonTime'] = MinutesDuration.decode(encoding_rule, stream, value_tracker)
        value['priority'] = SignPrority.decode(encoding_rule, stream, value_tracker)
        value['sspLocationRights'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['regions'] = TravelerDataFrame__12.decode(encoding_rule, stream, value_tracker)
        value['sspMsgRights1'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['sspMsgRights2'] = DDay.decode(encoding_rule, stream, value_tracker)
        value['content'] = TravelerDataFrame__21.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['url'] = URL_Short.decode(encoding_rule, stream, value_tracker)
        elif 'url' in self._def_vals:
            value['url'] = self._def_vals['url']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = TravelerDataFrame()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'sspTimRights' in value:
            DDay.validate(value['sspTimRights'], errors, '{}/{}'.format(comp_path ,'sspTimRights'))
        elif 'sspTimRights' not in value:
            report_missing_field(type(self).__name__, 'sspTimRights', errors, comp_path)
        if 'frameType' in value:
            TravelerInfoType.validate(value['frameType'], errors, '{}/{}'.format(comp_path ,'frameType'))
        elif 'frameType' not in value:
            report_missing_field(type(self).__name__, 'frameType', errors, comp_path)
        if 'msgId' in value:
            TravelerDataFrame__5.validate(value['msgId'], errors, '{}/{}'.format(comp_path ,'msgId'))
        elif 'msgId' not in value:
            report_missing_field(type(self).__name__, 'msgId', errors, comp_path)
        if 'startYear' in value:
            DYear.validate(value['startYear'], errors, '{}/{}'.format(comp_path ,'startYear'))
        if 'startTime' in value:
            MinuteOfTheYear.validate(value['startTime'], errors, '{}/{}'.format(comp_path ,'startTime'))
        elif 'startTime' not in value:
            report_missing_field(type(self).__name__, 'startTime', errors, comp_path)
        if 'duratonTime' in value:
            MinutesDuration.validate(value['duratonTime'], errors, '{}/{}'.format(comp_path ,'duratonTime'))
        elif 'duratonTime' not in value:
            report_missing_field(type(self).__name__, 'duratonTime', errors, comp_path)
        if 'priority' in value:
            SignPrority.validate(value['priority'], errors, '{}/{}'.format(comp_path ,'priority'))
        elif 'priority' not in value:
            report_missing_field(type(self).__name__, 'priority', errors, comp_path)
        if 'sspLocationRights' in value:
            DDay.validate(value['sspLocationRights'], errors, '{}/{}'.format(comp_path ,'sspLocationRights'))
        elif 'sspLocationRights' not in value:
            report_missing_field(type(self).__name__, 'sspLocationRights', errors, comp_path)
        if 'regions' in value:
            TravelerDataFrame__12.validate(value['regions'], errors, '{}/{}'.format(comp_path ,'regions'))
        elif 'regions' not in value:
            report_missing_field(type(self).__name__, 'regions', errors, comp_path)
        if 'sspMsgRights1' in value:
            DDay.validate(value['sspMsgRights1'], errors, '{}/{}'.format(comp_path ,'sspMsgRights1'))
        elif 'sspMsgRights1' not in value:
            report_missing_field(type(self).__name__, 'sspMsgRights1', errors, comp_path)
        if 'sspMsgRights2' in value:
            DDay.validate(value['sspMsgRights2'], errors, '{}/{}'.format(comp_path ,'sspMsgRights2'))
        elif 'sspMsgRights2' not in value:
            report_missing_field(type(self).__name__, 'sspMsgRights2', errors, comp_path)
        if 'content' in value:
            TravelerDataFrame__21.validate(value['content'], errors, '{}/{}'.format(comp_path ,'content'))
        elif 'content' not in value:
            report_missing_field(type(self).__name__, 'content', errors, comp_path)
        if 'url' in value:
            URL_Short.validate(value['url'], errors, '{}/{}'.format(comp_path ,'url'))

        return errors

class TravelerDataFrame__5:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.TravelerDataFrame.msgId"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"furtherInfoID": 0, "roadSignID": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = TravelerDataFrame__5()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'furtherInfoID':
                FurtherInfoID.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'roadSignID':
                RoadSignID.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = TravelerDataFrame__5()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'furtherInfoID':
                alternative = FurtherInfoID.decode(encoding_rule, stream, value_tracker)
            if identifier == 'roadSignID':
                alternative = RoadSignID.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = TravelerDataFrame__5()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'furtherInfoID' in value:
            FurtherInfoID.validate(value['furtherInfoID'], errors, '{}/{}'.format(comp_path ,'furtherInfoID'))
            is_checked = True
        if 'roadSignID' in value:
            RoadSignID.validate(value['roadSignID'], errors, '{}/{}'.format(comp_path ,'roadSignID'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class TravelerDataFrame__12:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,16)]}}]
        self._unique_indetifier = "DSRC.TravelerDataFrame.regions"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                GeographicalPath.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                GeographicalPath.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(GeographicalPath.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = TravelerDataFrame__12()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(GeographicalPath.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = TravelerDataFrame__12()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = TravelerDataFrame__12()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                GeographicalPath.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class TravelerDataFrame__21:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.TravelerDataFrame.content"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"advisory": 0, "workZone": 1, "genericSign": 2, "speedLimit": 3, "exitService": 4}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = TravelerDataFrame__21()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 5
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'advisory':
                ITIScodesAndText.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'workZone':
                ExitService.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'genericSign':
                ExitService.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'speedLimit':
                ExitService.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'exitService':
                ExitService.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = TravelerDataFrame__21()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 5
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'advisory':
                alternative = ITIScodesAndText.decode(encoding_rule, stream, value_tracker)
            if identifier == 'workZone':
                alternative = ExitService.decode(encoding_rule, stream, value_tracker)
            if identifier == 'genericSign':
                alternative = ExitService.decode(encoding_rule, stream, value_tracker)
            if identifier == 'speedLimit':
                alternative = ExitService.decode(encoding_rule, stream, value_tracker)
            if identifier == 'exitService':
                alternative = ExitService.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = TravelerDataFrame__21()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'advisory' in value:
            ITIScodesAndText.validate(value['advisory'], errors, '{}/{}'.format(comp_path ,'advisory'))
            is_checked = True
        if 'workZone' in value:
            ExitService.validate(value['workZone'], errors, '{}/{}'.format(comp_path ,'workZone'))
            is_checked = True
        if 'genericSign' in value:
            ExitService.validate(value['genericSign'], errors, '{}/{}'.format(comp_path ,'genericSign'))
            is_checked = True
        if 'speedLimit' in value:
            ExitService.validate(value['speedLimit'], errors, '{}/{}'.format(comp_path ,'speedLimit'))
            is_checked = True
        if 'exitService' in value:
            ExitService.validate(value['exitService'], errors, '{}/{}'.format(comp_path ,'exitService'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class ValidRegion:
    def __init__(self):
        self._comp_types = {"direction" : HeadingSlice, "extent" : Extent, "area" : ValidRegion__6}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.ValidRegion"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ValidRegion()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('extent' in value and 'extent' not in self._def_vals):
            preamble_bits[0] = True
        elif ('extent' in value and 'extent' in self._def_vals):
            if not value_tracker.are_def_eq(value['extent'], self._def_vals['extent'], self._comp_types['extent']):
                preamble_bits[0] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'direction' in value:
            HeadingSlice.encode(encoding_rule, value['direction'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            Extent.encode(encoding_rule, value['extent'], value_tracker, stream)
        if 'area' in value:
            ValidRegion__6.encode(encoding_rule, value['area'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ValidRegion()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['direction'] = HeadingSlice.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['extent'] = Extent.decode(encoding_rule, stream, value_tracker)
        elif 'extent' in self._def_vals:
            value['extent'] = self._def_vals['extent']
        value['area'] = ValidRegion__6.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ValidRegion()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'direction' in value:
            HeadingSlice.validate(value['direction'], errors, '{}/{}'.format(comp_path ,'direction'))
        elif 'direction' not in value:
            report_missing_field(type(self).__name__, 'direction', errors, comp_path)
        if 'extent' in value:
            Extent.validate(value['extent'], errors, '{}/{}'.format(comp_path ,'extent'))
        if 'area' in value:
            ValidRegion__6.validate(value['area'], errors, '{}/{}'.format(comp_path ,'area'))
        elif 'area' not in value:
            report_missing_field(type(self).__name__, 'area', errors, comp_path)

        return errors

class ValidRegion__6:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.ValidRegion.area"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"shapePointSet": 0, "circle": 1, "regionPointSet": 2}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = ValidRegion__6()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 3
        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'shapePointSet':
                ShapePointSet.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'circle':
                Circle.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'regionPointSet':
                RegionPointSet.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = ValidRegion__6()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 3
        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'shapePointSet':
                alternative = ShapePointSet.decode(encoding_rule, stream, value_tracker)
            if identifier == 'circle':
                alternative = Circle.decode(encoding_rule, stream, value_tracker)
            if identifier == 'regionPointSet':
                alternative = RegionPointSet.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = ValidRegion__6()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'shapePointSet' in value:
            ShapePointSet.validate(value['shapePointSet'], errors, '{}/{}'.format(comp_path ,'shapePointSet'))
            is_checked = True
        if 'circle' in value:
            Circle.validate(value['circle'], errors, '{}/{}'.format(comp_path ,'circle'))
            is_checked = True
        if 'regionPointSet' in value:
            RegionPointSet.validate(value['regionPointSet'], errors, '{}/{}'.format(comp_path ,'regionPointSet'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class VehicleClassification:
    def __init__(self):
        self._comp_types = {"keyType" : AmbientAirPressure, "role" : BasicVehicleRole, "iso3883" : Iso3833VehicleType, "hpmsType" : VehicleType, "vehicleType" : VehicleGroupAffected, "responseEquip" : IncidentResponseEquipment, "responderType" : ResponderGroupAffected, "fuelType" : ApproachID, "regional" : AdvisorySpeed__7}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleClassification"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleClassification()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 9

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('keyType' in value and 'keyType' not in self._def_vals):
            preamble_bits[0] = True
        elif ('keyType' in value and 'keyType' in self._def_vals):
            if not value_tracker.are_def_eq(value['keyType'], self._def_vals['keyType'], self._comp_types['keyType']):
                preamble_bits[0] = True
        if ('role' in value and 'role' not in self._def_vals):
            preamble_bits[1] = True
        elif ('role' in value and 'role' in self._def_vals):
            if not value_tracker.are_def_eq(value['role'], self._def_vals['role'], self._comp_types['role']):
                preamble_bits[1] = True
        if ('iso3883' in value and 'iso3883' not in self._def_vals):
            preamble_bits[2] = True
        elif ('iso3883' in value and 'iso3883' in self._def_vals):
            if not value_tracker.are_def_eq(value['iso3883'], self._def_vals['iso3883'], self._comp_types['iso3883']):
                preamble_bits[2] = True
        if ('hpmsType' in value and 'hpmsType' not in self._def_vals):
            preamble_bits[3] = True
        elif ('hpmsType' in value and 'hpmsType' in self._def_vals):
            if not value_tracker.are_def_eq(value['hpmsType'], self._def_vals['hpmsType'], self._comp_types['hpmsType']):
                preamble_bits[3] = True
        if ('vehicleType' in value and 'vehicleType' not in self._def_vals):
            preamble_bits[4] = True
        elif ('vehicleType' in value and 'vehicleType' in self._def_vals):
            if not value_tracker.are_def_eq(value['vehicleType'], self._def_vals['vehicleType'], self._comp_types['vehicleType']):
                preamble_bits[4] = True
        if ('responseEquip' in value and 'responseEquip' not in self._def_vals):
            preamble_bits[5] = True
        elif ('responseEquip' in value and 'responseEquip' in self._def_vals):
            if not value_tracker.are_def_eq(value['responseEquip'], self._def_vals['responseEquip'], self._comp_types['responseEquip']):
                preamble_bits[5] = True
        if ('responderType' in value and 'responderType' not in self._def_vals):
            preamble_bits[6] = True
        elif ('responderType' in value and 'responderType' in self._def_vals):
            if not value_tracker.are_def_eq(value['responderType'], self._def_vals['responderType'], self._comp_types['responderType']):
                preamble_bits[6] = True
        if ('fuelType' in value and 'fuelType' not in self._def_vals):
            preamble_bits[7] = True
        elif ('fuelType' in value and 'fuelType' in self._def_vals):
            if not value_tracker.are_def_eq(value['fuelType'], self._def_vals['fuelType'], self._comp_types['fuelType']):
                preamble_bits[7] = True
        if ('regional' in value and 'regional' not in self._def_vals):
            preamble_bits[8] = True
        elif ('regional' in value and 'regional' in self._def_vals):
            if not value_tracker.are_def_eq(value['regional'], self._def_vals['regional'], self._comp_types['regional']):
                preamble_bits[8] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            AmbientAirPressure.encode(encoding_rule, value['keyType'], value_tracker, stream)
        if preamble_bits[2]:
            BasicVehicleRole.encode(encoding_rule, value['role'], value_tracker, stream)
        if preamble_bits[3]:
            Iso3833VehicleType.encode(encoding_rule, value['iso3883'], value_tracker, stream)
        if preamble_bits[4]:
            VehicleType.encode(encoding_rule, value['hpmsType'], value_tracker, stream)
        if preamble_bits[5]:
            VehicleGroupAffected.encode(encoding_rule, value['vehicleType'], value_tracker, stream)
        if preamble_bits[6]:
            IncidentResponseEquipment.encode(encoding_rule, value['responseEquip'], value_tracker, stream)
        if preamble_bits[7]:
            ResponderGroupAffected.encode(encoding_rule, value['responderType'], value_tracker, stream)
        if preamble_bits[8]:
            ApproachID.encode(encoding_rule, value['fuelType'], value_tracker, stream)
        if preamble_bits[9]:
            AdvisorySpeed__7.encode(encoding_rule, value['regional'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleClassification()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 9

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['keyType'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'keyType' in self._def_vals:
            value['keyType'] = self._def_vals['keyType']
        if preamble_bits[2]:
            value['role'] = BasicVehicleRole.decode(encoding_rule, stream, value_tracker)
        elif 'role' in self._def_vals:
            value['role'] = self._def_vals['role']
        if preamble_bits[3]:
            value['iso3883'] = Iso3833VehicleType.decode(encoding_rule, stream, value_tracker)
        elif 'iso3883' in self._def_vals:
            value['iso3883'] = self._def_vals['iso3883']
        if preamble_bits[4]:
            value['hpmsType'] = VehicleType.decode(encoding_rule, stream, value_tracker)
        elif 'hpmsType' in self._def_vals:
            value['hpmsType'] = self._def_vals['hpmsType']
        if preamble_bits[5]:
            value['vehicleType'] = VehicleGroupAffected.decode(encoding_rule, stream, value_tracker)
        elif 'vehicleType' in self._def_vals:
            value['vehicleType'] = self._def_vals['vehicleType']
        if preamble_bits[6]:
            value['responseEquip'] = IncidentResponseEquipment.decode(encoding_rule, stream, value_tracker)
        elif 'responseEquip' in self._def_vals:
            value['responseEquip'] = self._def_vals['responseEquip']
        if preamble_bits[7]:
            value['responderType'] = ResponderGroupAffected.decode(encoding_rule, stream, value_tracker)
        elif 'responderType' in self._def_vals:
            value['responderType'] = self._def_vals['responderType']
        if preamble_bits[8]:
            value['fuelType'] = ApproachID.decode(encoding_rule, stream, value_tracker)
        elif 'fuelType' in self._def_vals:
            value['fuelType'] = self._def_vals['fuelType']
        if preamble_bits[9]:
            value['regional'] = AdvisorySpeed__7.decode(encoding_rule, stream, value_tracker)
        elif 'regional' in self._def_vals:
            value['regional'] = self._def_vals['regional']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleClassification()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'keyType' in value:
            AmbientAirPressure.validate(value['keyType'], errors, '{}/{}'.format(comp_path ,'keyType'))
        if 'role' in value:
            BasicVehicleRole.validate(value['role'], errors, '{}/{}'.format(comp_path ,'role'))
        if 'iso3883' in value:
            Iso3833VehicleType.validate(value['iso3883'], errors, '{}/{}'.format(comp_path ,'iso3883'))
        if 'hpmsType' in value:
            VehicleType.validate(value['hpmsType'], errors, '{}/{}'.format(comp_path ,'hpmsType'))
        if 'vehicleType' in value:
            VehicleGroupAffected.validate(value['vehicleType'], errors, '{}/{}'.format(comp_path ,'vehicleType'))
        if 'responseEquip' in value:
            IncidentResponseEquipment.validate(value['responseEquip'], errors, '{}/{}'.format(comp_path ,'responseEquip'))
        if 'responderType' in value:
            ResponderGroupAffected.validate(value['responderType'], errors, '{}/{}'.format(comp_path ,'responderType'))
        if 'fuelType' in value:
            ApproachID.validate(value['fuelType'], errors, '{}/{}'.format(comp_path ,'fuelType'))
        if 'regional' in value:
            AdvisorySpeed__7.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))

        return errors

class VehicleData:
    def __init__(self):
        self._comp_types = {"height" : BumperHeight, "bumpers" : BumperHeights, "mass" : AmbientAirPressure, "trailerWeight" : AxleWeight}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleData"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleData()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('height' in value and 'height' not in self._def_vals):
            preamble_bits[0] = True
        elif ('height' in value and 'height' in self._def_vals):
            if not value_tracker.are_def_eq(value['height'], self._def_vals['height'], self._comp_types['height']):
                preamble_bits[0] = True
        if ('bumpers' in value and 'bumpers' not in self._def_vals):
            preamble_bits[1] = True
        elif ('bumpers' in value and 'bumpers' in self._def_vals):
            if not value_tracker.are_def_eq(value['bumpers'], self._def_vals['bumpers'], self._comp_types['bumpers']):
                preamble_bits[1] = True
        if ('mass' in value and 'mass' not in self._def_vals):
            preamble_bits[2] = True
        elif ('mass' in value and 'mass' in self._def_vals):
            if not value_tracker.are_def_eq(value['mass'], self._def_vals['mass'], self._comp_types['mass']):
                preamble_bits[2] = True
        if ('trailerWeight' in value and 'trailerWeight' not in self._def_vals):
            preamble_bits[3] = True
        elif ('trailerWeight' in value and 'trailerWeight' in self._def_vals):
            if not value_tracker.are_def_eq(value['trailerWeight'], self._def_vals['trailerWeight'], self._comp_types['trailerWeight']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            BumperHeight.encode(encoding_rule, value['height'], value_tracker, stream)
        if preamble_bits[2]:
            BumperHeights.encode(encoding_rule, value['bumpers'], value_tracker, stream)
        if preamble_bits[3]:
            AmbientAirPressure.encode(encoding_rule, value['mass'], value_tracker, stream)
        if preamble_bits[4]:
            AxleWeight.encode(encoding_rule, value['trailerWeight'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleData()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['height'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        elif 'height' in self._def_vals:
            value['height'] = self._def_vals['height']
        if preamble_bits[2]:
            value['bumpers'] = BumperHeights.decode(encoding_rule, stream, value_tracker)
        elif 'bumpers' in self._def_vals:
            value['bumpers'] = self._def_vals['bumpers']
        if preamble_bits[3]:
            value['mass'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'mass' in self._def_vals:
            value['mass'] = self._def_vals['mass']
        if preamble_bits[4]:
            value['trailerWeight'] = AxleWeight.decode(encoding_rule, stream, value_tracker)
        elif 'trailerWeight' in self._def_vals:
            value['trailerWeight'] = self._def_vals['trailerWeight']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleData()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'height' in value:
            BumperHeight.validate(value['height'], errors, '{}/{}'.format(comp_path ,'height'))
        if 'bumpers' in value:
            BumperHeights.validate(value['bumpers'], errors, '{}/{}'.format(comp_path ,'bumpers'))
        if 'mass' in value:
            AmbientAirPressure.validate(value['mass'], errors, '{}/{}'.format(comp_path ,'mass'))
        if 'trailerWeight' in value:
            AxleWeight.validate(value['trailerWeight'], errors, '{}/{}'.format(comp_path ,'trailerWeight'))

        return errors

class VehicleIdent:
    def __init__(self):
        self._comp_types = {"name" : DescriptiveName, "vin" : VINstring, "ownerCode" : VehicleIdent__3, "id" : VehicleID, "vehicleType" : VehicleType, "vehicleClass" : VehicleIdent__10}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleIdent"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleIdent()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 6

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('name' in value and 'name' not in self._def_vals):
            preamble_bits[0] = True
        elif ('name' in value and 'name' in self._def_vals):
            if not value_tracker.are_def_eq(value['name'], self._def_vals['name'], self._comp_types['name']):
                preamble_bits[0] = True
        if ('vin' in value and 'vin' not in self._def_vals):
            preamble_bits[1] = True
        elif ('vin' in value and 'vin' in self._def_vals):
            if not value_tracker.are_def_eq(value['vin'], self._def_vals['vin'], self._comp_types['vin']):
                preamble_bits[1] = True
        if ('ownerCode' in value and 'ownerCode' not in self._def_vals):
            preamble_bits[2] = True
        elif ('ownerCode' in value and 'ownerCode' in self._def_vals):
            if not value_tracker.are_def_eq(value['ownerCode'], self._def_vals['ownerCode'], self._comp_types['ownerCode']):
                preamble_bits[2] = True
        if ('id' in value and 'id' not in self._def_vals):
            preamble_bits[3] = True
        elif ('id' in value and 'id' in self._def_vals):
            if not value_tracker.are_def_eq(value['id'], self._def_vals['id'], self._comp_types['id']):
                preamble_bits[3] = True
        if ('vehicleType' in value and 'vehicleType' not in self._def_vals):
            preamble_bits[4] = True
        elif ('vehicleType' in value and 'vehicleType' in self._def_vals):
            if not value_tracker.are_def_eq(value['vehicleType'], self._def_vals['vehicleType'], self._comp_types['vehicleType']):
                preamble_bits[4] = True
        if ('vehicleClass' in value and 'vehicleClass' not in self._def_vals):
            preamble_bits[5] = True
        elif ('vehicleClass' in value and 'vehicleClass' in self._def_vals):
            if not value_tracker.are_def_eq(value['vehicleClass'], self._def_vals['vehicleClass'], self._comp_types['vehicleClass']):
                preamble_bits[5] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            DescriptiveName.encode(encoding_rule, value['name'], value_tracker, stream)
        if preamble_bits[2]:
            VINstring.encode(encoding_rule, value['vin'], value_tracker, stream)
        if preamble_bits[3]:
            VehicleIdent__3.encode(encoding_rule, value['ownerCode'], value_tracker, stream)
        if preamble_bits[4]:
            VehicleID.encode(encoding_rule, value['id'], value_tracker, stream)
        if preamble_bits[5]:
            VehicleType.encode(encoding_rule, value['vehicleType'], value_tracker, stream)
        if preamble_bits[6]:
            VehicleIdent__10.encode(encoding_rule, value['vehicleClass'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleIdent()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 6

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['name'] = DescriptiveName.decode(encoding_rule, stream, value_tracker)
        elif 'name' in self._def_vals:
            value['name'] = self._def_vals['name']
        if preamble_bits[2]:
            value['vin'] = VINstring.decode(encoding_rule, stream, value_tracker)
        elif 'vin' in self._def_vals:
            value['vin'] = self._def_vals['vin']
        if preamble_bits[3]:
            value['ownerCode'] = VehicleIdent__3.decode(encoding_rule, stream, value_tracker)
        elif 'ownerCode' in self._def_vals:
            value['ownerCode'] = self._def_vals['ownerCode']
        if preamble_bits[4]:
            value['id'] = VehicleID.decode(encoding_rule, stream, value_tracker)
        elif 'id' in self._def_vals:
            value['id'] = self._def_vals['id']
        if preamble_bits[5]:
            value['vehicleType'] = VehicleType.decode(encoding_rule, stream, value_tracker)
        elif 'vehicleType' in self._def_vals:
            value['vehicleType'] = self._def_vals['vehicleType']
        if preamble_bits[6]:
            value['vehicleClass'] = VehicleIdent__10.decode(encoding_rule, stream, value_tracker)
        elif 'vehicleClass' in self._def_vals:
            value['vehicleClass'] = self._def_vals['vehicleClass']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleIdent()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'name' in value:
            DescriptiveName.validate(value['name'], errors, '{}/{}'.format(comp_path ,'name'))
        if 'vin' in value:
            VINstring.validate(value['vin'], errors, '{}/{}'.format(comp_path ,'vin'))
        if 'ownerCode' in value:
            VehicleIdent__3.validate(value['ownerCode'], errors, '{}/{}'.format(comp_path ,'ownerCode'))
        if 'id' in value:
            VehicleID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        if 'vehicleType' in value:
            VehicleType.validate(value['vehicleType'], errors, '{}/{}'.format(comp_path ,'vehicleType'))
        if 'vehicleClass' in value:
            VehicleIdent__10.validate(value['vehicleClass'], errors, '{}/{}'.format(comp_path ,'vehicleClass'))

        return errors

class VehicleIdent__3:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"alphabet constraint","permitted":[[0,127]]}},{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1..32)","permitted":[(1,32)]}}]
        self._unique_indetifier = "DSRC.VehicleIdent.ownerCode"
        self._asn1Type = Asn1Type.String

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = VehicleIdent__3()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_aligned'] = 5
        data_map['width_length_unaligned'] = 5
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        osspy.per.encode_string(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> str:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = VehicleIdent__3()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> str:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_aligned'] = 5
        data_map['width_length_unaligned'] = 5
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        return osspy.per.decode_string(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = VehicleIdent__3()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class VehicleIdent__10:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleIdent.vehicleClass"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"vGroup": 0, "rGroup": 1, "rEquip": 2}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = VehicleIdent__10()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 3
        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'vGroup':
                VehicleGroupAffected.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'rGroup':
                ResponderGroupAffected.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'rEquip':
                IncidentResponseEquipment.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = VehicleIdent__10()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 3
        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'vGroup':
                alternative = VehicleGroupAffected.decode(encoding_rule, stream, value_tracker)
            if identifier == 'rGroup':
                alternative = ResponderGroupAffected.decode(encoding_rule, stream, value_tracker)
            if identifier == 'rEquip':
                alternative = IncidentResponseEquipment.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = VehicleIdent__10()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'vGroup' in value:
            VehicleGroupAffected.validate(value['vGroup'], errors, '{}/{}'.format(comp_path ,'vGroup'))
            is_checked = True
        if 'rGroup' in value:
            ResponderGroupAffected.validate(value['rGroup'], errors, '{}/{}'.format(comp_path ,'rGroup'))
            is_checked = True
        if 'rEquip' in value:
            IncidentResponseEquipment.validate(value['rEquip'], errors, '{}/{}'.format(comp_path ,'rEquip'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class VehicleID:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleID"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"entityID": 0, "stationID": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = VehicleID()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'entityID':
                TemporaryID.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'stationID':
                StationID.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = VehicleID()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'entityID':
                alternative = TemporaryID.decode(encoding_rule, stream, value_tracker)
            if identifier == 'stationID':
                alternative = StationID.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = VehicleID()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'entityID' in value:
            TemporaryID.validate(value['entityID'], errors, '{}/{}'.format(comp_path ,'entityID'))
            is_checked = True
        if 'stationID' in value:
            StationID.validate(value['stationID'], errors, '{}/{}'.format(comp_path ,'stationID'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class VehicleSafetyExtensions:
    def __init__(self):
        self._comp_types = {"events" : VehicleEventFlags, "pathHistory" : PathHistory, "pathPrediction" : PathPrediction, "lights" : ExteriorLights}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleSafetyExtensions"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleSafetyExtensions()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('events' in value and 'events' not in self._def_vals):
            preamble_bits[0] = True
        elif ('events' in value and 'events' in self._def_vals):
            if not value_tracker.are_def_eq(value['events'], self._def_vals['events'], self._comp_types['events']):
                preamble_bits[0] = True
        if ('pathHistory' in value and 'pathHistory' not in self._def_vals):
            preamble_bits[1] = True
        elif ('pathHistory' in value and 'pathHistory' in self._def_vals):
            if not value_tracker.are_def_eq(value['pathHistory'], self._def_vals['pathHistory'], self._comp_types['pathHistory']):
                preamble_bits[1] = True
        if ('pathPrediction' in value and 'pathPrediction' not in self._def_vals):
            preamble_bits[2] = True
        elif ('pathPrediction' in value and 'pathPrediction' in self._def_vals):
            if not value_tracker.are_def_eq(value['pathPrediction'], self._def_vals['pathPrediction'], self._comp_types['pathPrediction']):
                preamble_bits[2] = True
        if ('lights' in value and 'lights' not in self._def_vals):
            preamble_bits[3] = True
        elif ('lights' in value and 'lights' in self._def_vals):
            if not value_tracker.are_def_eq(value['lights'], self._def_vals['lights'], self._comp_types['lights']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            VehicleEventFlags.encode(encoding_rule, value['events'], value_tracker, stream)
        if preamble_bits[2]:
            PathHistory.encode(encoding_rule, value['pathHistory'], value_tracker, stream)
        if preamble_bits[3]:
            PathPrediction.encode(encoding_rule, value['pathPrediction'], value_tracker, stream)
        if preamble_bits[4]:
            ExteriorLights.encode(encoding_rule, value['lights'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleSafetyExtensions()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['events'] = VehicleEventFlags.decode(encoding_rule, stream, value_tracker)
        elif 'events' in self._def_vals:
            value['events'] = self._def_vals['events']
        if preamble_bits[2]:
            value['pathHistory'] = PathHistory.decode(encoding_rule, stream, value_tracker)
        elif 'pathHistory' in self._def_vals:
            value['pathHistory'] = self._def_vals['pathHistory']
        if preamble_bits[3]:
            value['pathPrediction'] = PathPrediction.decode(encoding_rule, stream, value_tracker)
        elif 'pathPrediction' in self._def_vals:
            value['pathPrediction'] = self._def_vals['pathPrediction']
        if preamble_bits[4]:
            value['lights'] = ExteriorLights.decode(encoding_rule, stream, value_tracker)
        elif 'lights' in self._def_vals:
            value['lights'] = self._def_vals['lights']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleSafetyExtensions()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'events' in value:
            VehicleEventFlags.validate(value['events'], errors, '{}/{}'.format(comp_path ,'events'))
        if 'pathHistory' in value:
            PathHistory.validate(value['pathHistory'], errors, '{}/{}'.format(comp_path ,'pathHistory'))
        if 'pathPrediction' in value:
            PathPrediction.validate(value['pathPrediction'], errors, '{}/{}'.format(comp_path ,'pathPrediction'))
        if 'lights' in value:
            ExteriorLights.validate(value['lights'], errors, '{}/{}'.format(comp_path ,'lights'))

        return errors

class VehicleSize:
    def __init__(self):
        self._comp_types = {"width" : GrossDistance, "length" : DYear}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleSize"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleSize()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'width' in value:
            GrossDistance.encode(encoding_rule, value['width'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'length' in value:
            DYear.encode(encoding_rule, value['length'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleSize()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['width'] = GrossDistance.decode(encoding_rule, stream, value_tracker)
        value['length'] = DYear.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleSize()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'width' in value:
            GrossDistance.validate(value['width'], errors, '{}/{}'.format(comp_path ,'width'))
        elif 'width' not in value:
            report_missing_field(type(self).__name__, 'width', errors, comp_path)
        if 'length' in value:
            DYear.validate(value['length'], errors, '{}/{}'.format(comp_path ,'length'))
        elif 'length' not in value:
            report_missing_field(type(self).__name__, 'length', errors, comp_path)

        return errors

class VehicleStatusRequest:
    def __init__(self):
        self._comp_types = {"dataType" : VehicleStatusDeviceTypeTag, "subType" : VehicleStatusRequest__2, "sendOnLessThenValue" : DrivenLineOffsetLg, "sendOnMoreThenValue" : DrivenLineOffsetLg, "sendAll" : IsDolly}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleStatusRequest"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleStatusRequest()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('subType' in value and 'subType' not in self._def_vals):
            preamble_bits[0] = True
        elif ('subType' in value and 'subType' in self._def_vals):
            if not value_tracker.are_def_eq(value['subType'], self._def_vals['subType'], self._comp_types['subType']):
                preamble_bits[0] = True
        if ('sendOnLessThenValue' in value and 'sendOnLessThenValue' not in self._def_vals):
            preamble_bits[1] = True
        elif ('sendOnLessThenValue' in value and 'sendOnLessThenValue' in self._def_vals):
            if not value_tracker.are_def_eq(value['sendOnLessThenValue'], self._def_vals['sendOnLessThenValue'], self._comp_types['sendOnLessThenValue']):
                preamble_bits[1] = True
        if ('sendOnMoreThenValue' in value and 'sendOnMoreThenValue' not in self._def_vals):
            preamble_bits[2] = True
        elif ('sendOnMoreThenValue' in value and 'sendOnMoreThenValue' in self._def_vals):
            if not value_tracker.are_def_eq(value['sendOnMoreThenValue'], self._def_vals['sendOnMoreThenValue'], self._comp_types['sendOnMoreThenValue']):
                preamble_bits[2] = True
        if ('sendAll' in value and 'sendAll' not in self._def_vals):
            preamble_bits[3] = True
        elif ('sendAll' in value and 'sendAll' in self._def_vals):
            if not value_tracker.are_def_eq(value['sendAll'], self._def_vals['sendAll'], self._comp_types['sendAll']):
                preamble_bits[3] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'dataType' in value:
            VehicleStatusDeviceTypeTag.encode(encoding_rule, value['dataType'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            VehicleStatusRequest__2.encode(encoding_rule, value['subType'], value_tracker, stream)
        if preamble_bits[2]:
            DrivenLineOffsetLg.encode(encoding_rule, value['sendOnLessThenValue'], value_tracker, stream)
        if preamble_bits[3]:
            DrivenLineOffsetLg.encode(encoding_rule, value['sendOnMoreThenValue'], value_tracker, stream)
        if preamble_bits[4]:
            IsDolly.encode(encoding_rule, value['sendAll'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleStatusRequest()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['dataType'] = VehicleStatusDeviceTypeTag.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['subType'] = VehicleStatusRequest__2.decode(encoding_rule, stream, value_tracker)
        elif 'subType' in self._def_vals:
            value['subType'] = self._def_vals['subType']
        if preamble_bits[2]:
            value['sendOnLessThenValue'] = DrivenLineOffsetLg.decode(encoding_rule, stream, value_tracker)
        elif 'sendOnLessThenValue' in self._def_vals:
            value['sendOnLessThenValue'] = self._def_vals['sendOnLessThenValue']
        if preamble_bits[3]:
            value['sendOnMoreThenValue'] = DrivenLineOffsetLg.decode(encoding_rule, stream, value_tracker)
        elif 'sendOnMoreThenValue' in self._def_vals:
            value['sendOnMoreThenValue'] = self._def_vals['sendOnMoreThenValue']
        if preamble_bits[4]:
            value['sendAll'] = IsDolly.decode(encoding_rule, stream, value_tracker)
        elif 'sendAll' in self._def_vals:
            value['sendAll'] = self._def_vals['sendAll']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleStatusRequest()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'dataType' in value:
            VehicleStatusDeviceTypeTag.validate(value['dataType'], errors, '{}/{}'.format(comp_path ,'dataType'))
        elif 'dataType' not in value:
            report_missing_field(type(self).__name__, 'dataType', errors, comp_path)
        if 'subType' in value:
            VehicleStatusRequest__2.validate(value['subType'], errors, '{}/{}'.format(comp_path ,'subType'))
        if 'sendOnLessThenValue' in value:
            DrivenLineOffsetLg.validate(value['sendOnLessThenValue'], errors, '{}/{}'.format(comp_path ,'sendOnLessThenValue'))
        if 'sendOnMoreThenValue' in value:
            DrivenLineOffsetLg.validate(value['sendOnMoreThenValue'], errors, '{}/{}'.format(comp_path ,'sendOnMoreThenValue'))
        if 'sendAll' in value:
            IsDolly.validate(value['sendAll'], errors, '{}/{}'.format(comp_path ,'sendAll'))

        return errors

class VehicleStatusRequest__2:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "1..15","permitted":[(1,15)]}}]
        self._unique_indetifier = "DSRC.VehicleStatusRequest.subType"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = VehicleStatusRequest__2()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 4
        data_map['width_value_unaligned'] = 4
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 1
        data_map['maximum'] = 15

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = VehicleStatusRequest__2()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 4
        data_map['width_value_unaligned'] = 4
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 1
        data_map['maximum'] = 15

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = VehicleStatusRequest__2()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class VehicleStatusRequestList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,32)]}}]
        self._unique_indetifier = "DSRC.VehicleStatusRequestList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                VehicleStatusRequest.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                VehicleStatusRequest.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(VehicleStatusRequest.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = VehicleStatusRequestList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(VehicleStatusRequest.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = VehicleStatusRequestList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 32
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = VehicleStatusRequestList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                VehicleStatusRequest.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class VehicleStatus:
    def __init__(self):
        self._comp_types = {"lights" : ExteriorLights, "lightBar" : LightbarInUse, "wipers" : WiperSet, "brakeStatus" : BrakeSystemStatus, "brakePressure" : BrakeAppliedPressure, "roadFriction" : CoefficientOfFriction, "sunData" : DriveAxleLiftAirPressure, "rainData" : RainSensor, "airTemp" : AmbientAirTemperature, "airPres" : AmbientAirPressure, "steering" : VehicleStatus__15, "accelSets" : VehicleStatus__21, "object" : VehicleStatus__25, "fullPos" : FullPositionVector, "throttlePos" : AttachmentRadius, "speedHeadC" : SpeedandHeadingandThrottleConfidence, "speedC" : SpeedConfidence, "vehicleData" : VehicleStatus__35, "vehicleIdent" : VehicleIdent, "j1939data" : J1939data, "weatherReport" : VehicleStatus__43, "gnssStatus" : GNSSstatus}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleStatus"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleStatus()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 22

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('lights' in value and 'lights' not in self._def_vals):
            preamble_bits[0] = True
        elif ('lights' in value and 'lights' in self._def_vals):
            if not value_tracker.are_def_eq(value['lights'], self._def_vals['lights'], self._comp_types['lights']):
                preamble_bits[0] = True
        if ('lightBar' in value and 'lightBar' not in self._def_vals):
            preamble_bits[1] = True
        elif ('lightBar' in value and 'lightBar' in self._def_vals):
            if not value_tracker.are_def_eq(value['lightBar'], self._def_vals['lightBar'], self._comp_types['lightBar']):
                preamble_bits[1] = True
        if ('wipers' in value and 'wipers' not in self._def_vals):
            preamble_bits[2] = True
        elif ('wipers' in value and 'wipers' in self._def_vals):
            if not value_tracker.are_def_eq(value['wipers'], self._def_vals['wipers'], self._comp_types['wipers']):
                preamble_bits[2] = True
        if ('brakeStatus' in value and 'brakeStatus' not in self._def_vals):
            preamble_bits[3] = True
        elif ('brakeStatus' in value and 'brakeStatus' in self._def_vals):
            if not value_tracker.are_def_eq(value['brakeStatus'], self._def_vals['brakeStatus'], self._comp_types['brakeStatus']):
                preamble_bits[3] = True
        if ('brakePressure' in value and 'brakePressure' not in self._def_vals):
            preamble_bits[4] = True
        elif ('brakePressure' in value and 'brakePressure' in self._def_vals):
            if not value_tracker.are_def_eq(value['brakePressure'], self._def_vals['brakePressure'], self._comp_types['brakePressure']):
                preamble_bits[4] = True
        if ('roadFriction' in value and 'roadFriction' not in self._def_vals):
            preamble_bits[5] = True
        elif ('roadFriction' in value and 'roadFriction' in self._def_vals):
            if not value_tracker.are_def_eq(value['roadFriction'], self._def_vals['roadFriction'], self._comp_types['roadFriction']):
                preamble_bits[5] = True
        if ('sunData' in value and 'sunData' not in self._def_vals):
            preamble_bits[6] = True
        elif ('sunData' in value and 'sunData' in self._def_vals):
            if not value_tracker.are_def_eq(value['sunData'], self._def_vals['sunData'], self._comp_types['sunData']):
                preamble_bits[6] = True
        if ('rainData' in value and 'rainData' not in self._def_vals):
            preamble_bits[7] = True
        elif ('rainData' in value and 'rainData' in self._def_vals):
            if not value_tracker.are_def_eq(value['rainData'], self._def_vals['rainData'], self._comp_types['rainData']):
                preamble_bits[7] = True
        if ('airTemp' in value and 'airTemp' not in self._def_vals):
            preamble_bits[8] = True
        elif ('airTemp' in value and 'airTemp' in self._def_vals):
            if not value_tracker.are_def_eq(value['airTemp'], self._def_vals['airTemp'], self._comp_types['airTemp']):
                preamble_bits[8] = True
        if ('airPres' in value and 'airPres' not in self._def_vals):
            preamble_bits[9] = True
        elif ('airPres' in value and 'airPres' in self._def_vals):
            if not value_tracker.are_def_eq(value['airPres'], self._def_vals['airPres'], self._comp_types['airPres']):
                preamble_bits[9] = True
        if ('steering' in value and 'steering' not in self._def_vals):
            preamble_bits[10] = True
        elif ('steering' in value and 'steering' in self._def_vals):
            if not value_tracker.are_def_eq(value['steering'], self._def_vals['steering'], self._comp_types['steering']):
                preamble_bits[10] = True
        if ('accelSets' in value and 'accelSets' not in self._def_vals):
            preamble_bits[11] = True
        elif ('accelSets' in value and 'accelSets' in self._def_vals):
            if not value_tracker.are_def_eq(value['accelSets'], self._def_vals['accelSets'], self._comp_types['accelSets']):
                preamble_bits[11] = True
        if ('object' in value and 'object' not in self._def_vals):
            preamble_bits[12] = True
        elif ('object' in value and 'object' in self._def_vals):
            if not value_tracker.are_def_eq(value['object'], self._def_vals['object'], self._comp_types['object']):
                preamble_bits[12] = True
        if ('fullPos' in value and 'fullPos' not in self._def_vals):
            preamble_bits[13] = True
        elif ('fullPos' in value and 'fullPos' in self._def_vals):
            if not value_tracker.are_def_eq(value['fullPos'], self._def_vals['fullPos'], self._comp_types['fullPos']):
                preamble_bits[13] = True
        if ('throttlePos' in value and 'throttlePos' not in self._def_vals):
            preamble_bits[14] = True
        elif ('throttlePos' in value and 'throttlePos' in self._def_vals):
            if not value_tracker.are_def_eq(value['throttlePos'], self._def_vals['throttlePos'], self._comp_types['throttlePos']):
                preamble_bits[14] = True
        if ('speedHeadC' in value and 'speedHeadC' not in self._def_vals):
            preamble_bits[15] = True
        elif ('speedHeadC' in value and 'speedHeadC' in self._def_vals):
            if not value_tracker.are_def_eq(value['speedHeadC'], self._def_vals['speedHeadC'], self._comp_types['speedHeadC']):
                preamble_bits[15] = True
        if ('speedC' in value and 'speedC' not in self._def_vals):
            preamble_bits[16] = True
        elif ('speedC' in value and 'speedC' in self._def_vals):
            if not value_tracker.are_def_eq(value['speedC'], self._def_vals['speedC'], self._comp_types['speedC']):
                preamble_bits[16] = True
        if ('vehicleData' in value and 'vehicleData' not in self._def_vals):
            preamble_bits[17] = True
        elif ('vehicleData' in value and 'vehicleData' in self._def_vals):
            if not value_tracker.are_def_eq(value['vehicleData'], self._def_vals['vehicleData'], self._comp_types['vehicleData']):
                preamble_bits[17] = True
        if ('vehicleIdent' in value and 'vehicleIdent' not in self._def_vals):
            preamble_bits[18] = True
        elif ('vehicleIdent' in value and 'vehicleIdent' in self._def_vals):
            if not value_tracker.are_def_eq(value['vehicleIdent'], self._def_vals['vehicleIdent'], self._comp_types['vehicleIdent']):
                preamble_bits[18] = True
        if ('j1939data' in value and 'j1939data' not in self._def_vals):
            preamble_bits[19] = True
        elif ('j1939data' in value and 'j1939data' in self._def_vals):
            if not value_tracker.are_def_eq(value['j1939data'], self._def_vals['j1939data'], self._comp_types['j1939data']):
                preamble_bits[19] = True
        if ('weatherReport' in value and 'weatherReport' not in self._def_vals):
            preamble_bits[20] = True
        elif ('weatherReport' in value and 'weatherReport' in self._def_vals):
            if not value_tracker.are_def_eq(value['weatherReport'], self._def_vals['weatherReport'], self._comp_types['weatherReport']):
                preamble_bits[20] = True
        if ('gnssStatus' in value and 'gnssStatus' not in self._def_vals):
            preamble_bits[21] = True
        elif ('gnssStatus' in value and 'gnssStatus' in self._def_vals):
            if not value_tracker.are_def_eq(value['gnssStatus'], self._def_vals['gnssStatus'], self._comp_types['gnssStatus']):
                preamble_bits[21] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            ExteriorLights.encode(encoding_rule, value['lights'], value_tracker, stream)
        if preamble_bits[2]:
            LightbarInUse.encode(encoding_rule, value['lightBar'], value_tracker, stream)
        if preamble_bits[3]:
            WiperSet.encode(encoding_rule, value['wipers'], value_tracker, stream)
        if preamble_bits[4]:
            BrakeSystemStatus.encode(encoding_rule, value['brakeStatus'], value_tracker, stream)
        if preamble_bits[5]:
            BrakeAppliedPressure.encode(encoding_rule, value['brakePressure'], value_tracker, stream)
        if preamble_bits[6]:
            CoefficientOfFriction.encode(encoding_rule, value['roadFriction'], value_tracker, stream)
        if preamble_bits[7]:
            DriveAxleLiftAirPressure.encode(encoding_rule, value['sunData'], value_tracker, stream)
        if preamble_bits[8]:
            RainSensor.encode(encoding_rule, value['rainData'], value_tracker, stream)
        if preamble_bits[9]:
            AmbientAirTemperature.encode(encoding_rule, value['airTemp'], value_tracker, stream)
        if preamble_bits[10]:
            AmbientAirPressure.encode(encoding_rule, value['airPres'], value_tracker, stream)
        if preamble_bits[11]:
            VehicleStatus__15.encode(encoding_rule, value['steering'], value_tracker, stream)
        if preamble_bits[12]:
            VehicleStatus__21.encode(encoding_rule, value['accelSets'], value_tracker, stream)
        if preamble_bits[13]:
            VehicleStatus__25.encode(encoding_rule, value['object'], value_tracker, stream)
        if preamble_bits[14]:
            FullPositionVector.encode(encoding_rule, value['fullPos'], value_tracker, stream)
        if preamble_bits[15]:
            AttachmentRadius.encode(encoding_rule, value['throttlePos'], value_tracker, stream)
        if preamble_bits[16]:
            SpeedandHeadingandThrottleConfidence.encode(encoding_rule, value['speedHeadC'], value_tracker, stream)
        if preamble_bits[17]:
            SpeedConfidence.encode(encoding_rule, value['speedC'], value_tracker, stream)
        if preamble_bits[18]:
            VehicleStatus__35.encode(encoding_rule, value['vehicleData'], value_tracker, stream)
        if preamble_bits[19]:
            VehicleIdent.encode(encoding_rule, value['vehicleIdent'], value_tracker, stream)
        if preamble_bits[20]:
            J1939data.encode(encoding_rule, value['j1939data'], value_tracker, stream)
        if preamble_bits[21]:
            VehicleStatus__43.encode(encoding_rule, value['weatherReport'], value_tracker, stream)
        if preamble_bits[22]:
            GNSSstatus.encode(encoding_rule, value['gnssStatus'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleStatus()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 22

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['lights'] = ExteriorLights.decode(encoding_rule, stream, value_tracker)
        elif 'lights' in self._def_vals:
            value['lights'] = self._def_vals['lights']
        if preamble_bits[2]:
            value['lightBar'] = LightbarInUse.decode(encoding_rule, stream, value_tracker)
        elif 'lightBar' in self._def_vals:
            value['lightBar'] = self._def_vals['lightBar']
        if preamble_bits[3]:
            value['wipers'] = WiperSet.decode(encoding_rule, stream, value_tracker)
        elif 'wipers' in self._def_vals:
            value['wipers'] = self._def_vals['wipers']
        if preamble_bits[4]:
            value['brakeStatus'] = BrakeSystemStatus.decode(encoding_rule, stream, value_tracker)
        elif 'brakeStatus' in self._def_vals:
            value['brakeStatus'] = self._def_vals['brakeStatus']
        if preamble_bits[5]:
            value['brakePressure'] = BrakeAppliedPressure.decode(encoding_rule, stream, value_tracker)
        elif 'brakePressure' in self._def_vals:
            value['brakePressure'] = self._def_vals['brakePressure']
        if preamble_bits[6]:
            value['roadFriction'] = CoefficientOfFriction.decode(encoding_rule, stream, value_tracker)
        elif 'roadFriction' in self._def_vals:
            value['roadFriction'] = self._def_vals['roadFriction']
        if preamble_bits[7]:
            value['sunData'] = DriveAxleLiftAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'sunData' in self._def_vals:
            value['sunData'] = self._def_vals['sunData']
        if preamble_bits[8]:
            value['rainData'] = RainSensor.decode(encoding_rule, stream, value_tracker)
        elif 'rainData' in self._def_vals:
            value['rainData'] = self._def_vals['rainData']
        if preamble_bits[9]:
            value['airTemp'] = AmbientAirTemperature.decode(encoding_rule, stream, value_tracker)
        elif 'airTemp' in self._def_vals:
            value['airTemp'] = self._def_vals['airTemp']
        if preamble_bits[10]:
            value['airPres'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'airPres' in self._def_vals:
            value['airPres'] = self._def_vals['airPres']
        if preamble_bits[11]:
            value['steering'] = VehicleStatus__15.decode(encoding_rule, stream, value_tracker)
        elif 'steering' in self._def_vals:
            value['steering'] = self._def_vals['steering']
        if preamble_bits[12]:
            value['accelSets'] = VehicleStatus__21.decode(encoding_rule, stream, value_tracker)
        elif 'accelSets' in self._def_vals:
            value['accelSets'] = self._def_vals['accelSets']
        if preamble_bits[13]:
            value['object'] = VehicleStatus__25.decode(encoding_rule, stream, value_tracker)
        elif 'object' in self._def_vals:
            value['object'] = self._def_vals['object']
        if preamble_bits[14]:
            value['fullPos'] = FullPositionVector.decode(encoding_rule, stream, value_tracker)
        elif 'fullPos' in self._def_vals:
            value['fullPos'] = self._def_vals['fullPos']
        if preamble_bits[15]:
            value['throttlePos'] = AttachmentRadius.decode(encoding_rule, stream, value_tracker)
        elif 'throttlePos' in self._def_vals:
            value['throttlePos'] = self._def_vals['throttlePos']
        if preamble_bits[16]:
            value['speedHeadC'] = SpeedandHeadingandThrottleConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'speedHeadC' in self._def_vals:
            value['speedHeadC'] = self._def_vals['speedHeadC']
        if preamble_bits[17]:
            value['speedC'] = SpeedConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'speedC' in self._def_vals:
            value['speedC'] = self._def_vals['speedC']
        if preamble_bits[18]:
            value['vehicleData'] = VehicleStatus__35.decode(encoding_rule, stream, value_tracker)
        elif 'vehicleData' in self._def_vals:
            value['vehicleData'] = self._def_vals['vehicleData']
        if preamble_bits[19]:
            value['vehicleIdent'] = VehicleIdent.decode(encoding_rule, stream, value_tracker)
        elif 'vehicleIdent' in self._def_vals:
            value['vehicleIdent'] = self._def_vals['vehicleIdent']
        if preamble_bits[20]:
            value['j1939data'] = J1939data.decode(encoding_rule, stream, value_tracker)
        elif 'j1939data' in self._def_vals:
            value['j1939data'] = self._def_vals['j1939data']
        if preamble_bits[21]:
            value['weatherReport'] = VehicleStatus__43.decode(encoding_rule, stream, value_tracker)
        elif 'weatherReport' in self._def_vals:
            value['weatherReport'] = self._def_vals['weatherReport']
        if preamble_bits[22]:
            value['gnssStatus'] = GNSSstatus.decode(encoding_rule, stream, value_tracker)
        elif 'gnssStatus' in self._def_vals:
            value['gnssStatus'] = self._def_vals['gnssStatus']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleStatus()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lights' in value:
            ExteriorLights.validate(value['lights'], errors, '{}/{}'.format(comp_path ,'lights'))
        if 'lightBar' in value:
            LightbarInUse.validate(value['lightBar'], errors, '{}/{}'.format(comp_path ,'lightBar'))
        if 'wipers' in value:
            WiperSet.validate(value['wipers'], errors, '{}/{}'.format(comp_path ,'wipers'))
        if 'brakeStatus' in value:
            BrakeSystemStatus.validate(value['brakeStatus'], errors, '{}/{}'.format(comp_path ,'brakeStatus'))
        if 'brakePressure' in value:
            BrakeAppliedPressure.validate(value['brakePressure'], errors, '{}/{}'.format(comp_path ,'brakePressure'))
        if 'roadFriction' in value:
            CoefficientOfFriction.validate(value['roadFriction'], errors, '{}/{}'.format(comp_path ,'roadFriction'))
        if 'sunData' in value:
            DriveAxleLiftAirPressure.validate(value['sunData'], errors, '{}/{}'.format(comp_path ,'sunData'))
        if 'rainData' in value:
            RainSensor.validate(value['rainData'], errors, '{}/{}'.format(comp_path ,'rainData'))
        if 'airTemp' in value:
            AmbientAirTemperature.validate(value['airTemp'], errors, '{}/{}'.format(comp_path ,'airTemp'))
        if 'airPres' in value:
            AmbientAirPressure.validate(value['airPres'], errors, '{}/{}'.format(comp_path ,'airPres'))
        if 'steering' in value:
            VehicleStatus__15.validate(value['steering'], errors, '{}/{}'.format(comp_path ,'steering'))
        if 'accelSets' in value:
            VehicleStatus__21.validate(value['accelSets'], errors, '{}/{}'.format(comp_path ,'accelSets'))
        if 'object' in value:
            VehicleStatus__25.validate(value['object'], errors, '{}/{}'.format(comp_path ,'object'))
        if 'fullPos' in value:
            FullPositionVector.validate(value['fullPos'], errors, '{}/{}'.format(comp_path ,'fullPos'))
        if 'throttlePos' in value:
            AttachmentRadius.validate(value['throttlePos'], errors, '{}/{}'.format(comp_path ,'throttlePos'))
        if 'speedHeadC' in value:
            SpeedandHeadingandThrottleConfidence.validate(value['speedHeadC'], errors, '{}/{}'.format(comp_path ,'speedHeadC'))
        if 'speedC' in value:
            SpeedConfidence.validate(value['speedC'], errors, '{}/{}'.format(comp_path ,'speedC'))
        if 'vehicleData' in value:
            VehicleStatus__35.validate(value['vehicleData'], errors, '{}/{}'.format(comp_path ,'vehicleData'))
        if 'vehicleIdent' in value:
            VehicleIdent.validate(value['vehicleIdent'], errors, '{}/{}'.format(comp_path ,'vehicleIdent'))
        if 'j1939data' in value:
            J1939data.validate(value['j1939data'], errors, '{}/{}'.format(comp_path ,'j1939data'))
        if 'weatherReport' in value:
            VehicleStatus__43.validate(value['weatherReport'], errors, '{}/{}'.format(comp_path ,'weatherReport'))
        if 'gnssStatus' in value:
            GNSSstatus.validate(value['gnssStatus'], errors, '{}/{}'.format(comp_path ,'gnssStatus'))

        return errors

class VehicleStatus__15:
    def __init__(self):
        self._comp_types = {"angle" : SteeringWheelAngle, "confidence" : SteeringWheelAngleConfidence, "rate" : SteeringWheelAngleRateOfChange, "wheels" : DrivingWheelAngle}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleStatus.steering"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleStatus__15()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('confidence' in value and 'confidence' not in self._def_vals):
            preamble_bits[0] = True
        elif ('confidence' in value and 'confidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['confidence'], self._def_vals['confidence'], self._comp_types['confidence']):
                preamble_bits[0] = True
        if ('rate' in value and 'rate' not in self._def_vals):
            preamble_bits[1] = True
        elif ('rate' in value and 'rate' in self._def_vals):
            if not value_tracker.are_def_eq(value['rate'], self._def_vals['rate'], self._comp_types['rate']):
                preamble_bits[1] = True
        if ('wheels' in value and 'wheels' not in self._def_vals):
            preamble_bits[2] = True
        elif ('wheels' in value and 'wheels' in self._def_vals):
            if not value_tracker.are_def_eq(value['wheels'], self._def_vals['wheels'], self._comp_types['wheels']):
                preamble_bits[2] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'angle' in value:
            SteeringWheelAngle.encode(encoding_rule, value['angle'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            SteeringWheelAngleConfidence.encode(encoding_rule, value['confidence'], value_tracker, stream)
        if preamble_bits[1]:
            SteeringWheelAngleRateOfChange.encode(encoding_rule, value['rate'], value_tracker, stream)
        if preamble_bits[2]:
            DrivingWheelAngle.encode(encoding_rule, value['wheels'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleStatus__15()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['angle'] = SteeringWheelAngle.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['confidence'] = SteeringWheelAngleConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'confidence' in self._def_vals:
            value['confidence'] = self._def_vals['confidence']
        if preamble_bits[1]:
            value['rate'] = SteeringWheelAngleRateOfChange.decode(encoding_rule, stream, value_tracker)
        elif 'rate' in self._def_vals:
            value['rate'] = self._def_vals['rate']
        if preamble_bits[2]:
            value['wheels'] = DrivingWheelAngle.decode(encoding_rule, stream, value_tracker)
        elif 'wheels' in self._def_vals:
            value['wheels'] = self._def_vals['wheels']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleStatus__15()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'angle' in value:
            SteeringWheelAngle.validate(value['angle'], errors, '{}/{}'.format(comp_path ,'angle'))
        elif 'angle' not in value:
            report_missing_field(type(self).__name__, 'angle', errors, comp_path)
        if 'confidence' in value:
            SteeringWheelAngleConfidence.validate(value['confidence'], errors, '{}/{}'.format(comp_path ,'confidence'))
        if 'rate' in value:
            SteeringWheelAngleRateOfChange.validate(value['rate'], errors, '{}/{}'.format(comp_path ,'rate'))
        if 'wheels' in value:
            DrivingWheelAngle.validate(value['wheels'], errors, '{}/{}'.format(comp_path ,'wheels'))

        return errors

class VehicleStatus__21:
    def __init__(self):
        self._comp_types = {"accel4way" : AccelerationSet4Way, "vertAccelThres" : BrakeAppliedStatus, "yawRateCon" : YawRateConfidence, "hozAccelCon" : AccelerationConfidence, "confidenceSet" : ConfidenceSet}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleStatus.accelSets"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleStatus__21()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('accel4way' in value and 'accel4way' not in self._def_vals):
            preamble_bits[0] = True
        elif ('accel4way' in value and 'accel4way' in self._def_vals):
            if not value_tracker.are_def_eq(value['accel4way'], self._def_vals['accel4way'], self._comp_types['accel4way']):
                preamble_bits[0] = True
        if ('vertAccelThres' in value and 'vertAccelThres' not in self._def_vals):
            preamble_bits[1] = True
        elif ('vertAccelThres' in value and 'vertAccelThres' in self._def_vals):
            if not value_tracker.are_def_eq(value['vertAccelThres'], self._def_vals['vertAccelThres'], self._comp_types['vertAccelThres']):
                preamble_bits[1] = True
        if ('yawRateCon' in value and 'yawRateCon' not in self._def_vals):
            preamble_bits[2] = True
        elif ('yawRateCon' in value and 'yawRateCon' in self._def_vals):
            if not value_tracker.are_def_eq(value['yawRateCon'], self._def_vals['yawRateCon'], self._comp_types['yawRateCon']):
                preamble_bits[2] = True
        if ('hozAccelCon' in value and 'hozAccelCon' not in self._def_vals):
            preamble_bits[3] = True
        elif ('hozAccelCon' in value and 'hozAccelCon' in self._def_vals):
            if not value_tracker.are_def_eq(value['hozAccelCon'], self._def_vals['hozAccelCon'], self._comp_types['hozAccelCon']):
                preamble_bits[3] = True
        if ('confidenceSet' in value and 'confidenceSet' not in self._def_vals):
            preamble_bits[4] = True
        elif ('confidenceSet' in value and 'confidenceSet' in self._def_vals):
            if not value_tracker.are_def_eq(value['confidenceSet'], self._def_vals['confidenceSet'], self._comp_types['confidenceSet']):
                preamble_bits[4] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[0]:
            AccelerationSet4Way.encode(encoding_rule, value['accel4way'], value_tracker, stream)
        if preamble_bits[1]:
            BrakeAppliedStatus.encode(encoding_rule, value['vertAccelThres'], value_tracker, stream)
        if preamble_bits[2]:
            YawRateConfidence.encode(encoding_rule, value['yawRateCon'], value_tracker, stream)
        if preamble_bits[3]:
            AccelerationConfidence.encode(encoding_rule, value['hozAccelCon'], value_tracker, stream)
        if preamble_bits[4]:
            ConfidenceSet.encode(encoding_rule, value['confidenceSet'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleStatus__21()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[0]:
            value['accel4way'] = AccelerationSet4Way.decode(encoding_rule, stream, value_tracker)
        elif 'accel4way' in self._def_vals:
            value['accel4way'] = self._def_vals['accel4way']
        if preamble_bits[1]:
            value['vertAccelThres'] = BrakeAppliedStatus.decode(encoding_rule, stream, value_tracker)
        elif 'vertAccelThres' in self._def_vals:
            value['vertAccelThres'] = self._def_vals['vertAccelThres']
        if preamble_bits[2]:
            value['yawRateCon'] = YawRateConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'yawRateCon' in self._def_vals:
            value['yawRateCon'] = self._def_vals['yawRateCon']
        if preamble_bits[3]:
            value['hozAccelCon'] = AccelerationConfidence.decode(encoding_rule, stream, value_tracker)
        elif 'hozAccelCon' in self._def_vals:
            value['hozAccelCon'] = self._def_vals['hozAccelCon']
        if preamble_bits[4]:
            value['confidenceSet'] = ConfidenceSet.decode(encoding_rule, stream, value_tracker)
        elif 'confidenceSet' in self._def_vals:
            value['confidenceSet'] = self._def_vals['confidenceSet']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleStatus__21()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'accel4way' in value:
            AccelerationSet4Way.validate(value['accel4way'], errors, '{}/{}'.format(comp_path ,'accel4way'))
        if 'vertAccelThres' in value:
            BrakeAppliedStatus.validate(value['vertAccelThres'], errors, '{}/{}'.format(comp_path ,'vertAccelThres'))
        if 'yawRateCon' in value:
            YawRateConfidence.validate(value['yawRateCon'], errors, '{}/{}'.format(comp_path ,'yawRateCon'))
        if 'hozAccelCon' in value:
            AccelerationConfidence.validate(value['hozAccelCon'], errors, '{}/{}'.format(comp_path ,'hozAccelCon'))
        if 'confidenceSet' in value:
            ConfidenceSet.validate(value['confidenceSet'], errors, '{}/{}'.format(comp_path ,'confidenceSet'))

        return errors

class VehicleStatus__25:
    def __init__(self):
        self._comp_types = {"obDist" : DSRCmsgID, "obDirect" : Angle, "dateTime" : DDateTime}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleStatus.object"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleStatus__25()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'obDist' in value:
            DSRCmsgID.encode(encoding_rule, value['obDist'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'obDirect' in value:
            Angle.encode(encoding_rule, value['obDirect'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'dateTime' in value:
            DDateTime.encode(encoding_rule, value['dateTime'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleStatus__25()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['obDist'] = DSRCmsgID.decode(encoding_rule, stream, value_tracker)
        value['obDirect'] = Angle.decode(encoding_rule, stream, value_tracker)
        value['dateTime'] = DDateTime.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleStatus__25()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'obDist' in value:
            DSRCmsgID.validate(value['obDist'], errors, '{}/{}'.format(comp_path ,'obDist'))
        elif 'obDist' not in value:
            report_missing_field(type(self).__name__, 'obDist', errors, comp_path)
        if 'obDirect' in value:
            Angle.validate(value['obDirect'], errors, '{}/{}'.format(comp_path ,'obDirect'))
        elif 'obDirect' not in value:
            report_missing_field(type(self).__name__, 'obDirect', errors, comp_path)
        if 'dateTime' in value:
            DDateTime.validate(value['dateTime'], errors, '{}/{}'.format(comp_path ,'dateTime'))
        elif 'dateTime' not in value:
            report_missing_field(type(self).__name__, 'dateTime', errors, comp_path)

        return errors

class VehicleStatus__35:
    def __init__(self):
        self._comp_types = {"height" : BumperHeight, "bumpers" : BumperHeights, "mass" : AmbientAirPressure, "trailerWeight" : AxleWeight, "type" : VehicleType}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleStatus.vehicleData"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleStatus__35()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'height' in value:
            BumperHeight.encode(encoding_rule, value['height'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'bumpers' in value:
            BumperHeights.encode(encoding_rule, value['bumpers'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'mass' in value:
            AmbientAirPressure.encode(encoding_rule, value['mass'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'trailerWeight' in value:
            AxleWeight.encode(encoding_rule, value['trailerWeight'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'type' in value:
            VehicleType.encode(encoding_rule, value['type'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleStatus__35()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['height'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        value['bumpers'] = BumperHeights.decode(encoding_rule, stream, value_tracker)
        value['mass'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['trailerWeight'] = AxleWeight.decode(encoding_rule, stream, value_tracker)
        value['type'] = VehicleType.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleStatus__35()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'height' in value:
            BumperHeight.validate(value['height'], errors, '{}/{}'.format(comp_path ,'height'))
        elif 'height' not in value:
            report_missing_field(type(self).__name__, 'height', errors, comp_path)
        if 'bumpers' in value:
            BumperHeights.validate(value['bumpers'], errors, '{}/{}'.format(comp_path ,'bumpers'))
        elif 'bumpers' not in value:
            report_missing_field(type(self).__name__, 'bumpers', errors, comp_path)
        if 'mass' in value:
            AmbientAirPressure.validate(value['mass'], errors, '{}/{}'.format(comp_path ,'mass'))
        elif 'mass' not in value:
            report_missing_field(type(self).__name__, 'mass', errors, comp_path)
        if 'trailerWeight' in value:
            AxleWeight.validate(value['trailerWeight'], errors, '{}/{}'.format(comp_path ,'trailerWeight'))
        elif 'trailerWeight' not in value:
            report_missing_field(type(self).__name__, 'trailerWeight', errors, comp_path)
        if 'type' in value:
            VehicleType.validate(value['type'], errors, '{}/{}'.format(comp_path ,'type'))
        elif 'type' not in value:
            report_missing_field(type(self).__name__, 'type', errors, comp_path)

        return errors

class VehicleStatus__43:
    def __init__(self):
        self._comp_types = {"isRaining" : EssPrecipYesNo, "rainRate" : DSecond, "precipSituation" : EssPrecipSituation, "solarRadiation" : DSecond, "friction" : EssMobileFriction}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleStatus.weatherReport"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleStatus__43()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('rainRate' in value and 'rainRate' not in self._def_vals):
            preamble_bits[0] = True
        elif ('rainRate' in value and 'rainRate' in self._def_vals):
            if not value_tracker.are_def_eq(value['rainRate'], self._def_vals['rainRate'], self._comp_types['rainRate']):
                preamble_bits[0] = True
        if ('precipSituation' in value and 'precipSituation' not in self._def_vals):
            preamble_bits[1] = True
        elif ('precipSituation' in value and 'precipSituation' in self._def_vals):
            if not value_tracker.are_def_eq(value['precipSituation'], self._def_vals['precipSituation'], self._comp_types['precipSituation']):
                preamble_bits[1] = True
        if ('solarRadiation' in value and 'solarRadiation' not in self._def_vals):
            preamble_bits[2] = True
        elif ('solarRadiation' in value and 'solarRadiation' in self._def_vals):
            if not value_tracker.are_def_eq(value['solarRadiation'], self._def_vals['solarRadiation'], self._comp_types['solarRadiation']):
                preamble_bits[2] = True
        if ('friction' in value and 'friction' not in self._def_vals):
            preamble_bits[3] = True
        elif ('friction' in value and 'friction' in self._def_vals):
            if not value_tracker.are_def_eq(value['friction'], self._def_vals['friction'], self._comp_types['friction']):
                preamble_bits[3] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'isRaining' in value:
            EssPrecipYesNo.encode(encoding_rule, value['isRaining'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            DSecond.encode(encoding_rule, value['rainRate'], value_tracker, stream)
        if preamble_bits[1]:
            EssPrecipSituation.encode(encoding_rule, value['precipSituation'], value_tracker, stream)
        if preamble_bits[2]:
            DSecond.encode(encoding_rule, value['solarRadiation'], value_tracker, stream)
        if preamble_bits[3]:
            EssMobileFriction.encode(encoding_rule, value['friction'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleStatus__43()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 4

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['isRaining'] = EssPrecipYesNo.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['rainRate'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'rainRate' in self._def_vals:
            value['rainRate'] = self._def_vals['rainRate']
        if preamble_bits[1]:
            value['precipSituation'] = EssPrecipSituation.decode(encoding_rule, stream, value_tracker)
        elif 'precipSituation' in self._def_vals:
            value['precipSituation'] = self._def_vals['precipSituation']
        if preamble_bits[2]:
            value['solarRadiation'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'solarRadiation' in self._def_vals:
            value['solarRadiation'] = self._def_vals['solarRadiation']
        if preamble_bits[3]:
            value['friction'] = EssMobileFriction.decode(encoding_rule, stream, value_tracker)
        elif 'friction' in self._def_vals:
            value['friction'] = self._def_vals['friction']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleStatus__43()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'isRaining' in value:
            EssPrecipYesNo.validate(value['isRaining'], errors, '{}/{}'.format(comp_path ,'isRaining'))
        elif 'isRaining' not in value:
            report_missing_field(type(self).__name__, 'isRaining', errors, comp_path)
        if 'rainRate' in value:
            DSecond.validate(value['rainRate'], errors, '{}/{}'.format(comp_path ,'rainRate'))
        if 'precipSituation' in value:
            EssPrecipSituation.validate(value['precipSituation'], errors, '{}/{}'.format(comp_path ,'precipSituation'))
        if 'solarRadiation' in value:
            DSecond.validate(value['solarRadiation'], errors, '{}/{}'.format(comp_path ,'solarRadiation'))
        if 'friction' in value:
            EssMobileFriction.validate(value['friction'], errors, '{}/{}'.format(comp_path ,'friction'))

        return errors

class VerticalOffset:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.VerticalOffset"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"offset1": 0, "offset2": 1, "offset3": 2, "offset4": 3, "offset5": 4, "offset6": 5, "elevation": 6, "regional": 7}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = VerticalOffset()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 8
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'offset1':
                VertOffset_B07.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'offset2':
                DrivingWheelAngle.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'offset3':
                Offset_B09.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'offset4':
                Offset_B10.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'offset5':
                Offset_B11.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'offset6':
                Offset_B12.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'elevation':
                Elevation.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'regional':
                RegionalExtension_1.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = VerticalOffset()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 8
        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'offset1':
                alternative = VertOffset_B07.decode(encoding_rule, stream, value_tracker)
            if identifier == 'offset2':
                alternative = DrivingWheelAngle.decode(encoding_rule, stream, value_tracker)
            if identifier == 'offset3':
                alternative = Offset_B09.decode(encoding_rule, stream, value_tracker)
            if identifier == 'offset4':
                alternative = Offset_B10.decode(encoding_rule, stream, value_tracker)
            if identifier == 'offset5':
                alternative = Offset_B11.decode(encoding_rule, stream, value_tracker)
            if identifier == 'offset6':
                alternative = Offset_B12.decode(encoding_rule, stream, value_tracker)
            if identifier == 'elevation':
                alternative = Elevation.decode(encoding_rule, stream, value_tracker)
            if identifier == 'regional':
                alternative = RegionalExtension_1.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = VerticalOffset()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'offset1' in value:
            VertOffset_B07.validate(value['offset1'], errors, '{}/{}'.format(comp_path ,'offset1'))
            is_checked = True
        if 'offset2' in value:
            DrivingWheelAngle.validate(value['offset2'], errors, '{}/{}'.format(comp_path ,'offset2'))
            is_checked = True
        if 'offset3' in value:
            Offset_B09.validate(value['offset3'], errors, '{}/{}'.format(comp_path ,'offset3'))
            is_checked = True
        if 'offset4' in value:
            Offset_B10.validate(value['offset4'], errors, '{}/{}'.format(comp_path ,'offset4'))
            is_checked = True
        if 'offset5' in value:
            Offset_B11.validate(value['offset5'], errors, '{}/{}'.format(comp_path ,'offset5'))
            is_checked = True
        if 'offset6' in value:
            Offset_B12.validate(value['offset6'], errors, '{}/{}'.format(comp_path ,'offset6'))
            is_checked = True
        if 'elevation' in value:
            Elevation.validate(value['elevation'], errors, '{}/{}'.format(comp_path ,'elevation'))
            is_checked = True
        if 'regional' in value:
            RegionalExtension_1.validate(value['regional'], errors, '{}/{}'.format(comp_path ,'regional'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class WeatherProbe:
    def __init__(self):
        self._comp_types = {"airTemp" : AmbientAirTemperature, "airPressure" : AmbientAirPressure, "rainRates" : WiperSet}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.WeatherProbe"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = WeatherProbe()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('airTemp' in value and 'airTemp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('airTemp' in value and 'airTemp' in self._def_vals):
            if not value_tracker.are_def_eq(value['airTemp'], self._def_vals['airTemp'], self._comp_types['airTemp']):
                preamble_bits[0] = True
        if ('airPressure' in value and 'airPressure' not in self._def_vals):
            preamble_bits[1] = True
        elif ('airPressure' in value and 'airPressure' in self._def_vals):
            if not value_tracker.are_def_eq(value['airPressure'], self._def_vals['airPressure'], self._comp_types['airPressure']):
                preamble_bits[1] = True
        if ('rainRates' in value and 'rainRates' not in self._def_vals):
            preamble_bits[2] = True
        elif ('rainRates' in value and 'rainRates' in self._def_vals):
            if not value_tracker.are_def_eq(value['rainRates'], self._def_vals['rainRates'], self._comp_types['rainRates']):
                preamble_bits[2] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            AmbientAirTemperature.encode(encoding_rule, value['airTemp'], value_tracker, stream)
        if preamble_bits[2]:
            AmbientAirPressure.encode(encoding_rule, value['airPressure'], value_tracker, stream)
        if preamble_bits[3]:
            WiperSet.encode(encoding_rule, value['rainRates'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = WeatherProbe()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['airTemp'] = AmbientAirTemperature.decode(encoding_rule, stream, value_tracker)
        elif 'airTemp' in self._def_vals:
            value['airTemp'] = self._def_vals['airTemp']
        if preamble_bits[2]:
            value['airPressure'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        elif 'airPressure' in self._def_vals:
            value['airPressure'] = self._def_vals['airPressure']
        if preamble_bits[3]:
            value['rainRates'] = WiperSet.decode(encoding_rule, stream, value_tracker)
        elif 'rainRates' in self._def_vals:
            value['rainRates'] = self._def_vals['rainRates']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = WeatherProbe()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'airTemp' in value:
            AmbientAirTemperature.validate(value['airTemp'], errors, '{}/{}'.format(comp_path ,'airTemp'))
        if 'airPressure' in value:
            AmbientAirPressure.validate(value['airPressure'], errors, '{}/{}'.format(comp_path ,'airPressure'))
        if 'rainRates' in value:
            WiperSet.validate(value['rainRates'], errors, '{}/{}'.format(comp_path ,'rainRates'))

        return errors

class WeatherReport:
    def __init__(self):
        self._comp_types = {"isRaining" : EssPrecipYesNo, "rainRate" : DSecond, "precipSituation" : EssPrecipSituation, "solarRadiation" : DSecond, "friction" : EssMobileFriction, "roadFriction" : CoefficientOfFriction}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.WeatherReport"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = WeatherReport()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('rainRate' in value and 'rainRate' not in self._def_vals):
            preamble_bits[0] = True
        elif ('rainRate' in value and 'rainRate' in self._def_vals):
            if not value_tracker.are_def_eq(value['rainRate'], self._def_vals['rainRate'], self._comp_types['rainRate']):
                preamble_bits[0] = True
        if ('precipSituation' in value and 'precipSituation' not in self._def_vals):
            preamble_bits[1] = True
        elif ('precipSituation' in value and 'precipSituation' in self._def_vals):
            if not value_tracker.are_def_eq(value['precipSituation'], self._def_vals['precipSituation'], self._comp_types['precipSituation']):
                preamble_bits[1] = True
        if ('solarRadiation' in value and 'solarRadiation' not in self._def_vals):
            preamble_bits[2] = True
        elif ('solarRadiation' in value and 'solarRadiation' in self._def_vals):
            if not value_tracker.are_def_eq(value['solarRadiation'], self._def_vals['solarRadiation'], self._comp_types['solarRadiation']):
                preamble_bits[2] = True
        if ('friction' in value and 'friction' not in self._def_vals):
            preamble_bits[3] = True
        elif ('friction' in value and 'friction' in self._def_vals):
            if not value_tracker.are_def_eq(value['friction'], self._def_vals['friction'], self._comp_types['friction']):
                preamble_bits[3] = True
        if ('roadFriction' in value and 'roadFriction' not in self._def_vals):
            preamble_bits[4] = True
        elif ('roadFriction' in value and 'roadFriction' in self._def_vals):
            if not value_tracker.are_def_eq(value['roadFriction'], self._def_vals['roadFriction'], self._comp_types['roadFriction']):
                preamble_bits[4] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'isRaining' in value:
            EssPrecipYesNo.encode(encoding_rule, value['isRaining'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[1]:
            DSecond.encode(encoding_rule, value['rainRate'], value_tracker, stream)
        if preamble_bits[2]:
            EssPrecipSituation.encode(encoding_rule, value['precipSituation'], value_tracker, stream)
        if preamble_bits[3]:
            DSecond.encode(encoding_rule, value['solarRadiation'], value_tracker, stream)
        if preamble_bits[4]:
            EssMobileFriction.encode(encoding_rule, value['friction'], value_tracker, stream)
        if preamble_bits[5]:
            CoefficientOfFriction.encode(encoding_rule, value['roadFriction'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = WeatherReport()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['isRaining'] = EssPrecipYesNo.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[1]:
            value['rainRate'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'rainRate' in self._def_vals:
            value['rainRate'] = self._def_vals['rainRate']
        if preamble_bits[2]:
            value['precipSituation'] = EssPrecipSituation.decode(encoding_rule, stream, value_tracker)
        elif 'precipSituation' in self._def_vals:
            value['precipSituation'] = self._def_vals['precipSituation']
        if preamble_bits[3]:
            value['solarRadiation'] = DSecond.decode(encoding_rule, stream, value_tracker)
        elif 'solarRadiation' in self._def_vals:
            value['solarRadiation'] = self._def_vals['solarRadiation']
        if preamble_bits[4]:
            value['friction'] = EssMobileFriction.decode(encoding_rule, stream, value_tracker)
        elif 'friction' in self._def_vals:
            value['friction'] = self._def_vals['friction']
        if preamble_bits[5]:
            value['roadFriction'] = CoefficientOfFriction.decode(encoding_rule, stream, value_tracker)
        elif 'roadFriction' in self._def_vals:
            value['roadFriction'] = self._def_vals['roadFriction']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = WeatherReport()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'isRaining' in value:
            EssPrecipYesNo.validate(value['isRaining'], errors, '{}/{}'.format(comp_path ,'isRaining'))
        elif 'isRaining' not in value:
            report_missing_field(type(self).__name__, 'isRaining', errors, comp_path)
        if 'rainRate' in value:
            DSecond.validate(value['rainRate'], errors, '{}/{}'.format(comp_path ,'rainRate'))
        if 'precipSituation' in value:
            EssPrecipSituation.validate(value['precipSituation'], errors, '{}/{}'.format(comp_path ,'precipSituation'))
        if 'solarRadiation' in value:
            DSecond.validate(value['solarRadiation'], errors, '{}/{}'.format(comp_path ,'solarRadiation'))
        if 'friction' in value:
            EssMobileFriction.validate(value['friction'], errors, '{}/{}'.format(comp_path ,'friction'))
        if 'roadFriction' in value:
            CoefficientOfFriction.validate(value['roadFriction'], errors, '{}/{}'.format(comp_path ,'roadFriction'))

        return errors

class WiperSet:
    def __init__(self):
        self._comp_types = {"statusFront" : WiperStatus, "rateFront" : BumperHeight, "statusRear" : WiperStatus, "rateRear" : BumperHeight}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.WiperSet"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = WiperSet()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('statusRear' in value and 'statusRear' not in self._def_vals):
            preamble_bits[0] = True
        elif ('statusRear' in value and 'statusRear' in self._def_vals):
            if not value_tracker.are_def_eq(value['statusRear'], self._def_vals['statusRear'], self._comp_types['statusRear']):
                preamble_bits[0] = True
        if ('rateRear' in value and 'rateRear' not in self._def_vals):
            preamble_bits[1] = True
        elif ('rateRear' in value and 'rateRear' in self._def_vals):
            if not value_tracker.are_def_eq(value['rateRear'], self._def_vals['rateRear'], self._comp_types['rateRear']):
                preamble_bits[1] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'statusFront' in value:
            WiperStatus.encode(encoding_rule, value['statusFront'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'rateFront' in value:
            BumperHeight.encode(encoding_rule, value['rateFront'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            WiperStatus.encode(encoding_rule, value['statusRear'], value_tracker, stream)
        if preamble_bits[1]:
            BumperHeight.encode(encoding_rule, value['rateRear'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = WiperSet()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['statusFront'] = WiperStatus.decode(encoding_rule, stream, value_tracker)
        value['rateFront'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['statusRear'] = WiperStatus.decode(encoding_rule, stream, value_tracker)
        elif 'statusRear' in self._def_vals:
            value['statusRear'] = self._def_vals['statusRear']
        if preamble_bits[1]:
            value['rateRear'] = BumperHeight.decode(encoding_rule, stream, value_tracker)
        elif 'rateRear' in self._def_vals:
            value['rateRear'] = self._def_vals['rateRear']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = WiperSet()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'statusFront' in value:
            WiperStatus.validate(value['statusFront'], errors, '{}/{}'.format(comp_path ,'statusFront'))
        elif 'statusFront' not in value:
            report_missing_field(type(self).__name__, 'statusFront', errors, comp_path)
        if 'rateFront' in value:
            BumperHeight.validate(value['rateFront'], errors, '{}/{}'.format(comp_path ,'rateFront'))
        elif 'rateFront' not in value:
            report_missing_field(type(self).__name__, 'rateFront', errors, comp_path)
        if 'statusRear' in value:
            WiperStatus.validate(value['statusRear'], errors, '{}/{}'.format(comp_path ,'statusRear'))
        if 'rateRear' in value:
            BumperHeight.validate(value['rateRear'], errors, '{}/{}'.format(comp_path ,'rateRear'))

        return errors

class Acceleration:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-2000..2001","permitted":[(-2000,2001)]}}]
        self._unique_indetifier = "DSRC.Acceleration"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Acceleration()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -2000
        data_map['maximum'] = 2001

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Acceleration()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -2000
        data_map['maximum'] = 2001

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Acceleration()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class AccelerationConfidence:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.AccelerationConfidence"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "accl-100-00": 1, "accl-010-00": 2, "accl-005-00": 3, "accl-001-00": 4, "accl-000-10": 5, "accl-000-05": 6, "accl-000-01": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = AccelerationConfidence()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = AccelerationConfidence()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = AccelerationConfidence()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class AdvisorySpeedType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.AdvisorySpeedType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"none": 0, "greenwave": 1, "ecoDrive": 2, "transit": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = AdvisorySpeedType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = AdvisorySpeedType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = AdvisorySpeedType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class AllowedManeuvers:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(12)","isBitString":"True","permitted":[(12,12)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.AllowedManeuvers"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = AllowedManeuvers()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 12
        data_map['maximum_root_size'] = 12
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = AllowedManeuvers()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 12
        data_map['maximum_root_size'] = 12
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = AllowedManeuvers()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class AmbientAirTemperature:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..191","permitted":[(0,191)]}}]
        self._unique_indetifier = "DSRC.AmbientAirTemperature"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = AmbientAirTemperature()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 191

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = AmbientAirTemperature()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 191

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = AmbientAirTemperature()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class Angle:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..28800","permitted":[(0,28800)]}}]
        self._unique_indetifier = "DSRC.Angle"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Angle()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 28800

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Angle()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 28800

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Angle()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

Heading = Angle
ObstacleDirection = Angle

class AnimalPropelledType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.AnimalPropelledType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "otherTypes": 1, "animalMounted": 2, "animalDrawnCarriage": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = AnimalPropelledType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = AnimalPropelledType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = AnimalPropelledType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class AnimalType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.AnimalType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "serviceUse": 1, "pet": 2, "farm": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = AnimalType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = AnimalType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = AnimalType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class Attachment:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.Attachment"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "stroller": 1, "bicycleTrailer": 2, "cart": 3, "wheelchair": 4, "otherWalkAssistAttachments": 5, "pet": 6}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = Attachment()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = Attachment()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = Attachment()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class AttachmentRadius:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..200","permitted":[(0,200)]}}]
        self._unique_indetifier = "DSRC.AttachmentRadius"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = AttachmentRadius()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 200

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = AttachmentRadius()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 200

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = AttachmentRadius()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

Confidence = AttachmentRadius
ThrottlePosition = AttachmentRadius

class AuxiliaryBrakeStatus:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.AuxiliaryBrakeStatus"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "off": 1, "on": 2, "reserved": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = AuxiliaryBrakeStatus()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = AuxiliaryBrakeStatus()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = AuxiliaryBrakeStatus()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class BasicVehicleRole:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.BasicVehicleRole"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"basicVehicle": 0, "publicTransport": 1, "specialTransport": 2, "dangerousGoods": 3, "roadWork": 4, "roadRescue": 5, "emergency": 6, "safetyCar": 7, "none-unknown": 8, "truck": 9, "motorcycle": 10, "roadSideSource": 11, "police": 12, "fire": 13, "ambulance": 14, "dot": 15, "transit": 16, "slowMoving": 17, "stopNgo": 18, "cyclist": 19, "pedestrian": 20, "nonMotorized": 21, "military": 22}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = BasicVehicleRole()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 5
        data_map['width_index_aligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = BasicVehicleRole()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 5
        data_map['width_index_aligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = BasicVehicleRole()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class BrakeAppliedPressure:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.BrakeAppliedPressure"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "minPressure": 1, "bkLvl-2": 2, "bkLvl-3": 3, "bkLvl-4": 4, "bkLvl-5": 5, "bkLvl-6": 6, "bkLvl-7": 7, "bkLvl-8": 8, "bkLvl-9": 9, "bkLvl-10": 10, "bkLvl-11": 11, "bkLvl-12": 12, "bkLvl-13": 13, "bkLvl-14": 14, "maxPressure": 15}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = BrakeAppliedPressure()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = BrakeAppliedPressure()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = BrakeAppliedPressure()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class BrakeBoostApplied:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.BrakeBoostApplied"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "off": 1, "on": 2}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = BrakeBoostApplied()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = BrakeBoostApplied()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = BrakeBoostApplied()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class BumperHeight:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..127","permitted":[(0,127)]}}]
        self._unique_indetifier = "DSRC.BumperHeight"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = BumperHeight()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 7
        data_map['width_value_unaligned'] = 7
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 127

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = BumperHeight()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 7
        data_map['width_value_unaligned'] = 7
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 127

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = BumperHeight()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

MsgCount = BumperHeight
VehicleHeight = BumperHeight
WiperRate = BumperHeight

class CoarseHeading:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..240","permitted":[(0,240)]}}]
        self._unique_indetifier = "DSRC.CoarseHeading"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = CoarseHeading()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 240

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = CoarseHeading()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 240

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = CoarseHeading()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class CodeWord:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1..16)","isOctetString":"True","permitted":[(1,16)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.CodeWord"
        self._asn1Type = Asn1Type.OCTET_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        octetstring_type = CodeWord()
        return octetstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False

        bin_val = None
        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            bin_val = func(encoding_rule, value['containing'], value_tracker).get_buffer()
        else:
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc:
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc

        if bin_val is None:
            raise TypeError("63305: The 'plain octets' are missing from the octet string value!")

        osspy.per.encode_octet_string(stream, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        octetstring_type = CodeWord()
        return octetstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False

        value = osspy.per.decode_octet_string(stream, **data_map)

        if self._contents_constrait is not None:
            func = getattr(self._contents_constrait, 'decode')
            bin_val = bytearray.fromhex(value)
            tmpstream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, tmpstream, value_tracker)
                tmpstream.ensure_not_beyond_end_of_stream()

                if tmpstream.is_eof():
                    value = valcontaining
                else:
                    tmpstream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        octetstring_type = CodeWord()
        return octetstring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class CoefficientOfFriction:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..50","permitted":[(0,50)]}}]
        self._unique_indetifier = "DSRC.CoefficientOfFriction"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = CoefficientOfFriction()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 50

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = CoefficientOfFriction()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 50

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = CoefficientOfFriction()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class Count:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..32","permitted":[(0,32)]}}]
        self._unique_indetifier = "DSRC.Count"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Count()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 32

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Count()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 32

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Count()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DeltaAngle:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-150..150","permitted":[(-150,150)]}}]
        self._unique_indetifier = "DSRC.DeltaAngle"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DeltaAngle()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 9
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -150
        data_map['maximum'] = 150

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DeltaAngle()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 9
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -150
        data_map['maximum'] = 150

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DeltaAngle()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DeltaTime:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-122 .. 121","permitted":[(-122,121)]}}]
        self._unique_indetifier = "DSRC.DeltaTime"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DeltaTime()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -122
        data_map['maximum'] = 121

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DeltaTime()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -122
        data_map['maximum'] = 121

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DeltaTime()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DescriptiveName:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"alphabet constraint","permitted":[[0,127]]}},{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1..63)","permitted":[(1,63)]}}]
        self._unique_indetifier = "DSRC.DescriptiveName"
        self._asn1Type = Asn1Type.String

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DescriptiveName()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 63
        data_map['width_length_aligned'] = 6
        data_map['width_length_unaligned'] = 6
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        osspy.per.encode_string(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> str:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DescriptiveName()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> str:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 63
        data_map['width_length_aligned'] = 6
        data_map['width_length_unaligned'] = 6
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        return osspy.per.decode_string(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DescriptiveName()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DDay:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..31","permitted":[(0,31)]}}]
        self._unique_indetifier = "DSRC.DDay"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DDay()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 5
        data_map['width_value_unaligned'] = 5
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 31

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DDay()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 5
        data_map['width_value_unaligned'] = 5
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 31

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DDay()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

DHour = DDay
GrossSpeed = DDay
SpeedProfileMeasurement = DDay
SSPindex = DDay

class DirectionOfUse:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.DirectionOfUse"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "forward": 1, "reverse": 2, "both": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = DirectionOfUse()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = DirectionOfUse()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = DirectionOfUse()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class DistanceUnits:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.DistanceUnits"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"centimeter": 0, "cm2-5": 1, "decimeter": 2, "meter": 3, "kilometer": 4, "foot": 5, "yard": 6, "mile": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = DistanceUnits()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = DistanceUnits()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = DistanceUnits()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class DMinute:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..60","permitted":[(0,60)]}}]
        self._unique_indetifier = "DSRC.DMinute"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DMinute()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 60

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DMinute()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 60

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DMinute()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

Second = DMinute

class DMonth:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..12","permitted":[(0,12)]}}]
        self._unique_indetifier = "DSRC.DMonth"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DMonth()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 4
        data_map['width_value_unaligned'] = 4
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 12

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DMonth()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 4
        data_map['width_value_unaligned'] = 4
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 12

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DMonth()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DOffset:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-840..840","permitted":[(-840,840)]}}]
        self._unique_indetifier = "DSRC.DOffset"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DOffset()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 11
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -840
        data_map['maximum'] = 840

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DOffset()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 11
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -840
        data_map['maximum'] = 840

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DOffset()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DrivenLineOffsetLg:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-32767..32767","permitted":[(-32767,32767)]}}]
        self._unique_indetifier = "DSRC.DrivenLineOffsetLg"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DrivenLineOffsetLg()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -32767
        data_map['maximum'] = 32767

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DrivenLineOffsetLg()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -32767
        data_map['maximum'] = 32767

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DrivenLineOffsetLg()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

RadiusOfCurvature = DrivenLineOffsetLg
YawRate = DrivenLineOffsetLg
VehicleStatusRequest__4 = DrivenLineOffsetLg
VehicleStatusRequest__6 = DrivenLineOffsetLg

class DrivenLineOffsetSm:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-2047..2047","permitted":[(-2047,2047)]}}]
        self._unique_indetifier = "DSRC.DrivenLineOffsetSm"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DrivenLineOffsetSm()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -2047
        data_map['maximum'] = 2047

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DrivenLineOffsetSm()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -2047
        data_map['maximum'] = 2047

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DrivenLineOffsetSm()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DSRCmsgID:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..32767","permitted":[(0,32767)]}}]
        self._unique_indetifier = "DSRC.DSRCmsgID"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DSRCmsgID()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 32767

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DSRCmsgID()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 32767

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DSRCmsgID()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

LaneWidth = DSRCmsgID
NMEA_MsgType = DSRCmsgID
ObstacleDistance = DSRCmsgID
ProbeSegmentNumber = DSRCmsgID

class Duration:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..3600","permitted":[(0,3600)]}}]
        self._unique_indetifier = "DSRC.Duration"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Duration()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 3600

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Duration()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 3600

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Duration()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class ElevationConfidence:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.ElevationConfidence"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "elev-500-00": 1, "elev-200-00": 2, "elev-100-00": 3, "elev-050-00": 4, "elev-020-00": 5, "elev-010-00": 6, "elev-005-00": 7, "elev-002-00": 8, "elev-001-00": 9, "elev-000-50": 10, "elev-000-20": 11, "elev-000-10": 12, "elev-000-05": 13, "elev-000-02": 14, "elev-000-01": 15}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = ElevationConfidence()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = ElevationConfidence()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = ElevationConfidence()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class Elevation:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-4096..61439","permitted":[(-4096,61439)]}}]
        self._unique_indetifier = "DSRC.Elevation"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Elevation()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -4096
        data_map['maximum'] = 61439

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Elevation()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -4096
        data_map['maximum'] = 61439

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Elevation()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class Extent:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.Extent"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"useInstantlyOnly": 0, "useFor3meters": 1, "useFor10meters": 2, "useFor50meters": 3, "useFor100meters": 4, "useFor500meters": 5, "useFor1000meters": 6, "useFor5000meters": 7, "useFor10000meters": 8, "useFor50000meters": 9, "useFor100000meters": 10, "useFor500000meters": 11, "useFor1000000meters": 12, "useFor5000000meters": 13, "useFor10000000meters": 14, "forever": 15}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = Extent()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = Extent()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = Extent()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class HeadingConfidence:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.HeadingConfidence"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "prec10deg": 1, "prec05deg": 2, "prec01deg": 3, "prec0-1deg": 4, "prec0-05deg": 5, "prec0-01deg": 6, "prec0-0125deg": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = HeadingConfidence()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = HeadingConfidence()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = HeadingConfidence()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class ITIStextPhrase:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"alphabet constraint","permitted":[[0,127]]}},{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1..16)","permitted":[(1,16)]}}]
        self._unique_indetifier = "DSRC.ITIStextPhrase"
        self._asn1Type = Asn1Type.String

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = ITIStextPhrase()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_aligned'] = 4
        data_map['width_length_unaligned'] = 4
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        osspy.per.encode_string(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> str:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = ITIStextPhrase()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> str:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 16
        data_map['width_length_aligned'] = 4
        data_map['width_length_unaligned'] = 4
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        return osspy.per.decode_string(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = ITIStextPhrase()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class AxleWeight:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..64255","permitted":[(0,64255)]}}]
        self._unique_indetifier = "DSRC.AxleWeight"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = AxleWeight()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 64255

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = AxleWeight()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 64255

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = AxleWeight()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

CargoWeight = AxleWeight
TireLeakageRate = AxleWeight
TrailerWeight = AxleWeight

class DriveAxleLubePressure:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..250","permitted":[(0,250)]}}]
        self._unique_indetifier = "DSRC.DriveAxleLubePressure"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DriveAxleLubePressure()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 250

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DriveAxleLubePressure()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 250

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DriveAxleLubePressure()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

SteeringAxleLubePressure = DriveAxleLubePressure
TirePressure = DriveAxleLubePressure

class DriveAxleTemperature:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-40..210","permitted":[(-40,210)]}}]
        self._unique_indetifier = "DSRC.DriveAxleTemperature"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DriveAxleTemperature()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -40
        data_map['maximum'] = 210

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DriveAxleTemperature()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -40
        data_map['maximum'] = 210

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DriveAxleTemperature()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

SteeringAxleTemperature = DriveAxleTemperature

class TirePressureThresholdDetection:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.TirePressureThresholdDetection"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"noData": 0, "overPressure": 1, "noWarningPressure": 2, "underPressure": 3, "extremeUnderPressure": 4, "undefined": 5, "errorIndicator": 6, "notAvailable": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = TirePressureThresholdDetection()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = TirePressureThresholdDetection()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = TirePressureThresholdDetection()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class TireTemp:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-8736..55519","permitted":[(-8736,55519)]}}]
        self._unique_indetifier = "DSRC.TireTemp"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = TireTemp()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -8736
        data_map['maximum'] = 55519

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = TireTemp()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -8736
        data_map['maximum'] = 55519

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = TireTemp()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class WheelEndElectFault:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.WheelEndElectFault"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"isOk": 0, "isNotDefined": 1, "isError": 2, "isNotSupported": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = WheelEndElectFault()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = WheelEndElectFault()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = WheelEndElectFault()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class WheelSensorStatus:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.WheelSensorStatus"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"off": 0, "on": 1, "notDefined": 2, "notSupported": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = WheelSensorStatus()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = WheelSensorStatus()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = WheelSensorStatus()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class HeadingSlice:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE (16)","isBitString":"True","permitted":[(16,16)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.HeadingSlice"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = HeadingSlice()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 16
        data_map['maximum_root_size'] = 16
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = HeadingSlice()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 16
        data_map['maximum_root_size'] = 16
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = HeadingSlice()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

IntersectionStatusObject = HeadingSlice
LaneAttributes_Barrier = HeadingSlice
LaneAttributes_Bike = HeadingSlice
LaneAttributes_Crosswalk = HeadingSlice
LaneAttributes_Parking = HeadingSlice
LaneAttributes_Sidewalk = HeadingSlice
LaneAttributes_Striping = HeadingSlice
LaneAttributes_TrackedVehicle = HeadingSlice
PrivilegedEventFlags = HeadingSlice

class LaneAttributes_Vehicle:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE (8,...)","isBitString":"True","permitted":[(8,8)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.LaneAttributes-Vehicle"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = LaneAttributes_Vehicle()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 8
        data_map['maximum_root_size'] = 8
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = LaneAttributes_Vehicle()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 8
        data_map['maximum_root_size'] = 8
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = LaneAttributes_Vehicle()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class LaneDirection:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE (2)","isBitString":"True","permitted":[(2,2)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.LaneDirection"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = LaneDirection()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 2
        data_map['maximum_root_size'] = 2
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = LaneDirection()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 2
        data_map['maximum_root_size'] = 2
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = LaneDirection()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class LaneSharing:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE (10)","isBitString":"True","permitted":[(10,10)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.LaneSharing"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = LaneSharing()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 10
        data_map['maximum_root_size'] = 10
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = LaneSharing()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 10
        data_map['maximum_root_size'] = 10
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = LaneSharing()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class Latitude:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-900000000..900000001","permitted":[(-900000000,900000001)]}}]
        self._unique_indetifier = "DSRC.Latitude"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Latitude()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 31
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -900000000
        data_map['maximum'] = 900000001

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Latitude()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 31
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -900000000
        data_map['maximum'] = 900000001

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Latitude()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class Iso3833VehicleType:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..100","permitted":[(0,100)]}}]
        self._unique_indetifier = "DSRC.Iso3833VehicleType"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Iso3833VehicleType()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 7
        data_map['width_value_unaligned'] = 7
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 100

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Iso3833VehicleType()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 7
        data_map['width_value_unaligned'] = 7
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 100

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Iso3833VehicleType()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

LayerID = Iso3833VehicleType
PersonalClusterRadius = Iso3833VehicleType

class LayerType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.LayerType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"none": 0, "mixedContent": 1, "generalMapData": 2, "intersectionData": 3, "curveData": 4, "roadwaySectionData": 5, "parkingAreaData": 6, "sharedLaneData": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = LayerType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = LayerType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = LayerType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class LightbarInUse:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.LightbarInUse"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "notInUse": 1, "inUse": 2, "yellowCautionLights": 3, "schooldBusLights": 4, "arrowSignsActive": 5, "slowMovingVehicle": 6, "freqStops": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = LightbarInUse()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = LightbarInUse()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = LightbarInUse()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class Longitude:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-1799999999..1800000001","permitted":[(-1799999999,1800000001)]}}]
        self._unique_indetifier = "DSRC.Longitude"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Longitude()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 32
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -1799999999
        data_map['maximum'] = 1800000001

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Longitude()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 32
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -1799999999
        data_map['maximum'] = 1800000001

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Longitude()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class Location_quality:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.Location-quality"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"loc-qual-bt1m": 0, "loc-qual-bt5m": 1, "loc-qual-bt12m": 2, "loc-qual-bt50m": 3, "loc-qual-bt125m": 4, "loc-qual-bt500m": 5, "loc-qual-bt1250m": 6, "loc-qual-unknown": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = Location_quality()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = Location_quality()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = Location_quality()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class Location_tech:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.Location-tech"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"loc-tech-unknown": 0, "loc-tech-GNSS": 1, "loc-tech-DGPS": 2, "loc-tech-RTK": 3, "loc-tech-PPP": 4, "loc-tech-drGPS": 5, "loc-tech-drDGPS": 6, "loc-tech-dr": 7, "loc-tech-nav": 8, "loc-tech-fault": 9}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = Location_tech()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = Location_tech()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = Location_tech()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class MessageBLOB:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(10..2000)","isOctetString":"True","permitted":[(10,2000)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.MessageBLOB"
        self._asn1Type = Asn1Type.OCTET_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        octetstring_type = MessageBLOB()
        return octetstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 10
        data_map['maximum_root_size'] = 2000
        data_map['width_length_unaligned'] = 11
        data_map['width_length_aligned'] = 16
        data_map['align_length'] = True

        bin_val = None
        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            bin_val = func(encoding_rule, value['containing'], value_tracker).get_buffer()
        else:
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc:
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc

        if bin_val is None:
            raise TypeError("63305: The 'plain octets' are missing from the octet string value!")

        osspy.per.encode_octet_string(stream, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        octetstring_type = MessageBLOB()
        return octetstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 10
        data_map['maximum_root_size'] = 2000
        data_map['width_length_unaligned'] = 11
        data_map['width_length_aligned'] = 16
        data_map['align_length'] = True

        value = osspy.per.decode_octet_string(stream, **data_map)

        if self._contents_constrait is not None:
            func = getattr(self._contents_constrait, 'decode')
            bin_val = bytearray.fromhex(value)
            tmpstream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, tmpstream, value_tracker)
                tmpstream.ensure_not_beyond_end_of_stream()

                if tmpstream.is_eof():
                    value = valcontaining
                else:
                    tmpstream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        octetstring_type = MessageBLOB()
        return octetstring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class MinuteOfTheYear:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..527040","permitted":[(0,527040)]}}]
        self._unique_indetifier = "DSRC.MinuteOfTheYear"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = MinuteOfTheYear()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 20
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 527040

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = MinuteOfTheYear()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 20
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 527040

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = MinuteOfTheYear()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class MinutesDuration:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..32000","permitted":[(0,32000)]}}]
        self._unique_indetifier = "DSRC.MinutesDuration"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = MinutesDuration()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 32000

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = MinutesDuration()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 32000

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = MinutesDuration()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class MotorizedPropelledType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.MotorizedPropelledType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "otherTypes": 1, "wheelChair": 2, "bicycle": 3, "scooter": 4, "selfBalancingDevice": 5}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = MotorizedPropelledType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = MotorizedPropelledType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = MotorizedPropelledType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class MovementPhaseState:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.MovementPhaseState"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "dark": 1, "stop-Then-Proceed": 2, "stop-And-Remain": 3, "pre-Movement": 4, "permissive-Movement-Allowed": 5, "protected-Movement-Allowed": 6, "permissive-clearance": 7, "protected-clearance": 8, "caution-Conflicting-Traffic": 9}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = MovementPhaseState()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = MovementPhaseState()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = MovementPhaseState()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class FurtherInfoID:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(2)","isOctetString":"True","permitted":[(2,2)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.FurtherInfoID"
        self._asn1Type = Asn1Type.OCTET_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        octetstring_type = FurtherInfoID()
        return octetstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 2
        data_map['maximum_root_size'] = 2
        data_map['width_length_unaligned'] = 0
        data_map['width_length_aligned'] = 0
        data_map['align_length'] = False

        bin_val = None
        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            bin_val = func(encoding_rule, value['containing'], value_tracker).get_buffer()
        else:
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc:
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc

        if bin_val is None:
            raise TypeError("63305: The 'plain octets' are missing from the octet string value!")

        osspy.per.encode_octet_string(stream, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        octetstring_type = FurtherInfoID()
        return octetstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 2
        data_map['maximum_root_size'] = 2
        data_map['width_length_unaligned'] = 0
        data_map['width_length_aligned'] = 0
        data_map['align_length'] = False

        value = osspy.per.decode_octet_string(stream, **data_map)

        if self._contents_constrait is not None:
            func = getattr(self._contents_constrait, 'decode')
            bin_val = bytearray.fromhex(value)
            tmpstream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, tmpstream, value_tracker)
                tmpstream.ensure_not_beyond_end_of_stream()

                if tmpstream.is_eof():
                    value = valcontaining
                else:
                    tmpstream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        octetstring_type = FurtherInfoID()
        return octetstring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

MsgCRC = FurtherInfoID

class MultiVehicleResponse:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.MultiVehicleResponse"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "singleVehicle": 1, "multiVehicle": 2, "reserved": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = MultiVehicleResponse()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = MultiVehicleResponse()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = MultiVehicleResponse()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class MUTCDCode:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.MUTCDCode"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"none": 0, "regulatory": 1, "warning": 2, "maintenance": 3, "motoristService": 4, "guide": 5, "rec": 6}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = MUTCDCode()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = MUTCDCode()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = MUTCDCode()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class NMEA_Revision:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.NMEA-Revision"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unknown": 0, "reserved": 1, "rev1": 2, "rev2": 3, "rev3": 4, "rev4": 5, "rev5": 6}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = NMEA_Revision()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = NMEA_Revision()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = NMEA_Revision()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class NodeAttributeLL:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.NodeAttributeLL"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"reserved": 0, "stopLine": 1, "roundedCapStyleA": 2, "roundedCapStyleB": 3, "mergePoint": 4, "divergePoint": 5, "downstreamStopLine": 6, "downstreamStartNode": 7, "closedToTraffic": 8, "safeIsland": 9, "curbPresentAtStepOff": 10, "hydrantPresent": 11}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = NodeAttributeLL()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = NodeAttributeLL()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = NodeAttributeLL()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

NodeAttributeXY = NodeAttributeLL

class NumberOfParticipantsInCluster:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.NumberOfParticipantsInCluster"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "small": 1, "medium": 2, "large": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = NumberOfParticipantsInCluster()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = NumberOfParticipantsInCluster()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = NumberOfParticipantsInCluster()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class GrossDistance:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..1023","permitted":[(0,1023)]}}]
        self._unique_indetifier = "DSRC.GrossDistance"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = GrossDistance()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 10
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 1023

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = GrossDistance()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 10
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 1023

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = GrossDistance()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

ObjectCount = GrossDistance
VehicleWidth = GrossDistance

class Offset_B11:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-1024..1023","permitted":[(-1024,1023)]}}]
        self._unique_indetifier = "DSRC.Offset-B11"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Offset_B11()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 11
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -1024
        data_map['maximum'] = 1023

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Offset_B11()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 11
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -1024
        data_map['maximum'] = 1023

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Offset_B11()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

VertOffset_B11 = Offset_B11

class Offset_B13:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-4096..4095","permitted":[(-4096,4095)]}}]
        self._unique_indetifier = "DSRC.Offset-B13"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Offset_B13()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 13
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -4096
        data_map['maximum'] = 4095

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Offset_B13()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 13
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -4096
        data_map['maximum'] = 4095

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Offset_B13()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class Elevation__A:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-32768..32767","permitted":[(-32768,32767)]}}]
        self._unique_indetifier = "AddGrpB.Elevation"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Elevation__A()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -32768
        data_map['maximum'] = 32767

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Elevation__A()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -32768
        data_map['maximum'] = 32767

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Elevation__A()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

Offset_B16 = Elevation__A
OffsetLL_B16 = Elevation__A

class Offset_B14:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-8192..8191","permitted":[(-8192,8191)]}}]
        self._unique_indetifier = "DSRC.Offset-B14"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Offset_B14()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 14
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -8192
        data_map['maximum'] = 8191

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Offset_B14()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 14
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -8192
        data_map['maximum'] = 8191

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Offset_B14()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

OffsetLL_B14 = Offset_B14

class OffsetLL_B18:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-131072..131071","permitted":[(-131072,131071)]}}]
        self._unique_indetifier = "DSRC.OffsetLL-B18"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = OffsetLL_B18()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 18
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -131072
        data_map['maximum'] = 131071

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = OffsetLL_B18()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 18
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -131072
        data_map['maximum'] = 131071

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = OffsetLL_B18()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class OffsetLL_B22:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-2097152..2097151","permitted":[(-2097152,2097151)]}}]
        self._unique_indetifier = "DSRC.OffsetLL-B22"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = OffsetLL_B22()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 22
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -2097152
        data_map['maximum'] = 2097151

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = OffsetLL_B22()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 22
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -2097152
        data_map['maximum'] = 2097151

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = OffsetLL_B22()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class OffsetLL_B24:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-8388608..8388607","permitted":[(-8388608,8388607)]}}]
        self._unique_indetifier = "DSRC.OffsetLL-B24"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = OffsetLL_B24()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 24
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -8388608
        data_map['maximum'] = 8388607

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = OffsetLL_B24()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 24
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -8388608
        data_map['maximum'] = 8388607

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = OffsetLL_B24()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class PayloadData:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1..2048)","isOctetString":"True","permitted":[(1,2048)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.PayloadData"
        self._asn1Type = Asn1Type.OCTET_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        octetstring_type = PayloadData()
        return octetstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 2048
        data_map['width_length_unaligned'] = 11
        data_map['width_length_aligned'] = 16
        data_map['align_length'] = True

        bin_val = None
        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            bin_val = func(encoding_rule, value['containing'], value_tracker).get_buffer()
        else:
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc:
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc

        if bin_val is None:
            raise TypeError("63305: The 'plain octets' are missing from the octet string value!")

        osspy.per.encode_octet_string(stream, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        octetstring_type = PayloadData()
        return octetstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 2048
        data_map['width_length_unaligned'] = 11
        data_map['width_length_aligned'] = 16
        data_map['align_length'] = True

        value = osspy.per.decode_octet_string(stream, **data_map)

        if self._contents_constrait is not None:
            func = getattr(self._contents_constrait, 'decode')
            bin_val = bytearray.fromhex(value)
            tmpstream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, tmpstream, value_tracker)
                tmpstream.ensure_not_beyond_end_of_stream()

                if tmpstream.is_eof():
                    value = valcontaining
                else:
                    tmpstream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        octetstring_type = PayloadData()
        return octetstring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class HumanPropelledType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.HumanPropelledType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "otherTypes": 1, "onFoot": 2, "skateboard": 3, "pushOrKickScooter": 4, "wheelchair": 5}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = HumanPropelledType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = HumanPropelledType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = HumanPropelledType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class ExteriorLights:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE (9, ...)","isBitString":"True","permitted":[(9,9)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.ExteriorLights"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = ExteriorLights()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 9
        data_map['maximum_root_size'] = 9
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = ExteriorLights()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 9
        data_map['maximum_root_size'] = 9
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = ExteriorLights()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

PersonalDeviceUsageState = ExteriorLights

class PersonalDeviceUserType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.PersonalDeviceUserType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "aPEDESTRIAN": 1, "aPEDALCYCLIST": 2, "aPUBLICSAFETYWORKER": 3, "anANIMAL": 4}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = PersonalDeviceUserType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = PersonalDeviceUserType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = PersonalDeviceUserType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class PositionConfidence:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.PositionConfidence"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "a500m": 1, "a200m": 2, "a100m": 3, "a50m": 4, "a20m": 5, "a10m": 6, "a5m": 7, "a2m": 8, "a1m": 9, "a50cm": 10, "a20cm": 11, "a10cm": 12, "a5cm": 13, "a2cm": 14, "a1cm": 15}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = PositionConfidence()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = PositionConfidence()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = PositionConfidence()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class PrioritizationResponseStatus:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.PrioritizationResponseStatus"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unknown": 0, "requested": 1, "processing": 2, "watchOtherTraffic": 3, "granted": 4, "rejected": 5, "maxPresence": 6, "reserviceLocked": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = PrioritizationResponseStatus()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = PrioritizationResponseStatus()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = PrioritizationResponseStatus()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class PriorityRequestType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.PriorityRequestType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"priorityRequestTypeReserved": 0, "priorityRequest": 1, "priorityRequestUpdate": 2, "priorityCancellation": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = PriorityRequestType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = PriorityRequestType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = PriorityRequestType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class PersonalAssistive:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE (6, ...)","isBitString":"True","permitted":[(6,6)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.PersonalAssistive"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = PersonalAssistive()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 6
        data_map['maximum_root_size'] = 6
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = PersonalAssistive()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 6
        data_map['maximum_root_size'] = 6
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = PersonalAssistive()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

PublicSafetyAndRoadWorkerActivity = PersonalAssistive

class PublicSafetyDirectingTrafficSubType:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE (7, ...)","isBitString":"True","permitted":[(7,7)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.PublicSafetyDirectingTrafficSubType"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = PublicSafetyDirectingTrafficSubType()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 7
        data_map['maximum_root_size'] = 7
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = PublicSafetyDirectingTrafficSubType()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 7
        data_map['maximum_root_size'] = 7
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = PublicSafetyDirectingTrafficSubType()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class PublicSafetyEventResponderWorkerType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.PublicSafetyEventResponderWorkerType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "towOperater": 1, "fireAndEMSWorker": 2, "aDOTWorker": 3, "lawEnforcement": 4, "hazmatResponder": 5, "animalControlWorker": 6, "otherPersonnel": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = PublicSafetyEventResponderWorkerType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = PublicSafetyEventResponderWorkerType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = PublicSafetyEventResponderWorkerType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class RainSensor:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RainSensor"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"none": 0, "lightMist": 1, "heavyMist": 2, "lightRainOrDrizzle": 3, "rain": 4, "moderateRain": 5, "heavyRain": 6, "heavyDownpour": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = RainSensor()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = RainSensor()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = RainSensor()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class RequestedItem:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RequestedItem"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"reserved": 0, "itemA": 1, "itemB": 2, "itemC": 3, "itemD": 4, "itemE": 5, "itemF": 6, "itemG": 7, "itemI": 8, "itemJ": 9, "itemK": 10, "itemL": 11, "itemM": 12, "itemN": 13, "itemO": 14, "itemP": 15, "itemQ": 16}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = RequestedItem()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 5
        data_map['width_index_aligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = RequestedItem()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 5
        data_map['width_index_aligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = RequestedItem()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class RequestImportanceLevel:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RequestImportanceLevel"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"requestImportanceLevelUnKnown": 0, "requestImportanceLevel1": 1, "requestImportanceLevel2": 2, "requestImportanceLevel3": 3, "requestImportanceLevel4": 4, "requestImportanceLevel5": 5, "requestImportanceLevel6": 6, "requestImportanceLevel7": 7, "requestImportanceLevel8": 8, "requestImportanceLevel9": 9, "requestImportanceLevel10": 10, "requestImportanceLevel11": 11, "requestImportanceLevel12": 12, "requestImportanceLevel13": 13, "requestImportanceLevel14": 14, "requestImportanceReserved": 15}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = RequestImportanceLevel()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = RequestImportanceLevel()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = RequestImportanceLevel()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class RequestSubRole:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RequestSubRole"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"requestSubRoleUnKnown": 0, "requestSubRole1": 1, "requestSubRole2": 2, "requestSubRole3": 3, "requestSubRole4": 4, "requestSubRole5": 5, "requestSubRole6": 6, "requestSubRole7": 7, "requestSubRole8": 8, "requestSubRole9": 9, "requestSubRole10": 10, "requestSubRole11": 11, "requestSubRole12": 12, "requestSubRole13": 13, "requestSubRole14": 14, "requestSubRoleReserved": 15}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = RequestSubRole()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = RequestSubRole()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = RequestSubRole()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class ResponseType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.ResponseType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"notInUseOrNotEquipped": 0, "emergency": 1, "nonEmergency": 2, "pursuit": 3, "stationary": 4, "slowMoving": 5, "stopAndGoMovement": 6}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = ResponseType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = ResponseType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = ResponseType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class RestrictionAppliesTo:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RestrictionAppliesTo"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"none": 0, "equippedTransit": 1, "equippedTaxis": 2, "equippedOther": 3, "emissionCompliant": 4, "equippedBicycle": 5, "weightCompliant": 6, "heightCompliant": 7, "pedestrians": 8, "slowMovingPersons": 9, "wheelchairUsers": 10, "visualDisabilities": 11, "audioDisabilities": 12, "otherUnknownDisabilities": 13}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = RestrictionAppliesTo()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = RestrictionAppliesTo()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = RestrictionAppliesTo()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class RTCM_Revision:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RTCM-Revision"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unknown": 0, "rtcmRev2": 1, "rtcmRev3": 2, "reserved": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = RTCM_Revision()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = RTCM_Revision()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = RTCM_Revision()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class NMEA_Payload:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1..1023)","isOctetString":"True","permitted":[(1,1023)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.NMEA-Payload"
        self._asn1Type = Asn1Type.OCTET_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        octetstring_type = NMEA_Payload()
        return octetstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 1023
        data_map['width_length_unaligned'] = 10
        data_map['width_length_aligned'] = 16
        data_map['align_length'] = True

        bin_val = None
        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            bin_val = func(encoding_rule, value['containing'], value_tracker).get_buffer()
        else:
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc:
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc

        if bin_val is None:
            raise TypeError("63305: The 'plain octets' are missing from the octet string value!")

        osspy.per.encode_octet_string(stream, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        octetstring_type = NMEA_Payload()
        return octetstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 1023
        data_map['width_length_unaligned'] = 10
        data_map['width_length_aligned'] = 16
        data_map['align_length'] = True

        value = osspy.per.decode_octet_string(stream, **data_map)

        if self._contents_constrait is not None:
            func = getattr(self._contents_constrait, 'decode')
            bin_val = bytearray.fromhex(value)
            tmpstream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, tmpstream, value_tracker)
                tmpstream.ensure_not_beyond_end_of_stream()

                if tmpstream.is_eof():
                    value = valcontaining
                else:
                    tmpstream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        octetstring_type = NMEA_Payload()
        return octetstring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

RTCMmessage = NMEA_Payload

class Offset_B12:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-2048..2047","permitted":[(-2048,2047)]}}]
        self._unique_indetifier = "DSRC.Offset-B12"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Offset_B12()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -2048
        data_map['maximum'] = 2047

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Offset_B12()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -2048
        data_map['maximum'] = 2047

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Offset_B12()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

OffsetLL_B12 = Offset_B12
Scale_B12 = Offset_B12
VertOffset_B12 = Offset_B12

class SecondOfTime:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..61","permitted":[(0,61)]}}]
        self._unique_indetifier = "DSRC.SecondOfTime"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = SecondOfTime()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 61

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = SecondOfTime()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 61

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = SecondOfTime()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class SegmentAttributeLL:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.SegmentAttributeLL"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"reserved": 0, "doNotBlock": 1, "whiteLine": 2, "mergingLaneLeft": 3, "mergingLaneRight": 4, "curbOnLeft": 5, "curbOnRight": 6, "loadingzoneOnLeft": 7, "loadingzoneOnRight": 8, "turnOutPointOnLeft": 9, "turnOutPointOnRight": 10, "adjacentParkingOnLeft": 11, "adjacentParkingOnRight": 12, "adjacentBikeLaneOnLeft": 13, "adjacentBikeLaneOnRight": 14, "sharedBikeLane": 15, "bikeBoxInFront": 16, "transitStopOnLeft": 17, "transitStopOnRight": 18, "transitStopInLane": 19, "sharedWithTrackedVehicle": 20, "safeIsland": 21, "lowCurbsPresent": 22, "rumbleStripPresent": 23, "audibleSignalingPresent": 24, "adaptiveTimingPresent": 25, "rfSignalRequestPresent": 26, "partialCurbIntrusion": 27, "taperToLeft": 28, "taperToRight": 29, "taperToCenterLine": 30, "parallelParking": 31, "headInParking": 32, "freeParking": 33, "timeRestrictionsOnParking": 34, "costToPark": 35, "midBlockCurbPresent": 36, "unEvenPavementPresent": 37}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = SegmentAttributeLL()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 6
        data_map['width_index_aligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = SegmentAttributeLL()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 6
        data_map['width_index_aligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = SegmentAttributeLL()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

SegmentAttributeXY = SegmentAttributeLL

class Priority:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1)","isOctetString":"True","permitted":[(1,1)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.Priority"
        self._asn1Type = Asn1Type.OCTET_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        octetstring_type = Priority()
        return octetstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 1
        data_map['width_length_unaligned'] = 0
        data_map['width_length_aligned'] = 0
        data_map['align_length'] = False

        bin_val = None
        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            bin_val = func(encoding_rule, value['containing'], value_tracker).get_buffer()
        else:
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc:
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc

        if bin_val is None:
            raise TypeError("63305: The 'plain octets' are missing from the octet string value!")

        osspy.per.encode_octet_string(stream, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        octetstring_type = Priority()
        return octetstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 1
        data_map['width_length_unaligned'] = 0
        data_map['width_length_aligned'] = 0
        data_map['align_length'] = False

        value = osspy.per.decode_octet_string(stream, **data_map)

        if self._contents_constrait is not None:
            func = getattr(self._contents_constrait, 'decode')
            bin_val = bytearray.fromhex(value)
            tmpstream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, tmpstream, value_tracker)
                tmpstream.ensure_not_beyond_end_of_stream()

                if tmpstream.is_eof():
                    value = valcontaining
                else:
                    tmpstream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        octetstring_type = Priority()
        return octetstring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

SignalReqScheme = Priority

class SignPrority:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..7","permitted":[(0,7)]}}]
        self._unique_indetifier = "DSRC.SignPrority"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = SignPrority()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 3
        data_map['width_value_unaligned'] = 3
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 7

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = SignPrority()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 3
        data_map['width_value_unaligned'] = 3
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 7

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = SignPrority()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class SirenInUse:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.SirenInUse"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "notInUse": 1, "inUse": 2, "reserved": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = SirenInUse()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = SirenInUse()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = SirenInUse()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class SpeedAdvice:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..500","permitted":[(0,500)]}}]
        self._unique_indetifier = "DSRC.SpeedAdvice"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = SpeedAdvice()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 9
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 500

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = SpeedAdvice()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 9
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 500

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = SpeedAdvice()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class SpeedConfidence:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.SpeedConfidence"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "prec100ms": 1, "prec10ms": 2, "prec5ms": 3, "prec1ms": 4, "prec0-1ms": 5, "prec0-05ms": 6, "prec0-01ms": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = SpeedConfidence()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = SpeedConfidence()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = SpeedConfidence()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class SpeedLimitType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.SpeedLimitType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unknown": 0, "maxSpeedInSchoolZone": 1, "maxSpeedInSchoolZoneWhenChildrenArePresent": 2, "maxSpeedInConstructionZone": 3, "vehicleMinSpeed": 4, "vehicleMaxSpeed": 5, "vehicleNightMaxSpeed": 6, "truckMinSpeed": 7, "truckMaxSpeed": 8, "truckNightMaxSpeed": 9, "vehiclesWithTrailersMinSpeed": 10, "vehiclesWithTrailersMaxSpeed": 11, "vehiclesWithTrailersNightMaxSpeed": 12}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = SpeedLimitType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = SpeedLimitType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = SpeedLimitType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class AntiLockBrakeStatus:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.AntiLockBrakeStatus"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "off": 1, "on": 2, "engaged": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = AntiLockBrakeStatus()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = AntiLockBrakeStatus()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = AntiLockBrakeStatus()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

StabilityControlStatus = AntiLockBrakeStatus
TractionControlStatus = AntiLockBrakeStatus

class StationID:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..4294967295","permitted":[(0,4294967295)]}}]
        self._unique_indetifier = "DSRC.StationID"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = StationID()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 32
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 4294967295

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = StationID()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 32
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 4294967295

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = StationID()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class SteeringWheelAngleConfidence:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.SteeringWheelAngleConfidence"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "prec2deg": 1, "prec1deg": 2, "prec0-02deg": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = SteeringWheelAngleConfidence()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = SteeringWheelAngleConfidence()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = SteeringWheelAngleConfidence()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class SteeringWheelAngle:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-126..127","permitted":[(-126,127)]}}]
        self._unique_indetifier = "DSRC.SteeringWheelAngle"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = SteeringWheelAngle()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -126
        data_map['maximum'] = 127

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = SteeringWheelAngle()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -126
        data_map['maximum'] = 127

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = SteeringWheelAngle()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DriveAxleLiftAirPressure:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..1000","permitted":[(0,1000)]}}]
        self._unique_indetifier = "DSRC.DriveAxleLiftAirPressure"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DriveAxleLiftAirPressure()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 10
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 1000

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DriveAxleLiftAirPressure()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 10
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 1000

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DriveAxleLiftAirPressure()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

SunSensor = DriveAxleLiftAirPressure

class TemporaryID:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(4)","isOctetString":"True","permitted":[(4,4)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.TemporaryID"
        self._asn1Type = Asn1Type.OCTET_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        octetstring_type = TemporaryID()
        return octetstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 4
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 0
        data_map['width_length_aligned'] = 0
        data_map['align_length'] = False

        bin_val = None
        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            bin_val = func(encoding_rule, value['containing'], value_tracker).get_buffer()
        else:
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc:
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc

        if bin_val is None:
            raise TypeError("63305: The 'plain octets' are missing from the octet string value!")

        osspy.per.encode_octet_string(stream, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        octetstring_type = TemporaryID()
        return octetstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 4
        data_map['maximum_root_size'] = 4
        data_map['width_length_unaligned'] = 0
        data_map['width_length_aligned'] = 0
        data_map['align_length'] = False

        value = osspy.per.decode_octet_string(stream, **data_map)

        if self._contents_constrait is not None:
            func = getattr(self._contents_constrait, 'decode')
            bin_val = bytearray.fromhex(value)
            tmpstream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, tmpstream, value_tracker)
                tmpstream.ensure_not_beyond_end_of_stream()

                if tmpstream.is_eof():
                    value = valcontaining
                else:
                    tmpstream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        octetstring_type = TemporaryID()
        return octetstring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class TermDistance:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "1..30000","permitted":[(1,30000)]}}]
        self._unique_indetifier = "DSRC.TermDistance"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = TermDistance()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 1
        data_map['maximum'] = 30000

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = TermDistance()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 1
        data_map['maximum'] = 30000

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = TermDistance()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class TermTime:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "1..1800","permitted":[(1,1800)]}}]
        self._unique_indetifier = "DSRC.TermTime"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = TermTime()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 11
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 1
        data_map['maximum'] = 1800

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = TermTime()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 11
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 1
        data_map['maximum'] = 1800

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = TermTime()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class ThrottleConfidence:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.ThrottleConfidence"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "prec10percent": 1, "prec1percent": 2, "prec0-5percent": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = ThrottleConfidence()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = ThrottleConfidence()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = ThrottleConfidence()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class TimeConfidence:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.TimeConfidence"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "time-100-000": 1, "time-050-000": 2, "time-020-000": 3, "time-010-000": 4, "time-002-000": 5, "time-001-000": 6, "time-000-500": 7, "time-000-200": 8, "time-000-100": 9, "time-000-050": 10, "time-000-020": 11, "time-000-010": 12, "time-000-005": 13, "time-000-002": 14, "time-000-001": 15, "time-000-000-5": 16, "time-000-000-2": 17, "time-000-000-1": 18, "time-000-000-05": 19, "time-000-000-02": 20, "time-000-000-01": 21, "time-000-000-005": 22, "time-000-000-002": 23, "time-000-000-001": 24, "time-000-000-000-5": 25, "time-000-000-000-2": 26, "time-000-000-000-1": 27, "time-000-000-000-05": 28, "time-000-000-000-02": 29, "time-000-000-000-01": 30, "time-000-000-000-005": 31, "time-000-000-000-002": 32, "time-000-000-000-001": 33, "time-000-000-000-000-5": 34, "time-000-000-000-000-2": 35, "time-000-000-000-000-1": 36, "time-000-000-000-000-05": 37, "time-000-000-000-000-02": 38, "time-000-000-000-000-01": 39}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = TimeConfidence()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 6
        data_map['width_index_aligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = TimeConfidence()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 6
        data_map['width_index_aligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = TimeConfidence()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class TimeMark:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..36001","permitted":[(0,36001)]}}]
        self._unique_indetifier = "DSRC.TimeMark"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = TimeMark()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 36001

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = TimeMark()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 36001

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = TimeMark()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class TimeOffset:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "1..65535","permitted":[(1,65535)]}}]
        self._unique_indetifier = "DSRC.TimeOffset"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = TimeOffset()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 1
        data_map['maximum'] = 65535

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = TimeOffset()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 1
        data_map['maximum'] = 65535

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = TimeOffset()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

Year = TimeOffset

class TransitStatus:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(6)","isBitString":"True","permitted":[(6,6)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.TransitStatus"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = TransitStatus()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 6
        data_map['maximum_root_size'] = 6
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = TransitStatus()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 6
        data_map['maximum_root_size'] = 6
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = TransitStatus()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class TransitVehicleOccupancy:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.TransitVehicleOccupancy"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"occupancyUnknown": 0, "occupancyEmpty": 1, "occupancyVeryLow": 2, "occupancyLow": 3, "occupancyMed": 4, "occupancyHigh": 5, "occupancyNearlyFull": 6, "occupancyFull": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = TransitVehicleOccupancy()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = TransitVehicleOccupancy()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = TransitVehicleOccupancy()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class GNSSstatus:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(8)","isBitString":"True","permitted":[(8,8)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.GNSSstatus"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = GNSSstatus()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 8
        data_map['maximum_root_size'] = 8
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = GNSSstatus()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 8
        data_map['maximum_root_size'] = 8
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = GNSSstatus()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

TransitVehicleStatus = GNSSstatus

class TransmissionState:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.TransmissionState"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"neutral": 0, "park": 1, "forwardGears": 2, "reverseGears": 3, "reserved1": 4, "reserved2": 5, "reserved3": 6, "unavailable": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = TransmissionState()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = TransmissionState()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = TransmissionState()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class TravelerInfoType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.TravelerInfoType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unknown": 0, "advisory": 1, "roadSignage": 2, "commercialSignage": 3}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = TravelerInfoType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = TravelerInfoType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = TravelerInfoType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class UniqueMSGID:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(9)","isOctetString":"True","permitted":[(9,9)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.UniqueMSGID"
        self._asn1Type = Asn1Type.OCTET_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        octetstring_type = UniqueMSGID()
        return octetstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 9
        data_map['maximum_root_size'] = 9
        data_map['width_length_unaligned'] = 0
        data_map['width_length_aligned'] = 0
        data_map['align_length'] = False

        bin_val = None
        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            bin_val = func(encoding_rule, value['containing'], value_tracker).get_buffer()
        else:
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc:
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc

        if bin_val is None:
            raise TypeError("63305: The 'plain octets' are missing from the octet string value!")

        osspy.per.encode_octet_string(stream, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        octetstring_type = UniqueMSGID()
        return octetstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 9
        data_map['maximum_root_size'] = 9
        data_map['width_length_unaligned'] = 0
        data_map['width_length_aligned'] = 0
        data_map['align_length'] = False

        value = osspy.per.decode_octet_string(stream, **data_map)

        if self._contents_constrait is not None:
            func = getattr(self._contents_constrait, 'decode')
            bin_val = bytearray.fromhex(value)
            tmpstream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, tmpstream, value_tracker)
                tmpstream.ensure_not_beyond_end_of_stream()

                if tmpstream.is_eof():
                    value = valcontaining
                else:
                    tmpstream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        octetstring_type = UniqueMSGID()
        return octetstring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class URL_Base:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"alphabet constraint","permitted":[[0,127]]}},{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1..45)","permitted":[(1,45)]}}]
        self._unique_indetifier = "DSRC.URL-Base"
        self._asn1Type = Asn1Type.String

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = URL_Base()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 45
        data_map['width_length_aligned'] = 6
        data_map['width_length_unaligned'] = 6
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        osspy.per.encode_string(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> str:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = URL_Base()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> str:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 45
        data_map['width_length_aligned'] = 6
        data_map['width_length_unaligned'] = 6
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        return osspy.per.decode_string(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = URL_Base()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class URL_Short:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"alphabet constraint","permitted":[[0,127]]}},{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1..15)","permitted":[(1,15)]}}]
        self._unique_indetifier = "DSRC.URL-Short"
        self._asn1Type = Asn1Type.String

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = URL_Short()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 15
        data_map['width_length_aligned'] = 4
        data_map['width_length_unaligned'] = 4
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        osspy.per.encode_string(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> str:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = URL_Short()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> str:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 15
        data_map['width_length_aligned'] = 4
        data_map['width_length_unaligned'] = 4
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        return osspy.per.decode_string(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = URL_Short()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class UserSizeAndBehaviour:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE (5, ...)","isBitString":"True","permitted":[(5,5)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.UserSizeAndBehaviour"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = UserSizeAndBehaviour()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 5
        data_map['maximum_root_size'] = 5
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = UserSizeAndBehaviour()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 5
        data_map['maximum_root_size'] = 5
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = UserSizeAndBehaviour()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class VehicleEventFlags:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE (13, ...)","isBitString":"True","permitted":[(13,13)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.VehicleEventFlags"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = VehicleEventFlags()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 13
        data_map['maximum_root_size'] = 13
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = VehicleEventFlags()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = True
        data_map['minimum_root_size'] = 13
        data_map['maximum_root_size'] = 13
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = VehicleEventFlags()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DYear:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0.. 4095","permitted":[(0,4095)]}}]
        self._unique_indetifier = "DSRC.DYear"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DYear()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 4095

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DYear()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 4095

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DYear()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

Radius_B12 = DYear
VehicleLength = DYear

class AmbientAirPressure:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..255","permitted":[(0,255)]}}]
        self._unique_indetifier = "DSRC.AmbientAirPressure"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = AmbientAirPressure()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 255

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = AmbientAirPressure()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 255

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = AmbientAirPressure()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

AxleLocation = AmbientAirPressure
BasicVehicleClass = AmbientAirPressure
Day = AmbientAirPressure
DriveAxleLocation = AmbientAirPressure
Hour = AmbientAirPressure
LaneConnectionID = AmbientAirPressure
LaneID = AmbientAirPressure
Minute = AmbientAirPressure
MsgCount__A = AmbientAirPressure
RegionId = AmbientAirPressure
RequestID = AmbientAirPressure
RestrictionClassID = AmbientAirPressure
SemiMajorAxisAccuracy = AmbientAirPressure
SemiMinorAxisAccuracy = AmbientAirPressure
SignalGroupID = AmbientAirPressure
TireLocation = AmbientAirPressure
TrailerMass = AmbientAirPressure
VehicleMass = AmbientAirPressure
Sample__1 = AmbientAirPressure
Sample__3 = AmbientAirPressure

class VehicleStatusDeviceTypeTag:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleStatusDeviceTypeTag"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unknown": 0, "lights": 1, "wipers": 2, "brakes": 3, "stab": 4, "trac": 5, "abs": 6, "sunS": 7, "rainS": 8, "airTemp": 9, "steering": 10, "vertAccelThres": 11, "vertAccel": 12, "hozAccelLong": 13, "hozAccelLat": 14, "hozAccelCon": 15, "accel4way": 16, "confidenceSet": 17, "obDist": 18, "obDirect": 19, "yaw": 20, "yawRateCon": 21, "dateTime": 22, "fullPos": 23, "position2D": 24, "position3D": 25, "vehicle": 26, "speedHeadC": 27, "speedC": 28}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = VehicleStatusDeviceTypeTag()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 5
        data_map['width_index_aligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = VehicleStatusDeviceTypeTag()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 5
        data_map['width_index_aligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = VehicleStatusDeviceTypeTag()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class VehicleType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.VehicleType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"none": 0, "unknown": 1, "special": 2, "moto": 3, "car": 4, "carOther": 5, "bus": 6, "axleCnt2": 7, "axleCnt3": 8, "axleCnt4": 9, "axleCnt4Trailer": 10, "axleCnt5Trailer": 11, "axleCnt6Trailer": 12, "axleCnt5MultiTrailer": 13, "axleCnt6MultiTrailer": 14, "axleCnt7MultiTrailer": 15}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = VehicleType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = VehicleType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = VehicleType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class Speed:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..8191","permitted":[(0,8191)]}}]
        self._unique_indetifier = "DSRC.Speed"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Speed()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 13
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 8191

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Speed()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 13
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 8191

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Speed()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

Velocity = Speed

class BrakeAppliedStatus:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(5)","isBitString":"True","permitted":[(5,5)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.BrakeAppliedStatus"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = BrakeAppliedStatus()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 5
        data_map['maximum_root_size'] = 5
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = BrakeAppliedStatus()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 5
        data_map['maximum_root_size'] = 5
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = BrakeAppliedStatus()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

VerticalAccelerationThreshold = BrakeAppliedStatus

class SteeringWheelAngleRateOfChange:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-127..127","permitted":[(-127,127)]}}]
        self._unique_indetifier = "DSRC.SteeringWheelAngleRateOfChange"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = SteeringWheelAngleRateOfChange()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -127
        data_map['maximum'] = 127

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = SteeringWheelAngleRateOfChange()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -127
        data_map['maximum'] = 127

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = SteeringWheelAngleRateOfChange()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

VerticalAcceleration = SteeringWheelAngleRateOfChange

class VertOffset_B07:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-64..63","permitted":[(-64,63)]}}]
        self._unique_indetifier = "DSRC.VertOffset-B07"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = VertOffset_B07()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 7
        data_map['width_value_unaligned'] = 7
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -64
        data_map['maximum'] = 63

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = VertOffset_B07()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 7
        data_map['width_value_unaligned'] = 7
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -64
        data_map['maximum'] = 63

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = VertOffset_B07()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DrivingWheelAngle:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-128..127","permitted":[(-128,127)]}}]
        self._unique_indetifier = "DSRC.DrivingWheelAngle"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DrivingWheelAngle()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -128
        data_map['maximum'] = 127

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DrivingWheelAngle()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -128
        data_map['maximum'] = 127

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DrivingWheelAngle()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

RoadwayCrownAngle = DrivingWheelAngle
VertOffset_B08 = DrivingWheelAngle

class Offset_B09:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-256..255","permitted":[(-256,255)]}}]
        self._unique_indetifier = "DSRC.Offset-B09"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Offset_B09()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 9
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -256
        data_map['maximum'] = 255

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Offset_B09()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 9
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -256
        data_map['maximum'] = 255

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Offset_B09()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

VertOffset_B09 = Offset_B09

class Offset_B10:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-512..511","permitted":[(-512,511)]}}]
        self._unique_indetifier = "DSRC.Offset-B10"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Offset_B10()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 10
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -512
        data_map['maximum'] = 511

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Offset_B10()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 10
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -512
        data_map['maximum'] = 511

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Offset_B10()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

VertOffset_B10 = Offset_B10

class VINstring:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1..17)","isOctetString":"True","permitted":[(1,17)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.VINstring"
        self._asn1Type = Asn1Type.OCTET_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        octetstring_type = VINstring()
        return octetstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 17
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False

        bin_val = None
        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            bin_val = func(encoding_rule, value['containing'], value_tracker).get_buffer()
        else:
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc:
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc

        if bin_val is None:
            raise TypeError("63305: The 'plain octets' are missing from the octet string value!")

        osspy.per.encode_octet_string(stream, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        octetstring_type = VINstring()
        return octetstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 17
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False

        value = osspy.per.decode_octet_string(stream, **data_map)

        if self._contents_constrait is not None:
            func = getattr(self._contents_constrait, 'decode')
            bin_val = bytearray.fromhex(value)
            tmpstream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, tmpstream, value_tracker)
                tmpstream.ensure_not_beyond_end_of_stream()

                if tmpstream.is_eof():
                    value = valcontaining
                else:
                    tmpstream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        octetstring_type = VINstring()
        return octetstring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class WiperStatus:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.WiperStatus"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "off": 1, "intermittent": 2, "low": 3, "high": 4, "washerInUse": 5, "automaticPresent": 6}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = WiperStatus()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = WiperStatus()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = WiperStatus()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class YawRateConfidence:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.YawRateConfidence"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unavailable": 0, "degSec-100-00": 1, "degSec-010-00": 2, "degSec-005-00": 3, "degSec-001-00": 4, "degSec-000-10": 5, "degSec-000-05": 6, "degSec-000-01": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = YawRateConfidence()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = YawRateConfidence()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = YawRateConfidence()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class ZoneLength:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..10000","permitted":[(0,10000)]}}]
        self._unique_indetifier = "DSRC.ZoneLength"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = ZoneLength()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 14
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 10000

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = ZoneLength()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 14
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 10000

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = ZoneLength()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class ApproachID:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..15","permitted":[(0,15)]}}]
        self._unique_indetifier = "DSRC.ApproachID"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = ApproachID()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 4
        data_map['width_value_unaligned'] = 4
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 15

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = ApproachID()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 4
        data_map['width_value_unaligned'] = 4
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 15

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = ApproachID()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

FuelType = ApproachID
TimeIntervalConfidence = ApproachID
Zoom = ApproachID

class BSMPSMParams:
    def __init__(self):
        self._comp_types = {"radius" : BSMPSMParams__1, "minimumTimeDelta" : BSMPSMParams__3, "minimumPosDelta" : BSMPSMParams__4}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.BSMPSMParams"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = BSMPSMParams()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('radius' in value and 'radius' not in self._def_vals):
            preamble_bits[0] = True
        elif ('radius' in value and 'radius' in self._def_vals):
            if not value_tracker.are_def_eq(value['radius'], self._def_vals['radius'], self._comp_types['radius']):
                preamble_bits[0] = True
        if ('minimumTimeDelta' in value and 'minimumTimeDelta' not in self._def_vals):
            preamble_bits[1] = True
        elif ('minimumTimeDelta' in value and 'minimumTimeDelta' in self._def_vals):
            if not value_tracker.are_def_eq(value['minimumTimeDelta'], self._def_vals['minimumTimeDelta'], self._comp_types['minimumTimeDelta']):
                preamble_bits[1] = True
        if ('minimumPosDelta' in value and 'minimumPosDelta' not in self._def_vals):
            preamble_bits[2] = True
        elif ('minimumPosDelta' in value and 'minimumPosDelta' in self._def_vals):
            if not value_tracker.are_def_eq(value['minimumPosDelta'], self._def_vals['minimumPosDelta'], self._comp_types['minimumPosDelta']):
                preamble_bits[2] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[0]:
            BSMPSMParams__1.encode(encoding_rule, value['radius'], value_tracker, stream)
        if preamble_bits[1]:
            BSMPSMParams__3.encode(encoding_rule, value['minimumTimeDelta'], value_tracker, stream)
        if preamble_bits[2]:
            BSMPSMParams__4.encode(encoding_rule, value['minimumPosDelta'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = BSMPSMParams()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 3

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[0]:
            value['radius'] = BSMPSMParams__1.decode(encoding_rule, stream, value_tracker)
        elif 'radius' in self._def_vals:
            value['radius'] = self._def_vals['radius']
        if preamble_bits[1]:
            value['minimumTimeDelta'] = BSMPSMParams__3.decode(encoding_rule, stream, value_tracker)
        elif 'minimumTimeDelta' in self._def_vals:
            value['minimumTimeDelta'] = self._def_vals['minimumTimeDelta']
        if preamble_bits[2]:
            value['minimumPosDelta'] = BSMPSMParams__4.decode(encoding_rule, stream, value_tracker)
        elif 'minimumPosDelta' in self._def_vals:
            value['minimumPosDelta'] = self._def_vals['minimumPosDelta']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = BSMPSMParams()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'radius' in value:
            BSMPSMParams__1.validate(value['radius'], errors, '{}/{}'.format(comp_path ,'radius'))
        if 'minimumTimeDelta' in value:
            BSMPSMParams__3.validate(value['minimumTimeDelta'], errors, '{}/{}'.format(comp_path ,'minimumTimeDelta'))
        if 'minimumPosDelta' in value:
            BSMPSMParams__4.validate(value['minimumPosDelta'], errors, '{}/{}'.format(comp_path ,'minimumPosDelta'))

        return errors

class BSMPSMParams__3:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.BSMPSMParams.minimumTimeDelta"
        self._asn1Type = Asn1Type.REAL

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = BSMPSMParams__3()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        osspy.per.encode_real(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> Union[float, str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = BSMPSMParams__3()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> Union[float, str, dict]:
        data_map = {}

        return osspy.per.decode_real(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = BSMPSMParams__3()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class BSMPSMParams__4:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.BSMPSMParams.minimumPosDelta"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = BSMPSMParams__4()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = None
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = None
        data_map['maximum'] = None

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = BSMPSMParams__4()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = None
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = None
        data_map['maximum'] = None

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = BSMPSMParams__4()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class MAPSPaTParams:
    def __init__(self):
        self._comp_types = {"locationFilter" : LocationFilter, "radius" : BSMPSMParams__1}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.MAPSPaTParams"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = MAPSPaTParams()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('locationFilter' in value and 'locationFilter' not in self._def_vals):
            preamble_bits[0] = True
        elif ('locationFilter' in value and 'locationFilter' in self._def_vals):
            if not value_tracker.are_def_eq(value['locationFilter'], self._def_vals['locationFilter'], self._comp_types['locationFilter']):
                preamble_bits[0] = True
        if ('radius' in value and 'radius' not in self._def_vals):
            preamble_bits[1] = True
        elif ('radius' in value and 'radius' in self._def_vals):
            if not value_tracker.are_def_eq(value['radius'], self._def_vals['radius'], self._comp_types['radius']):
                preamble_bits[1] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[0]:
            LocationFilter.encode(encoding_rule, value['locationFilter'], value_tracker, stream)
        if preamble_bits[1]:
            BSMPSMParams__1.encode(encoding_rule, value['radius'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = MAPSPaTParams()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[0]:
            value['locationFilter'] = LocationFilter.decode(encoding_rule, stream, value_tracker)
        elif 'locationFilter' in self._def_vals:
            value['locationFilter'] = self._def_vals['locationFilter']
        if preamble_bits[1]:
            value['radius'] = BSMPSMParams__1.decode(encoding_rule, stream, value_tracker)
        elif 'radius' in self._def_vals:
            value['radius'] = self._def_vals['radius']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = MAPSPaTParams()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'locationFilter' in value:
            LocationFilter.validate(value['locationFilter'], errors, '{}/{}'.format(comp_path ,'locationFilter'))
        if 'radius' in value:
            BSMPSMParams__1.validate(value['radius'], errors, '{}/{}'.format(comp_path ,'radius'))

        return errors

class BSMPSMParams__1:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "1..1500","permitted":[(1,1500)]}}]
        self._unique_indetifier = "DSRC.BSMPSMParams.radius"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = BSMPSMParams__1()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 11
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 1
        data_map['maximum'] = 1500

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = BSMPSMParams__1()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 11
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 1
        data_map['maximum'] = 1500

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = BSMPSMParams__1()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

MAPSPaTParams__2 = BSMPSMParams__1

class LocationFilter:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.LocationFilter"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"radius": 0, "ahead": 1, "none": 2}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = LocationFilter()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = LocationFilter()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = LocationFilter()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class SignalAheadParams:
    def __init__(self):
        self._comp_types = {"scope" : Scope}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SignalAheadParams"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SignalAheadParams()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('scope' in value and 'scope' not in self._def_vals):
            preamble_bits[0] = True
        elif ('scope' in value and 'scope' in self._def_vals):
            if not value_tracker.are_def_eq(value['scope'], self._def_vals['scope'], self._comp_types['scope']):
                preamble_bits[0] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[0]:
            Scope.encode(encoding_rule, value['scope'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SignalAheadParams()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[0]:
            value['scope'] = Scope.decode(encoding_rule, stream, value_tracker)
        elif 'scope' in self._def_vals:
            value['scope'] = self._def_vals['scope']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SignalAheadParams()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'scope' in value:
            Scope.validate(value['scope'], errors, '{}/{}'.format(comp_path ,'scope'))

        return errors

class Scope:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.Scope"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"intersection": 0, "currentDirection": 1}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = Scope()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = 1
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = Scope()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = 1
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = Scope()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class DataRequestMessage:
    def __init__(self):
        self._comp_types = {"apiDeveloperKey" : DataRequestMessage__1, "id" : TemporaryID, "elems" : DataRequestMessage__4}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DataRequestMessage"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DataRequestMessage()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'apiDeveloperKey' in value:
            DataRequestMessage__1.encode(encoding_rule, value['apiDeveloperKey'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'id' in value:
            TemporaryID.encode(encoding_rule, value['id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'elems' in value:
            DataRequestMessage__4.encode(encoding_rule, value['elems'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DataRequestMessage()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['apiDeveloperKey'] = DataRequestMessage__1.decode(encoding_rule, stream, value_tracker)
        value['id'] = TemporaryID.decode(encoding_rule, stream, value_tracker)
        value['elems'] = DataRequestMessage__4.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DataRequestMessage()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'apiDeveloperKey' in value:
            DataRequestMessage__1.validate(value['apiDeveloperKey'], errors, '{}/{}'.format(comp_path ,'apiDeveloperKey'))
        elif 'apiDeveloperKey' not in value:
            report_missing_field(type(self).__name__, 'apiDeveloperKey', errors, comp_path)
        if 'id' in value:
            TemporaryID.validate(value['id'], errors, '{}/{}'.format(comp_path ,'id'))
        elif 'id' not in value:
            report_missing_field(type(self).__name__, 'id', errors, comp_path)
        if 'elems' in value:
            DataRequestMessage__4.validate(value['elems'], errors, '{}/{}'.format(comp_path ,'elems'))
        elif 'elems' not in value:
            report_missing_field(type(self).__name__, 'elems', errors, comp_path)

        return errors

class DataRequestMessage__1:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"alphabet constraint","permitted":[[0,127]]}}]
        self._unique_indetifier = "DSRC.DataRequestMessage.apiDeveloperKey"
        self._asn1Type = Asn1Type.String

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DataRequestMessage__1()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 0
        data_map['maximum_root_size'] = None
        data_map['width_length_aligned'] = None
        data_map['width_length_unaligned'] = None
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        osspy.per.encode_string(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> str:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DataRequestMessage__1()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> str:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 0
        data_map['maximum_root_size'] = None
        data_map['width_length_aligned'] = None
        data_map['width_length_unaligned'] = None
        data_map['align_length'] = False
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        return osspy.per.decode_string(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DataRequestMessage__1()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

DataRequestResponse__2 = DataRequestMessage__1
StatusMessage__1 = DataRequestMessage__1
StatusMessage__2 = DataRequestMessage__1

class DataRequestMessage__4:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(0,10)]}}]
        self._unique_indetifier = "DSRC.DataRequestMessage.elems"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                DataRequestElement.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                DataRequestElement.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(DataRequestElement.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = DataRequestMessage__4()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 0
        data_map['maximum_root_size'] = 10
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(DataRequestElement.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = DataRequestMessage__4()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 0
        data_map['maximum_root_size'] = 10
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = DataRequestMessage__4()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                DataRequestElement.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class DataRequestElement:
    def __init__(self):
        self._comp_types = {"messageType" : DataRequestElement__1, "parameters" : DataRequestElement__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DataRequestElement"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DataRequestElement()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'messageType' in value:
            DataRequestElement__1.encode(encoding_rule, value['messageType'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'parameters' in value:
            DataRequestElement__2.encode(encoding_rule, value['parameters'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DataRequestElement()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['messageType'] = DataRequestElement__1.decode(encoding_rule, stream, value_tracker)
        value['parameters'] = DataRequestElement__2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DataRequestElement()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'messageType' in value:
            DataRequestElement__1.validate(value['messageType'], errors, '{}/{}'.format(comp_path ,'messageType'))
        elif 'messageType' not in value:
            report_missing_field(type(self).__name__, 'messageType', errors, comp_path)
        if 'parameters' in value:
            DataRequestElement__2.validate(value['parameters'], errors, '{}/{}'.format(comp_path ,'parameters'))
        elif 'parameters' not in value:
            report_missing_field(type(self).__name__, 'parameters', errors, comp_path)

        return errors

class DataRequestElement__1:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "{ParameterTypes}","permitted":[(0,32767)]}},{"type":"simple table constraint","isExtensible": False,"fields":{"type":"constraint union","constraints":[{"type":"single value","permitted": 20},{"type":"single value","permitted": 19},{"type":"single value","permitted": 240}]}}]
        self._unique_indetifier = "DSRC.DataRequestElement.messageType"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DataRequestElement__1()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 32767

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DataRequestElement__1()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 15
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 32767

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DataRequestElement__1()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DataRequestElement__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.DataRequestElement.parameters"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = DataRequestElement__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["messageType"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded and value is not None and value_tracker.are_equivalent([20], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                BSMPSMParams.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([19], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                MAPSPaTParams.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([240], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                SignalAheadParams.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = DataRequestElement__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["messageType"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            if (not is_decoded and value_tracker.are_equivalent([20], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = BSMPSMParams.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([19], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = MAPSPaTParams.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([240], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = SignalAheadParams.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = DataRequestElement__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DataRequestResponse:
    def __init__(self):
        self._comp_types = {"failure" : IsDolly, "message" : DataRequestMessage__1}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DataRequestResponse"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DataRequestResponse()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('message' in value and 'message' not in self._def_vals):
            preamble_bits[0] = True
        elif ('message' in value and 'message' in self._def_vals):
            if not value_tracker.are_def_eq(value['message'], self._def_vals['message'], self._comp_types['message']):
                preamble_bits[0] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'failure' in value:
            IsDolly.encode(encoding_rule, value['failure'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            DataRequestMessage__1.encode(encoding_rule, value['message'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DataRequestResponse()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['failure'] = IsDolly.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['message'] = DataRequestMessage__1.decode(encoding_rule, stream, value_tracker)
        elif 'message' in self._def_vals:
            value['message'] = self._def_vals['message']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DataRequestResponse()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'failure' in value:
            IsDolly.validate(value['failure'], errors, '{}/{}'.format(comp_path ,'failure'))
        elif 'failure' not in value:
            report_missing_field(type(self).__name__, 'failure', errors, comp_path)
        if 'message' in value:
            DataRequestMessage__1.validate(value['message'], errors, '{}/{}'.format(comp_path ,'message'))

        return errors

class IsDolly:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.IsDolly"
        self._asn1Type = Asn1Type.BOOLEAN

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = IsDolly()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        osspy.per.encode_boolean(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> bool:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = IsDolly()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> bool:
        data_map = {}

        return osspy.per.decode_boolean(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = IsDolly()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

PedestrianBicycleDetect = IsDolly
PersonalCrossingInProgress = IsDolly
PersonalCrossingRequest = IsDolly
PivotingAllowed = IsDolly
WaitOnStopline = IsDolly
DataRequestResponse__1 = IsDolly
GeographicalPath__6 = IsDolly
VehicleStatusRequest__8 = IsDolly

class StatusMessage:
    def __init__(self):
        self._comp_types = {"severity" : DataRequestMessage__1, "message" : DataRequestMessage__1}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.StatusMessage"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = StatusMessage()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'severity' in value:
            DataRequestMessage__1.encode(encoding_rule, value['severity'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'message' in value:
            DataRequestMessage__1.encode(encoding_rule, value['message'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = StatusMessage()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['severity'] = DataRequestMessage__1.decode(encoding_rule, stream, value_tracker)
        value['message'] = DataRequestMessage__1.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = StatusMessage()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'severity' in value:
            DataRequestMessage__1.validate(value['severity'], errors, '{}/{}'.format(comp_path ,'severity'))
        elif 'severity' not in value:
            report_missing_field(type(self).__name__, 'severity', errors, comp_path)
        if 'message' in value:
            DataRequestMessage__1.validate(value['message'], errors, '{}/{}'.format(comp_path ,'message'))
        elif 'message' not in value:
            report_missing_field(type(self).__name__, 'message', errors, comp_path)

        return errors

class DisconnectMessage:
    def __init__(self):
        self._comp_types = {}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.DisconnectMessage"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = DisconnectMessage()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = DisconnectMessage()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = DisconnectMessage()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        return errors

class SignalAheadMessage:
    def __init__(self):
        self._comp_types = {"timeStamp" : MinuteOfTheYear, "intersectionName" : DescriptiveName, "intersectionId" : IntersectionReferenceID, "refPoint" : Position3D, "movements" : MovementAndManeuverList}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.SignalAheadMessage"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SignalAheadMessage()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('timeStamp' in value and 'timeStamp' not in self._def_vals):
            preamble_bits[0] = True
        elif ('timeStamp' in value and 'timeStamp' in self._def_vals):
            if not value_tracker.are_def_eq(value['timeStamp'], self._def_vals['timeStamp'], self._comp_types['timeStamp']):
                preamble_bits[0] = True
        if ('intersectionName' in value and 'intersectionName' not in self._def_vals):
            preamble_bits[1] = True
        elif ('intersectionName' in value and 'intersectionName' in self._def_vals):
            if not value_tracker.are_def_eq(value['intersectionName'], self._def_vals['intersectionName'], self._comp_types['intersectionName']):
                preamble_bits[1] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[0]:
            MinuteOfTheYear.encode(encoding_rule, value['timeStamp'], value_tracker, stream)
        if preamble_bits[1]:
            DescriptiveName.encode(encoding_rule, value['intersectionName'], value_tracker, stream)
        if 'intersectionId' in value:
            IntersectionReferenceID.encode(encoding_rule, value['intersectionId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'refPoint' in value:
            Position3D.encode(encoding_rule, value['refPoint'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'movements' in value:
            MovementAndManeuverList.encode(encoding_rule, value['movements'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SignalAheadMessage()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 2

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[0]:
            value['timeStamp'] = MinuteOfTheYear.decode(encoding_rule, stream, value_tracker)
        elif 'timeStamp' in self._def_vals:
            value['timeStamp'] = self._def_vals['timeStamp']
        if preamble_bits[1]:
            value['intersectionName'] = DescriptiveName.decode(encoding_rule, stream, value_tracker)
        elif 'intersectionName' in self._def_vals:
            value['intersectionName'] = self._def_vals['intersectionName']
        value['intersectionId'] = IntersectionReferenceID.decode(encoding_rule, stream, value_tracker)
        value['refPoint'] = Position3D.decode(encoding_rule, stream, value_tracker)
        value['movements'] = MovementAndManeuverList.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SignalAheadMessage()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'timeStamp' in value:
            MinuteOfTheYear.validate(value['timeStamp'], errors, '{}/{}'.format(comp_path ,'timeStamp'))
        if 'intersectionName' in value:
            DescriptiveName.validate(value['intersectionName'], errors, '{}/{}'.format(comp_path ,'intersectionName'))
        if 'intersectionId' in value:
            IntersectionReferenceID.validate(value['intersectionId'], errors, '{}/{}'.format(comp_path ,'intersectionId'))
        elif 'intersectionId' not in value:
            report_missing_field(type(self).__name__, 'intersectionId', errors, comp_path)
        if 'refPoint' in value:
            Position3D.validate(value['refPoint'], errors, '{}/{}'.format(comp_path ,'refPoint'))
        elif 'refPoint' not in value:
            report_missing_field(type(self).__name__, 'refPoint', errors, comp_path)
        if 'movements' in value:
            MovementAndManeuverList.validate(value['movements'], errors, '{}/{}'.format(comp_path ,'movements'))
        elif 'movements' not in value:
            report_missing_field(type(self).__name__, 'movements', errors, comp_path)

        return errors

class MovementAndManeuverList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,255)]}}]
        self._unique_indetifier = "DSRC.MovementAndManeuverList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                MovementAndManeuver.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                MovementAndManeuver.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(MovementAndManeuver.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = MovementAndManeuverList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 255
        data_map['width_length_unaligned'] = 8
        data_map['width_length_aligned'] = 8
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(MovementAndManeuver.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = MovementAndManeuverList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 255
        data_map['width_length_unaligned'] = 8
        data_map['width_length_aligned'] = 8
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = MovementAndManeuverList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                MovementAndManeuver.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class MovementAndManeuver:
    def __init__(self):
        self._comp_types = {"signalGroup" : AmbientAirPressure, "maneuvers" : Maneuvers, "state-time-speed" : MovementEventList}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "DSRC.MovementAndManeuver"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = MovementAndManeuver()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'signalGroup' in value:
            AmbientAirPressure.encode(encoding_rule, value['signalGroup'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'maneuvers' in value:
            Maneuvers.encode(encoding_rule, value['maneuvers'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'state-time-speed' in value:
            MovementEventList.encode(encoding_rule, value['state-time-speed'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = MovementAndManeuver()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['signalGroup'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['maneuvers'] = Maneuvers.decode(encoding_rule, stream, value_tracker)
        value['state-time-speed'] = MovementEventList.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = MovementAndManeuver()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'signalGroup' in value:
            AmbientAirPressure.validate(value['signalGroup'], errors, '{}/{}'.format(comp_path ,'signalGroup'))
        elif 'signalGroup' not in value:
            report_missing_field(type(self).__name__, 'signalGroup', errors, comp_path)
        if 'maneuvers' in value:
            Maneuvers.validate(value['maneuvers'], errors, '{}/{}'.format(comp_path ,'maneuvers'))
        elif 'maneuvers' not in value:
            report_missing_field(type(self).__name__, 'maneuvers', errors, comp_path)
        if 'state-time-speed' in value:
            MovementEventList.validate(value['state-time-speed'], errors, '{}/{}'.format(comp_path ,'state-time-speed'))
        elif 'state-time-speed' not in value:
            report_missing_field(type(self).__name__, 'state-time-speed', errors, comp_path)

        return errors

class Maneuvers:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(4)","isBitString":"True","permitted":[(4,4)]}}]
        self._contents_constrait = None
        self._unique_indetifier = "DSRC.Maneuvers"
        self._asn1Type = Asn1Type.BIT_STRING

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        bitstring_type = Maneuvers()
        return bitstring_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Union[str, dict], value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        bin_val = None
        length = None

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 4
        data_map['maximum_root_size'] = 4
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        if (self._contents_constrait is not None and isinstance(value, dict) and 'containing' in value):
            func = getattr(self._contents_constrait, 'encode')
            tmpstream = osspy.per.encodingstream(encoding_rule)
            value = func(encoding_rule, value['containing'], value_tracker, tmpstream).get_buffer()
            length = tmpstream.get_bit_length()

            if length is not None:
                value = {"length": length, "value": value.hex().upper()}

        if isinstance(value, str):
            try:
                bin_val = bytearray.fromhex(value)
            except Exception as exc: #pylint: disable=broad-except
                raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, dict):
            if 'value' not in value or 'length' not in value:
                raise TypeError("62105: The 'plain bits' are missing from the bit string value!")
            else:
                try:
                    bin_val = bytearray.fromhex(value['value'])
                    length = int(value["length"])
                except Exception as exc: #pylint: disable=broad-except
                    raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!") from exc
        elif isinstance(value, bytearray):
            bin_val = value
        else:
            raise TypeError("62105: The 'plain bits' are missing from the bit string value!")

        osspy.per.encode_bit_string(stream, length, bin_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        bitstring_type = Maneuvers()
        return bitstring_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, dict]:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 4
        data_map['maximum_root_size'] = 4
        data_map['width_length_aligned'] = 0
        data_map['width_length_unaligned'] = 0
        data_map['align_length'] = False
        data_map['has_named_bits'] = True

        value = osspy.per.decode_bit_string(stream, **data_map)

        if self._contents_constrait is not None:
            bin_val = None
            if isinstance(value, dict):
                bin_val = bytearray()
                bin_val = bytearray.fromhex(value['value'])
            elif isinstance(value, str):
                bin_val = bytearray.fromhex(value)

            func = getattr(self._contents_constrait, 'decode')
            stream = osspy.per.decodingstream(bin_val, encoding_rule)
            try:
                valcontaining = {}
                current_depth = value_tracker.depth
                valcontaining['containing'] = func(encoding_rule, stream, value_tracker)
                stream.ensure_not_beyond_end_of_stream()

                if stream.is_eof():
                    value = valcontaining
                else:
                    stream.seek_final()
            except Exception as _exc: #pylint: disable=broad-except
                warn("63302: The value contained in the octet string value could not be decoded!")
                value_tracker.depth = current_depth

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        bistring_type = Maneuvers()
        return bistring_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class AltitudeConfidence:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "AddGrpC.AltitudeConfidence"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"alt-000-01": 0, "alt-000-02": 1, "alt-000-05": 2, "alt-000-10": 3, "alt-000-20": 4, "alt-000-50": 5, "alt-001-00": 6, "alt-002-00": 7, "alt-005-00": 8, "alt-010-00": 9, "alt-020-00": 10, "alt-050-00": 11, "alt-100-00": 12, "alt-200-00": 13, "outOfRange": 14, "unavailable": 15}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = AltitudeConfidence()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = AltitudeConfidence()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = AltitudeConfidence()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class AltitudeValue:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-100000..800001","permitted":[(-100000,800001)]}}]
        self._unique_indetifier = "AddGrpC.AltitudeValue"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = AltitudeValue()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 20
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -100000
        data_map['maximum'] = 800001

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = AltitudeValue()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 20
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -100000
        data_map['maximum'] = 800001

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = AltitudeValue()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class EmissionType:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "AddGrpC.EmissionType"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"typeA": 0, "typeB": 1, "typeC": 2, "typeD": 3, "typeE": 4}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = EmissionType()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = EmissionType()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = EmissionType()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class Altitude:
    def __init__(self):
        self._comp_types = {"value" : AltitudeValue, "confidence" : AltitudeConfidence}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpC.Altitude"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Altitude()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'value' in value:
            AltitudeValue.encode(encoding_rule, value['value'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'confidence' in value:
            AltitudeConfidence.encode(encoding_rule, value['confidence'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Altitude()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['value'] = AltitudeValue.decode(encoding_rule, stream, value_tracker)
        value['confidence'] = AltitudeConfidence.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Altitude()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'value' in value:
            AltitudeValue.validate(value['value'], errors, '{}/{}'.format(comp_path ,'value'))
        elif 'value' not in value:
            report_missing_field(type(self).__name__, 'value', errors, comp_path)
        if 'confidence' in value:
            AltitudeConfidence.validate(value['confidence'], errors, '{}/{}'.format(comp_path ,'confidence'))
        elif 'confidence' not in value:
            report_missing_field(type(self).__name__, 'confidence', errors, comp_path)

        return errors

class PrioritizationResponse:
    def __init__(self):
        self._comp_types = {"stationID" : StationID, "priorState" : PrioritizationResponseStatus, "signalGroup" : AmbientAirPressure}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpC.PrioritizationResponse"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = PrioritizationResponse()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'stationID' in value:
            StationID.encode(encoding_rule, value['stationID'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'priorState' in value:
            PrioritizationResponseStatus.encode(encoding_rule, value['priorState'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'signalGroup' in value:
            AmbientAirPressure.encode(encoding_rule, value['signalGroup'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = PrioritizationResponse()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['stationID'] = StationID.decode(encoding_rule, stream, value_tracker)
        value['priorState'] = PrioritizationResponseStatus.decode(encoding_rule, stream, value_tracker)
        value['signalGroup'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = PrioritizationResponse()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'stationID' in value:
            StationID.validate(value['stationID'], errors, '{}/{}'.format(comp_path ,'stationID'))
        elif 'stationID' not in value:
            report_missing_field(type(self).__name__, 'stationID', errors, comp_path)
        if 'priorState' in value:
            PrioritizationResponseStatus.validate(value['priorState'], errors, '{}/{}'.format(comp_path ,'priorState'))
        elif 'priorState' not in value:
            report_missing_field(type(self).__name__, 'priorState', errors, comp_path)
        if 'signalGroup' in value:
            AmbientAirPressure.validate(value['signalGroup'], errors, '{}/{}'.format(comp_path ,'signalGroup'))
        elif 'signalGroup' not in value:
            report_missing_field(type(self).__name__, 'signalGroup', errors, comp_path)

        return errors

class PrioritizationResponseList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,10)]}}]
        self._unique_indetifier = "AddGrpC.PrioritizationResponseList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                PrioritizationResponse.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                PrioritizationResponse.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(PrioritizationResponse.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = PrioritizationResponseList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 10
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(PrioritizationResponse.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = PrioritizationResponseList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 10
        data_map['width_length_unaligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = PrioritizationResponseList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                PrioritizationResponse.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class ConnectionManeuverAssist_addGrpC:
    def __init__(self):
        self._comp_types = {"vehicleToLanePositions" : VehicleToLanePositionList, "rsuDistanceFromAnchor" : NodeOffsetPointXY}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpC.ConnectionManeuverAssist-addGrpC"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ConnectionManeuverAssist_addGrpC()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('rsuDistanceFromAnchor' in value and 'rsuDistanceFromAnchor' not in self._def_vals):
            preamble_bits[0] = True
        elif ('rsuDistanceFromAnchor' in value and 'rsuDistanceFromAnchor' in self._def_vals):
            if not value_tracker.are_def_eq(value['rsuDistanceFromAnchor'], self._def_vals['rsuDistanceFromAnchor'], self._comp_types['rsuDistanceFromAnchor']):
                preamble_bits[0] = True

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'vehicleToLanePositions' in value:
            VehicleToLanePositionList.encode(encoding_rule, value['vehicleToLanePositions'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[0]:
            NodeOffsetPointXY.encode(encoding_rule, value['rsuDistanceFromAnchor'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ConnectionManeuverAssist_addGrpC()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['vehicleToLanePositions'] = VehicleToLanePositionList.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[0]:
            value['rsuDistanceFromAnchor'] = NodeOffsetPointXY.decode(encoding_rule, stream, value_tracker)
        elif 'rsuDistanceFromAnchor' in self._def_vals:
            value['rsuDistanceFromAnchor'] = self._def_vals['rsuDistanceFromAnchor']

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ConnectionManeuverAssist_addGrpC()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'vehicleToLanePositions' in value:
            VehicleToLanePositionList.validate(value['vehicleToLanePositions'], errors, '{}/{}'.format(comp_path ,'vehicleToLanePositions'))
        elif 'vehicleToLanePositions' not in value:
            report_missing_field(type(self).__name__, 'vehicleToLanePositions', errors, comp_path)
        if 'rsuDistanceFromAnchor' in value:
            NodeOffsetPointXY.validate(value['rsuDistanceFromAnchor'], errors, '{}/{}'.format(comp_path ,'rsuDistanceFromAnchor'))

        return errors

class IntersectionState_addGrpC:
    def __init__(self):
        self._comp_types = {"activePrioritizations" : PrioritizationResponseList}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpC.IntersectionState-addGrpC"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = IntersectionState_addGrpC()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('activePrioritizations' in value and 'activePrioritizations' not in self._def_vals):
            preamble_bits[0] = True
        elif ('activePrioritizations' in value and 'activePrioritizations' in self._def_vals):
            if not value_tracker.are_def_eq(value['activePrioritizations'], self._def_vals['activePrioritizations'], self._comp_types['activePrioritizations']):
                preamble_bits[0] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            PrioritizationResponseList.encode(encoding_rule, value['activePrioritizations'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = IntersectionState_addGrpC()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['activePrioritizations'] = PrioritizationResponseList.decode(encoding_rule, stream, value_tracker)
        elif 'activePrioritizations' in self._def_vals:
            value['activePrioritizations'] = self._def_vals['activePrioritizations']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = IntersectionState_addGrpC()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'activePrioritizations' in value:
            PrioritizationResponseList.validate(value['activePrioritizations'], errors, '{}/{}'.format(comp_path ,'activePrioritizations'))

        return errors

class MapData_addGrpC:
    def __init__(self):
        self._comp_types = {"signalHeadLocations" : SignalHeadLocationList}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpC.MapData-addGrpC"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = MapData_addGrpC()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('signalHeadLocations' in value and 'signalHeadLocations' not in self._def_vals):
            preamble_bits[0] = True
        elif ('signalHeadLocations' in value and 'signalHeadLocations' in self._def_vals):
            if not value_tracker.are_def_eq(value['signalHeadLocations'], self._def_vals['signalHeadLocations'], self._comp_types['signalHeadLocations']):
                preamble_bits[0] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            SignalHeadLocationList.encode(encoding_rule, value['signalHeadLocations'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = MapData_addGrpC()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['signalHeadLocations'] = SignalHeadLocationList.decode(encoding_rule, stream, value_tracker)
        elif 'signalHeadLocations' in self._def_vals:
            value['signalHeadLocations'] = self._def_vals['signalHeadLocations']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = MapData_addGrpC()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'signalHeadLocations' in value:
            SignalHeadLocationList.validate(value['signalHeadLocations'], errors, '{}/{}'.format(comp_path ,'signalHeadLocations'))

        return errors

class Position3D_addGrpC:
    def __init__(self):
        self._comp_types = {"altitude" : Altitude}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpC.Position3D-addGrpC"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Position3D_addGrpC()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'altitude' in value:
            Altitude.encode(encoding_rule, value['altitude'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Position3D_addGrpC()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['altitude'] = Altitude.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Position3D_addGrpC()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'altitude' in value:
            Altitude.validate(value['altitude'], errors, '{}/{}'.format(comp_path ,'altitude'))
        elif 'altitude' not in value:
            report_missing_field(type(self).__name__, 'altitude', errors, comp_path)

        return errors

class RestrictionUserType_addGrpC:
    def __init__(self):
        self._comp_types = {"emission" : EmissionType}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpC.RestrictionUserType-addGrpC"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RestrictionUserType_addGrpC()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('emission' in value and 'emission' not in self._def_vals):
            preamble_bits[0] = True
        elif ('emission' in value and 'emission' in self._def_vals):
            if not value_tracker.are_def_eq(value['emission'], self._def_vals['emission'], self._comp_types['emission']):
                preamble_bits[0] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            EmissionType.encode(encoding_rule, value['emission'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RestrictionUserType_addGrpC()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 1

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['emission'] = EmissionType.decode(encoding_rule, stream, value_tracker)
        elif 'emission' in self._def_vals:
            value['emission'] = self._def_vals['emission']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RestrictionUserType_addGrpC()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'emission' in value:
            EmissionType.validate(value['emission'], errors, '{}/{}'.format(comp_path ,'emission'))

        return errors

class SignalHeadLocation:
    def __init__(self):
        self._comp_types = {"node" : NodeOffsetPointXY, "signalGroupID" : AmbientAirPressure}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpC.SignalHeadLocation"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = SignalHeadLocation()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'node' in value:
            NodeOffsetPointXY.encode(encoding_rule, value['node'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'signalGroupID' in value:
            AmbientAirPressure.encode(encoding_rule, value['signalGroupID'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = SignalHeadLocation()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['node'] = NodeOffsetPointXY.decode(encoding_rule, stream, value_tracker)
        value['signalGroupID'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = SignalHeadLocation()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'node' in value:
            NodeOffsetPointXY.validate(value['node'], errors, '{}/{}'.format(comp_path ,'node'))
        elif 'node' not in value:
            report_missing_field(type(self).__name__, 'node', errors, comp_path)
        if 'signalGroupID' in value:
            AmbientAirPressure.validate(value['signalGroupID'], errors, '{}/{}'.format(comp_path ,'signalGroupID'))
        elif 'signalGroupID' not in value:
            report_missing_field(type(self).__name__, 'signalGroupID', errors, comp_path)

        return errors

class SignalHeadLocationList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,20)]}}]
        self._unique_indetifier = "AddGrpC.SignalHeadLocationList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                SignalHeadLocation.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                SignalHeadLocation.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(SignalHeadLocation.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = SignalHeadLocationList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 20
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(SignalHeadLocation.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = SignalHeadLocationList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 20
        data_map['width_length_unaligned'] = 5
        data_map['width_length_aligned'] = 5
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = SignalHeadLocationList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                SignalHeadLocation.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class VehicleToLanePosition:
    def __init__(self):
        self._comp_types = {"stationID" : StationID, "laneID" : AmbientAirPressure}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpC.VehicleToLanePosition"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = VehicleToLanePosition()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'stationID' in value:
            StationID.encode(encoding_rule, value['stationID'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'laneID' in value:
            AmbientAirPressure.encode(encoding_rule, value['laneID'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = VehicleToLanePosition()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['stationID'] = StationID.decode(encoding_rule, stream, value_tracker)
        value['laneID'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = VehicleToLanePosition()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'stationID' in value:
            StationID.validate(value['stationID'], errors, '{}/{}'.format(comp_path ,'stationID'))
        elif 'stationID' not in value:
            report_missing_field(type(self).__name__, 'stationID', errors, comp_path)
        if 'laneID' in value:
            AmbientAirPressure.validate(value['laneID'], errors, '{}/{}'.format(comp_path ,'laneID'))
        elif 'laneID' not in value:
            report_missing_field(type(self).__name__, 'laneID', errors, comp_path)

        return errors

class VehicleToLanePositionList:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,5)]}}]
        self._unique_indetifier = "AddGrpC.VehicleToLanePositionList"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                VehicleToLanePosition.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                VehicleToLanePosition.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(VehicleToLanePosition.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = VehicleToLanePositionList()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 5
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(VehicleToLanePosition.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = VehicleToLanePositionList()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 5
        data_map['width_length_unaligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = VehicleToLanePositionList()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                VehicleToLanePosition.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class Angle__A:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..239","permitted":[(0,239)]}}]
        self._unique_indetifier = "AddGrpB.Angle"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Angle__A()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 239

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Angle__A()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 239

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Angle__A()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DayOfWeek:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "AddGrpB.DayOfWeek"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"unknown": 0, "monday": 1, "tuesday": 2, "wednesday": 3, "thursday": 4, "friday": 5, "saturday": 6, "sunday": 7}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = DayOfWeek()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = DayOfWeek()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 3
        data_map['width_index_aligned'] = 3
        data_map['width_length_aligned'] = 3
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = DayOfWeek()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class DegreesLat:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-90..90","permitted":[(-90,90)]}}]
        self._unique_indetifier = "AddGrpB.DegreesLat"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DegreesLat()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -90
        data_map['maximum'] = 90

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DegreesLat()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -90
        data_map['maximum'] = 90

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DegreesLat()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class DegreesLong:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-180..180","permitted":[(-180,180)]}}]
        self._unique_indetifier = "AddGrpB.DegreesLong"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DegreesLong()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 9
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -180
        data_map['maximum'] = 180

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DegreesLong()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 9
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = -180
        data_map['maximum'] = 180

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DegreesLong()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

MergeDivergeNodeAngle = DegreesLong

class Holiday:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "AddGrpB.Holiday"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"weekday": 0, "holiday": 1}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = Holiday()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = 1
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = Holiday()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = 1
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = Holiday()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class LatitudeDMS:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-32400000.. 32400000","permitted":[(-32400000,32400000)]}}]
        self._unique_indetifier = "AddGrpB.LatitudeDMS"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = LatitudeDMS()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 26
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -32400000
        data_map['maximum'] = 32400000

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = LatitudeDMS()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 26
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -32400000
        data_map['maximum'] = 32400000

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = LatitudeDMS()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class LongitudeDMS:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "-64800000.. 64800000","permitted":[(-64800000,64800000)]}}]
        self._unique_indetifier = "AddGrpB.LongitudeDMS"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = LongitudeDMS()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 27
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -64800000
        data_map['maximum'] = 64800000

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = LongitudeDMS()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = None
        data_map['width_value_unaligned'] = 27
        data_map['width_length'] = 2
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = -64800000
        data_map['maximum'] = 64800000

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = LongitudeDMS()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class MaxTimetoChange:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..2402","permitted":[(0,2402)]}}]
        self._unique_indetifier = "AddGrpB.MaxTimetoChange"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = MaxTimetoChange()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 2402

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = MaxTimetoChange()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 12
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 2402

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = MaxTimetoChange()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

MinTimetoChange = MaxTimetoChange

class MinutesAngle:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..59","permitted":[(0,59)]}}]
        self._unique_indetifier = "AddGrpB.MinutesAngle"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = MinutesAngle()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 59

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = MinutesAngle()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 59

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = MinutesAngle()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class Month:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "1..255","permitted":[(1,255)]}}]
        self._unique_indetifier = "AddGrpB.Month"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = Month()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 1
        data_map['maximum'] = 255

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = Month()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 1
        data_map['maximum'] = 255

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = Month()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class SecondsAngle:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..5999","permitted":[(0,5999)]}}]
        self._unique_indetifier = "AddGrpB.SecondsAngle"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = SecondsAngle()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 13
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 5999

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = SecondsAngle()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 13
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 5999

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = SecondsAngle()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class SummerTime:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "AddGrpB.SummerTime"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"notInSummerTime": 0, "inSummerTime": 1}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = SummerTime()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = 1
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = SummerTime()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = 1
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = SummerTime()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class TenthSecond:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..9","permitted":[(0,9)]}}]
        self._unique_indetifier = "AddGrpB.TenthSecond"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = TenthSecond()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 4
        data_map['width_value_unaligned'] = 4
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 9

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = TenthSecond()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 4
        data_map['width_value_unaligned'] = 4
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 9

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = TenthSecond()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class TimeRemaining:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..9001","permitted":[(0,9001)]}}]
        self._unique_indetifier = "AddGrpB.TimeRemaining"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = TimeRemaining()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 14
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 9001

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = TimeRemaining()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 14
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 9001

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = TimeRemaining()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class LatitudeDMS2:
    def __init__(self):
        self._comp_types = {"d" : DegreesLat, "m" : MinutesAngle, "s" : SecondsAngle}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpB.LatitudeDMS2"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = LatitudeDMS2()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'd' in value:
            DegreesLat.encode(encoding_rule, value['d'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'm' in value:
            MinutesAngle.encode(encoding_rule, value['m'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 's' in value:
            SecondsAngle.encode(encoding_rule, value['s'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = LatitudeDMS2()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['d'] = DegreesLat.decode(encoding_rule, stream, value_tracker)
        value['m'] = MinutesAngle.decode(encoding_rule, stream, value_tracker)
        value['s'] = SecondsAngle.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = LatitudeDMS2()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'd' in value:
            DegreesLat.validate(value['d'], errors, '{}/{}'.format(comp_path ,'d'))
        elif 'd' not in value:
            report_missing_field(type(self).__name__, 'd', errors, comp_path)
        if 'm' in value:
            MinutesAngle.validate(value['m'], errors, '{}/{}'.format(comp_path ,'m'))
        elif 'm' not in value:
            report_missing_field(type(self).__name__, 'm', errors, comp_path)
        if 's' in value:
            SecondsAngle.validate(value['s'], errors, '{}/{}'.format(comp_path ,'s'))
        elif 's' not in value:
            report_missing_field(type(self).__name__, 's', errors, comp_path)

        return errors

class LongitudeDMS2:
    def __init__(self):
        self._comp_types = {"d" : DegreesLong, "m" : MinutesAngle, "s" : SecondsAngle}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpB.LongitudeDMS2"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = LongitudeDMS2()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'd' in value:
            DegreesLong.encode(encoding_rule, value['d'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'm' in value:
            MinutesAngle.encode(encoding_rule, value['m'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 's' in value:
            SecondsAngle.encode(encoding_rule, value['s'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = LongitudeDMS2()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['d'] = DegreesLong.decode(encoding_rule, stream, value_tracker)
        value['m'] = MinutesAngle.decode(encoding_rule, stream, value_tracker)
        value['s'] = SecondsAngle.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = LongitudeDMS2()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'd' in value:
            DegreesLong.validate(value['d'], errors, '{}/{}'.format(comp_path ,'d'))
        elif 'd' not in value:
            report_missing_field(type(self).__name__, 'd', errors, comp_path)
        if 'm' in value:
            MinutesAngle.validate(value['m'], errors, '{}/{}'.format(comp_path ,'m'))
        elif 'm' not in value:
            report_missing_field(type(self).__name__, 'm', errors, comp_path)
        if 's' in value:
            SecondsAngle.validate(value['s'], errors, '{}/{}'.format(comp_path ,'s'))
        elif 's' not in value:
            report_missing_field(type(self).__name__, 's', errors, comp_path)

        return errors

class Node_LLdms_48b:
    def __init__(self):
        self._comp_types = {"lon" : LongitudeDMS, "lat" : LatitudeDMS}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpB.Node-LLdms-48b"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_LLdms_48b()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'lon' in value:
            LongitudeDMS.encode(encoding_rule, value['lon'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            LatitudeDMS.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_LLdms_48b()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['lon'] = LongitudeDMS.decode(encoding_rule, stream, value_tracker)
        value['lat'] = LatitudeDMS.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_LLdms_48b()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lon' in value:
            LongitudeDMS.validate(value['lon'], errors, '{}/{}'.format(comp_path ,'lon'))
        elif 'lon' not in value:
            report_missing_field(type(self).__name__, 'lon', errors, comp_path)
        if 'lat' in value:
            LatitudeDMS.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)

        return errors

class Node_LLdms_80b:
    def __init__(self):
        self._comp_types = {"lon" : LongitudeDMS2, "lat" : LatitudeDMS2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpB.Node-LLdms-80b"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Node_LLdms_80b()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'lon' in value:
            LongitudeDMS2.encode(encoding_rule, value['lon'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'lat' in value:
            LatitudeDMS2.encode(encoding_rule, value['lat'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Node_LLdms_80b()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['lon'] = LongitudeDMS2.decode(encoding_rule, stream, value_tracker)
        value['lat'] = LatitudeDMS2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Node_LLdms_80b()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'lon' in value:
            LongitudeDMS2.validate(value['lon'], errors, '{}/{}'.format(comp_path ,'lon'))
        elif 'lon' not in value:
            report_missing_field(type(self).__name__, 'lon', errors, comp_path)
        if 'lat' in value:
            LatitudeDMS2.validate(value['lat'], errors, '{}/{}'.format(comp_path ,'lat'))
        elif 'lat' not in value:
            report_missing_field(type(self).__name__, 'lat', errors, comp_path)

        return errors

class LaneDataAttribute_addGrpB:
    def __init__(self):
        self._comp_types = {}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpB.LaneDataAttribute-addGrpB"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = LaneDataAttribute_addGrpB()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = LaneDataAttribute_addGrpB()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = LaneDataAttribute_addGrpB()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        return errors

class MovementEvent_addGrpB:
    def __init__(self):
        self._comp_types = {"startTime" : TimeRemaining, "minEndTime" : MaxTimetoChange, "maxEndTime" : MaxTimetoChange, "likelyTime" : TimeRemaining, "confidence" : ApproachID, "nextTime" : TimeRemaining}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpB.MovementEvent-addGrpB"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = MovementEvent_addGrpB()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if ('startTime' in value and 'startTime' not in self._def_vals):
            preamble_bits[0] = True
        elif ('startTime' in value and 'startTime' in self._def_vals):
            if not value_tracker.are_def_eq(value['startTime'], self._def_vals['startTime'], self._comp_types['startTime']):
                preamble_bits[0] = True
        if ('maxEndTime' in value and 'maxEndTime' not in self._def_vals):
            preamble_bits[1] = True
        elif ('maxEndTime' in value and 'maxEndTime' in self._def_vals):
            if not value_tracker.are_def_eq(value['maxEndTime'], self._def_vals['maxEndTime'], self._comp_types['maxEndTime']):
                preamble_bits[1] = True
        if ('likelyTime' in value and 'likelyTime' not in self._def_vals):
            preamble_bits[2] = True
        elif ('likelyTime' in value and 'likelyTime' in self._def_vals):
            if not value_tracker.are_def_eq(value['likelyTime'], self._def_vals['likelyTime'], self._comp_types['likelyTime']):
                preamble_bits[2] = True
        if ('confidence' in value and 'confidence' not in self._def_vals):
            preamble_bits[3] = True
        elif ('confidence' in value and 'confidence' in self._def_vals):
            if not value_tracker.are_def_eq(value['confidence'], self._def_vals['confidence'], self._comp_types['confidence']):
                preamble_bits[3] = True
        if ('nextTime' in value and 'nextTime' not in self._def_vals):
            preamble_bits[4] = True
        elif ('nextTime' in value and 'nextTime' in self._def_vals):
            if not value_tracker.are_def_eq(value['nextTime'], self._def_vals['nextTime'], self._comp_types['nextTime']):
                preamble_bits[4] = True
        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if preamble_bits[1]:
            TimeRemaining.encode(encoding_rule, value['startTime'], value_tracker, stream)
        if 'minEndTime' in value:
            MaxTimetoChange.encode(encoding_rule, value['minEndTime'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if preamble_bits[2]:
            MaxTimetoChange.encode(encoding_rule, value['maxEndTime'], value_tracker, stream)
        if preamble_bits[3]:
            TimeRemaining.encode(encoding_rule, value['likelyTime'], value_tracker, stream)
        if preamble_bits[4]:
            ApproachID.encode(encoding_rule, value['confidence'], value_tracker, stream)
        if preamble_bits[5]:
            TimeRemaining.encode(encoding_rule, value['nextTime'], value_tracker, stream)

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = MovementEvent_addGrpB()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 5

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        if preamble_bits[1]:
            value['startTime'] = TimeRemaining.decode(encoding_rule, stream, value_tracker)
        elif 'startTime' in self._def_vals:
            value['startTime'] = self._def_vals['startTime']
        value['minEndTime'] = MaxTimetoChange.decode(encoding_rule, stream, value_tracker)
        if preamble_bits[2]:
            value['maxEndTime'] = MaxTimetoChange.decode(encoding_rule, stream, value_tracker)
        elif 'maxEndTime' in self._def_vals:
            value['maxEndTime'] = self._def_vals['maxEndTime']
        if preamble_bits[3]:
            value['likelyTime'] = TimeRemaining.decode(encoding_rule, stream, value_tracker)
        elif 'likelyTime' in self._def_vals:
            value['likelyTime'] = self._def_vals['likelyTime']
        if preamble_bits[4]:
            value['confidence'] = ApproachID.decode(encoding_rule, stream, value_tracker)
        elif 'confidence' in self._def_vals:
            value['confidence'] = self._def_vals['confidence']
        if preamble_bits[5]:
            value['nextTime'] = TimeRemaining.decode(encoding_rule, stream, value_tracker)
        elif 'nextTime' in self._def_vals:
            value['nextTime'] = self._def_vals['nextTime']

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = MovementEvent_addGrpB()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'startTime' in value:
            TimeRemaining.validate(value['startTime'], errors, '{}/{}'.format(comp_path ,'startTime'))
        if 'minEndTime' in value:
            MaxTimetoChange.validate(value['minEndTime'], errors, '{}/{}'.format(comp_path ,'minEndTime'))
        elif 'minEndTime' not in value:
            report_missing_field(type(self).__name__, 'minEndTime', errors, comp_path)
        if 'maxEndTime' in value:
            MaxTimetoChange.validate(value['maxEndTime'], errors, '{}/{}'.format(comp_path ,'maxEndTime'))
        if 'likelyTime' in value:
            TimeRemaining.validate(value['likelyTime'], errors, '{}/{}'.format(comp_path ,'likelyTime'))
        if 'confidence' in value:
            ApproachID.validate(value['confidence'], errors, '{}/{}'.format(comp_path ,'confidence'))
        if 'nextTime' in value:
            TimeRemaining.validate(value['nextTime'], errors, '{}/{}'.format(comp_path ,'nextTime'))

        return errors

class NodeOffsetPointXY_addGrpB:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "AddGrpB.NodeOffsetPointXY-addGrpB"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"posA": 0, "posB": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = NodeOffsetPointXY_addGrpB()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(idx > 63)

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'posA':
                Node_LLdms_48b.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'posB':
                Node_LLdms_80b.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = NodeOffsetPointXY_addGrpB()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'posA':
                alternative = Node_LLdms_48b.decode(encoding_rule, stream, value_tracker)
            if identifier == 'posB':
                alternative = Node_LLdms_80b.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = NodeOffsetPointXY_addGrpB()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'posA' in value:
            Node_LLdms_48b.validate(value['posA'], errors, '{}/{}'.format(comp_path ,'posA'))
            is_checked = True
        if 'posB' in value:
            Node_LLdms_80b.validate(value['posB'], errors, '{}/{}'.format(comp_path ,'posB'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class Position3D_addGrpB:
    def __init__(self):
        self._comp_types = {"latitude" : LatitudeDMS2, "longitude" : LongitudeDMS2, "elevation" : Elevation__A}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpB.Position3D-addGrpB"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = Position3D_addGrpB()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        if '_unknown_extensions' in value:
            for ext_val in value['_unknown_extensions']:
                if ext_val is not None:
                    extension_bits.append(True)
                else:
                    extension_bits.append(False)

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'latitude' in value:
            LatitudeDMS2.encode(encoding_rule, value['latitude'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'longitude' in value:
            LongitudeDMS2.encode(encoding_rule, value['longitude'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'elevation' in value:
            Elevation__A.encode(encoding_rule, value['elevation'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
            unknown_exts = len(extension_bits) - data_map['num_extensions']
            known_exts = len(extension_bits) - unknown_exts
            if unknown_exts > 0:
                for idx in range(unknown_exts):
                    if extension_bits[known_exts + idx]:
                        hex_value = bytearray.fromhex(value['_unknown_extensions'][idx])
                        stream.write_octets_with_indefinite_length(hex_value)

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = Position3D_addGrpB()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = True
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['latitude'] = LatitudeDMS2.decode(encoding_rule, stream, value_tracker)
        value['longitude'] = LongitudeDMS2.decode(encoding_rule, stream, value_tracker)
        value['elevation'] = Elevation__A.decode(encoding_rule, stream, value_tracker)

        extension_bits = []
        if preamble_bits[0]:
            if not stream.read_bit():
                width = stream.read_int(6) + 1
                _, hex_value = stream.read_bits(width)
                extension_bits = stream.to_bit_list(width, hex_value)
            else:
                width, hex_value = stream.read_bits_with_indefinite_length()
                extension_bits = stream.to_bit_list(width, hex_value)
        stream.trim(extension_bits)
        unknown_exts = len(extension_bits) - data_map['num_extensions'] if len(extension_bits) > 0 else 0
        known_exts = len(extension_bits) - unknown_exts
        if unknown_exts > 0:
            for idx in range(unknown_exts):
                if extension_bits[known_exts + idx]:
                    hex_value = stream.read_octets_with_indefinite_length()
                    if hex_value is not None:
                        if '_unknown_extensions' not in value:
                            value['_unknown_extensions'] = []
                        value['_unknown_extensions'].append(hex_value.hex().upper())
                else:
                    if '_unknown_extensions' not in value:
                        value['_unknown_extensions'] = []
                    value['_unknown_extensions'].append(None)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = Position3D_addGrpB()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'latitude' in value:
            LatitudeDMS2.validate(value['latitude'], errors, '{}/{}'.format(comp_path ,'latitude'))
        elif 'latitude' not in value:
            report_missing_field(type(self).__name__, 'latitude', errors, comp_path)
        if 'longitude' in value:
            LongitudeDMS2.validate(value['longitude'], errors, '{}/{}'.format(comp_path ,'longitude'))
        elif 'longitude' not in value:
            report_missing_field(type(self).__name__, 'longitude', errors, comp_path)
        if 'elevation' in value:
            Elevation__A.validate(value['elevation'], errors, '{}/{}'.format(comp_path ,'elevation'))
        elif 'elevation' not in value:
            report_missing_field(type(self).__name__, 'elevation', errors, comp_path)

        return errors

class TimeMark__A:
    def __init__(self):
        self._comp_types = {"year" : TimeOffset, "month" : Month, "day" : AmbientAirPressure, "summerTime" : SummerTime, "holiday" : Holiday, "dayofWeek" : DayOfWeek, "hour" : AmbientAirPressure, "minute" : AmbientAirPressure, "second" : DMinute, "tenthSecond" : TenthSecond}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "AddGrpB.TimeMark"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = TimeMark__A()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'year' in value:
            TimeOffset.encode(encoding_rule, value['year'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'month' in value:
            Month.encode(encoding_rule, value['month'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'day' in value:
            AmbientAirPressure.encode(encoding_rule, value['day'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'summerTime' in value:
            SummerTime.encode(encoding_rule, value['summerTime'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'holiday' in value:
            Holiday.encode(encoding_rule, value['holiday'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'dayofWeek' in value:
            DayOfWeek.encode(encoding_rule, value['dayofWeek'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'hour' in value:
            AmbientAirPressure.encode(encoding_rule, value['hour'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'minute' in value:
            AmbientAirPressure.encode(encoding_rule, value['minute'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'second' in value:
            DMinute.encode(encoding_rule, value['second'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'tenthSecond' in value:
            TenthSecond.encode(encoding_rule, value['tenthSecond'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = TimeMark__A()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['year'] = TimeOffset.decode(encoding_rule, stream, value_tracker)
        value['month'] = Month.decode(encoding_rule, stream, value_tracker)
        value['day'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['summerTime'] = SummerTime.decode(encoding_rule, stream, value_tracker)
        value['holiday'] = Holiday.decode(encoding_rule, stream, value_tracker)
        value['dayofWeek'] = DayOfWeek.decode(encoding_rule, stream, value_tracker)
        value['hour'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['minute'] = AmbientAirPressure.decode(encoding_rule, stream, value_tracker)
        value['second'] = DMinute.decode(encoding_rule, stream, value_tracker)
        value['tenthSecond'] = TenthSecond.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = TimeMark__A()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'year' in value:
            TimeOffset.validate(value['year'], errors, '{}/{}'.format(comp_path ,'year'))
        elif 'year' not in value:
            report_missing_field(type(self).__name__, 'year', errors, comp_path)
        if 'month' in value:
            Month.validate(value['month'], errors, '{}/{}'.format(comp_path ,'month'))
        elif 'month' not in value:
            report_missing_field(type(self).__name__, 'month', errors, comp_path)
        if 'day' in value:
            AmbientAirPressure.validate(value['day'], errors, '{}/{}'.format(comp_path ,'day'))
        elif 'day' not in value:
            report_missing_field(type(self).__name__, 'day', errors, comp_path)
        if 'summerTime' in value:
            SummerTime.validate(value['summerTime'], errors, '{}/{}'.format(comp_path ,'summerTime'))
        elif 'summerTime' not in value:
            report_missing_field(type(self).__name__, 'summerTime', errors, comp_path)
        if 'holiday' in value:
            Holiday.validate(value['holiday'], errors, '{}/{}'.format(comp_path ,'holiday'))
        elif 'holiday' not in value:
            report_missing_field(type(self).__name__, 'holiday', errors, comp_path)
        if 'dayofWeek' in value:
            DayOfWeek.validate(value['dayofWeek'], errors, '{}/{}'.format(comp_path ,'dayofWeek'))
        elif 'dayofWeek' not in value:
            report_missing_field(type(self).__name__, 'dayofWeek', errors, comp_path)
        if 'hour' in value:
            AmbientAirPressure.validate(value['hour'], errors, '{}/{}'.format(comp_path ,'hour'))
        elif 'hour' not in value:
            report_missing_field(type(self).__name__, 'hour', errors, comp_path)
        if 'minute' in value:
            AmbientAirPressure.validate(value['minute'], errors, '{}/{}'.format(comp_path ,'minute'))
        elif 'minute' not in value:
            report_missing_field(type(self).__name__, 'minute', errors, comp_path)
        if 'second' in value:
            DMinute.validate(value['second'], errors, '{}/{}'.format(comp_path ,'second'))
        elif 'second' not in value:
            report_missing_field(type(self).__name__, 'second', errors, comp_path)
        if 'tenthSecond' in value:
            TenthSecond.validate(value['tenthSecond'], errors, '{}/{}'.format(comp_path ,'tenthSecond'))
        elif 'tenthSecond' not in value:
            report_missing_field(type(self).__name__, 'tenthSecond', errors, comp_path)

        return errors

class EssMobileFriction:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..101","permitted":[(0,101)]}}]
        self._unique_indetifier = "NTCIP.EssMobileFriction"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = EssMobileFriction()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 7
        data_map['width_value_unaligned'] = 7
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 101

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = EssMobileFriction()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 7
        data_map['width_value_unaligned'] = 7
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 101

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = EssMobileFriction()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class EssPrecipSituation:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "NTCIP.EssPrecipSituation"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"other": 0, "unknown": 1, "noPrecipitation": 2, "unidentifiedSlight": 3, "unidentifiedModerate": 4, "unidentifiedHeavy": 5, "snowSlight": 6, "snowModerate": 7, "snowHeavy": 8, "rainSlight": 9, "rainModerate": 10, "rainHeavy": 11, "frozenPrecipitationSlight": 12, "frozenPrecipitationModerate": 13, "frozenPrecipitationHeavy": 14}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = EssPrecipSituation()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = EssPrecipSituation()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = EssPrecipSituation()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class EssPrecipYesNo:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "NTCIP.EssPrecipYesNo"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"precip": 0, "noPrecip": 1, "error": 2}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = EssPrecipYesNo()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = EssPrecipYesNo()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 2
        data_map['width_index_aligned'] = 2
        data_map['width_length_aligned'] = 2
        data_map['align_index'] = False

        data_map['is_extension'] = False

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = EssPrecipYesNo()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class GenericLocations:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "ITIS.GenericLocations"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"on-bridges": 0, "in-tunnels": 1, "entering-or-leaving-tunnels": 2, "on-ramps": 3, "in-road-construction-area": 4, "around-a-curve": 5, "on-curve": 88, "on-tracks": 72, "in-street": 87, "shoulder": 89, "on-minor-roads": 6, "in-the-opposing-lanes": 7, "adjacent-to-roadway": 8, "across-tracks": 86, "on-bend": 9, "intersection": 94, "entire-intersection": 10, "in-the-median": 11, "moved-to-side-of-road": 12, "moved-to-shoulder": 13, "on-the-roadway": 14, "dip": 73, "traffic-circle": 74, "crossover": 90, "cross-road": 91, "side-road": 92, "to": 76, "by": 77, "through": 78, "area-of": 79, "under": 80, "over": 81, "from": 82, "approaching": 83, "entering-at": 84, "exiting-at": 85, "in-shaded-areas": 15, "in-low-lying-areas": 16, "in-the-downtown-area": 17, "in-the-inner-city-area": 18, "in-parts": 19, "in-some-places": 20, "in-the-ditch": 21, "in-the-valley": 22, "on-hill-top": 23, "near-the-foothills": 24, "at-high-altitudes": 25, "near-the-lake": 26, "near-the-shore": 27, "nearby-basin": 71, "over-the-crest-of-a-hill": 28, "other-than-on-the-roadway": 29, "near-the-beach": 30, "near-beach-access-point": 31, "mountain-pass": 69, "lower-level": 32, "upper-level": 33, "airport": 34, "concourse": 35, "gate": 36, "baggage-claim": 37, "customs-point": 38, "reservation-center": 70, "station": 39, "platform": 40, "dock": 41, "depot": 42, "ev-charging-point": 43, "information-welcome-point": 44, "at-rest-area": 45, "at-service-area": 46, "at-weigh-station": 47, "roadside-park": 95, "picnic-areas": 48, "rest-area": 49, "service-stations": 50, "toilets": 51, "bus-stop": 93, "park-and-ride-lot": 75, "on-the-right": 52, "on-the-left": 53, "in-the-center": 54, "in-the-opposite-direction": 55, "cross-traffic": 56, "northbound-traffic": 57, "eastbound-traffic": 58, "southbound-traffic": 59, "westbound-traffic": 60, "north": 61, "south": 62, "east": 63, "west": 64, "northeast": 65, "northwest": 66, "southeast": 67, "southwest": 68}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = GenericLocations()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 7
        data_map['width_index_aligned'] = 7
        data_map['width_length_aligned'] = 7
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = GenericLocations()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 7
        data_map['width_index_aligned'] = 7
        data_map['width_length_aligned'] = 7
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = GenericLocations()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class IncidentResponseEquipment:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "ITIS.IncidentResponseEquipment"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"ground-fire-suppression": 0, "heavy-ground-equipment": 1, "aircraft": 2, "marine-equipment": 3, "support-equipment": 4, "medical-rescue-unit": 5, "other": 6, "ground-fire-suppression-other": 7, "engine": 8, "truck-or-aerial": 9, "quint": 10, "tanker-pumper-combination": 11, "brush-truck": 12, "aircraft-rescue-firefighting": 13, "heavy-ground-equipment-other": 14, "dozer-or-plow": 15, "tractor": 16, "tanker-or-tender": 17, "aircraft-other": 18, "aircraft-fixed-wing-tanker": 19, "helitanker": 20, "helicopter": 21, "marine-equipment-other": 22, "fire-boat-with-pump": 23, "boat-no-pump": 24, "support-apparatus-other": 25, "breathing-apparatus-support": 26, "light-and-air-unit": 27, "medical-rescue-unit-other": 28, "rescue-unit": 29, "urban-search-rescue-unit": 30, "high-angle-rescue": 31, "crash-fire-rescue": 32, "bLS-unit": 33, "aLS-unit": 34, "mobile-command-post": 35, "chief-officer-car": 36, "hAZMAT-unit": 37, "type-i-hand-crew": 38, "type-ii-hand-crew": 39, "privately-owned-vehicle": 40, "other-apparatus-resource": 41, "ambulance": 42, "bomb-squad-van": 43, "combine-harvester": 44, "construction-vehicle": 45, "farm-tractor": 46, "grass-cutting-machines": 47, "hAZMAT-containment-tow": 48, "heavy-tow": 49, "light-tow": 51, "flatbed-tow": 71, "hedge-cutting-machines": 50, "mobile-crane": 52, "refuse-collection-vehicle": 53, "resurfacing-vehicle": 54, "road-sweeper": 55, "roadside-litter-collection-crews": 56, "salvage-vehicle": 57, "sand-truck": 58, "snowplow": 59, "steam-roller": 60, "swat-team-van": 61, "track-laying-vehicle": 62, "unknown-vehicle": 63, "white-lining-vehicle": 64, "dump-truck": 65, "supervisor-vehicle": 66, "snow-blower": 67, "rotary-snow-blower": 68, "road-grader": 69, "steam-truck": 70}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = IncidentResponseEquipment()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 7
        data_map['width_index_aligned'] = 7
        data_map['width_length_aligned'] = 7
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = IncidentResponseEquipment()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 7
        data_map['width_index_aligned'] = 7
        data_map['width_length_aligned'] = 7
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = IncidentResponseEquipment()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class ITIStext:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"alphabet constraint","permitted":[[0,127]]}},{"type":"subtype constraint","root expression":{"type":"size constraint","definition": "SIZE(1..500)","permitted":[(1,500)]}}]
        self._unique_indetifier = "ITIS.ITIStext"
        self._asn1Type = Asn1Type.String

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = ITIStext()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 500
        data_map['width_length_aligned'] = 16
        data_map['width_length_unaligned'] = 9
        data_map['align_length'] = True
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        osspy.per.encode_string(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> str:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = ITIStext()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> str:
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 500
        data_map['width_length_aligned'] = 16
        data_map['width_length_unaligned'] = 9
        data_map['align_length'] = True
        data_map['is_utf8'] = False
        data_map['alphabet'] = []
        data_map['width_index_aligned'] = None
        data_map['width_index_unaligned'] = None
        data_map['width_alphabet_aligned'] = 8
        data_map['width_alphabet_unaligned'] = 7

        return osspy.per.decode_string(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = ITIStext()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class ResponderGroupAffected:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "ITIS.ResponderGroupAffected"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"emergency-vehicle-units": 0, "federal-law-enforcement-units": 1, "state-police-units": 2, "county-police-units": 3, "local-police-units": 4, "ambulance-units": 5, "rescue-units": 6, "fire-units": 7, "hAZMAT-units": 8, "light-tow-unit": 9, "heavy-tow-unit": 10, "freeway-service-patrols": 11, "transportation-response-units": 12, "private-contractor-response-units": 13}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = ResponderGroupAffected()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = ResponderGroupAffected()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 4
        data_map['width_index_aligned'] = 4
        data_map['width_length_aligned'] = 4
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = ResponderGroupAffected()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class VehicleGroupAffected:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "ITIS.VehicleGroupAffected"
        self._asn1Type = Asn1Type.ENUMERATED
        self._root_identifiers = {"all-vehicles": 0, "bicycles": 1, "motorcycles": 2, "cars": 3, "light-vehicles": 4, "cars-and-light-vehicles": 5, "cars-with-trailers": 6, "cars-with-recreational-trailers": 7, "vehicles-with-trailers": 8, "heavy-vehicles": 9, "trucks": 10, "buses": 11, "articulated-buses": 12, "school-buses": 13, "vehicles-with-semi-trailers": 14, "vehicles-with-double-trailers": 15, "high-profile-vehicles": 16, "wide-vehicles": 17, "long-vehicles": 18, "hazardous-loads": 19, "exceptional-loads": 20, "abnormal-loads": 21, "convoys": 22, "maintenance-vehicles": 23, "delivery-vehicles": 24, "vehicles-with-even-numbered-license-plates": 25, "vehicles-with-odd-numbered-license-plates": 26, "vehicles-with-parking-permits": 27, "vehicles-with-catalytic-converters": 28, "vehicles-without-catalytic-converters": 29, "gas-powered-vehicles": 30, "diesel-powered-vehicles": 31, "lPG-vehicles": 32, "military-convoys": 33, "military-vehicles": 34}
        self._ext_identifiers = {}
        self._identifiers = {**self._root_identifiers, **self._ext_identifiers}

    @staticmethod
    def encode(encoding_rule: str, value: Union[str, int], value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        enum_type = VehicleGroupAffected()
        return enum_type.encode_value(value, stream)

    def encode_value(self, value: Union[str, int], stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['width_index_unaligned'] = 6
        data_map['width_index_aligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_index'] = False

        if (not isinstance(value, int) and not isinstance(value, str)):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        int_val = None
        if (isinstance(value, int) and value in self._root_identifiers.values()):
            int_val = value
        elif (isinstance(value, int) and value in self._ext_identifiers.values()):
            int_val = value

        if (isinstance(value, str) and value in self._identifiers):
            int_val = self._identifiers[value]

        if (int_val is None and isinstance(value, int)):
            int_val = value
            data_map['is_extension'] = True

        if (isinstance(value, str) and value in self._ext_identifiers.keys()):
            data_map['is_extension'] = True

        is_extension = data_map['is_extension'] if 'is_extension' in data_map else False
        stream.write_bit(is_extension)

        if is_extension:
            stream.write_bit(int_val > 63)

        if int_val is None:
            raise ValueError("62603: The enumeration item identifier is missing from the enumerated value!")

        osspy.per.encode_enum(stream, int_val, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Union[str, int]:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        enum_type = VehicleGroupAffected()
        return enum_type.decode_value(stream)

    def decode_value(self, stream: osspy.per.decodingstream) -> Union[str, int]:
        data_map = {}

        data_map['width_index_unaligned'] = 6
        data_map['width_index_aligned'] = 6
        data_map['width_length_aligned'] = 6
        data_map['align_index'] = False

        data_map['is_extension'] = False
        data_map['is_extension'] = stream.read_bit()

        idx = osspy.per.decode_enum(stream, **data_map)

        identifier = None
        if data_map['is_extension'] is False:
            if idx + 1 > len(self._root_identifiers):
                idx = 0
                raise ValueError("62605: The enumeration item in the encoded data was not recognized!", stream)
            for key, val in self._root_identifiers.items():
                if val == idx:
                    identifier = key
        elif idx + 1 <= len(self._ext_identifiers):
            for key, val in self._ext_identifiers.items():
                if val == idx:
                    identifier = key

        if identifier is not None:
            return identifier

        return idx

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        enum_type = VehicleGroupAffected()
        return enum_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        if (isinstance(value, int) and value not in self._identifiers.keys()):
            report_extra_field(value, type(self).__name__, value, errors, comp_path, list(self._identifiers.keys()))
        return errors

class ITIScodesAndText:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"size constraint","permitted":[(1,100)]}}]
        self._unique_indetifier = "ITIS.ITIScodesAndText"
        self._asn1Type = Asn1Type.SEQUENCE_OF

    def encode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value: list, value_tracker: dict, idx: int, length: int, encoded_items: list) -> bytearray:
        idx2 = idx
        for val in value[idx:length]:
            value_tracker.add_ancestor(val)
            if encoded_items is None:
                ITIScodesAndText__4.encode(encoding_rule, val, value_tracker, stream)
            else:
                loc = encoded_items[idx2][-1]
                ITIScodesAndText__4.encode(encoding_rule, value[loc] , value_tracker, stream)
                idx2 += 1
            value_tracker.remove_ancestor()
        return stream

    def decode_components(self, encoding_rule: str, stream: osspy.per.encodingstream, value_tracker: dict, components: list, length: int) -> list:
        for val in range(length):
            value_tracker.add_ancestor(val)
            components.append(ITIScodesAndText__4.decode(encoding_rule, stream, value_tracker))
            value_tracker.remove_ancestor()
        return components

    @staticmethod
    def encode(encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seqof_type = ITIScodesAndText()
        return seqof_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: list, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, list):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 100
        data_map['width_length_unaligned'] = 7
        data_map['width_length_aligned'] = 7
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        if (data_map['is_setof_type'] and stream.canonical):
            enc_list = []
            for val in value:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                enc_list.append(ITIScodesAndText__4.encode(encoding_rule, val, value_tracker, tmpstream).get_buffer())
            enc_list = sorted(enc_list)
            data_map['encoded_items'] = list(map(lambda x : (x, enc_list.index(x)), enc_list))

        idx, length = osspy.per.encode_sequence_of(stream, encoding_rule, value, value_tracker, self.encode_components, **data_map)

        self.encode_components(encoding_rule, stream, value, value_tracker, idx, length, data_map['encoded_items'])
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seqof_type = ITIScodesAndText()
        return seqof_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> list:
        components = []
        data_map = {}

        data_map['has_extensible_size'] = False
        data_map['minimum_root_size'] = 1
        data_map['maximum_root_size'] = 100
        data_map['width_length_unaligned'] = 7
        data_map['width_length_aligned'] = 7
        data_map['align_length'] = False
        data_map['is_setof_type'] = False
        data_map['encoded_items'] = None

        length = osspy.per.decode_sequence_of(stream, encoding_rule, components, value_tracker, self.decode_components, **data_map)

        self.decode_components(encoding_rule, stream, value_tracker, components, length)

        return components

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seqof_type = ITIScodesAndText()
        return seqof_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if isinstance(value, list):
            for idx, val in enumerate(value):
                ITIScodesAndText__4.validate(val, errors, '{}/{}'.format(comp_path, idx))

        return errors

class ITIScodesAndText__4:
    def __init__(self):
        self._comp_types = {"item" : ITIScodesAndText__3}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = "ITIS.ITIScodesAndText.c"
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = ITIScodesAndText__4()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'item' in value:
            ITIScodesAndText__3.encode(encoding_rule, value['item'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = ITIScodesAndText__4()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['item'] = ITIScodesAndText__3.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = ITIScodesAndText__4()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'item' in value:
            ITIScodesAndText__3.validate(value['item'], errors, '{}/{}'.format(comp_path ,'item'))
        elif 'item' not in value:
            report_missing_field(type(self).__name__, 'item', errors, comp_path)

        return errors

class ITIScodesAndText__3:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "ITIS.ITIScodesAndText.c.item"
        self._asn1Type = Asn1Type.CHOICE
        self._root_alternatives = {"itis": 0, "text": 1}
        self._ext_alternatives = {}
        self._alternatives = {**self._root_alternatives, **self._ext_alternatives}

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        choice_type = ITIScodesAndText__3()
        return choice_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}
        is_extension = False

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        if (not isinstance(value, object) or len(value.keys()) != 1):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value)

        identifier = list(value.keys())[0]
        alternative = list(value.values())[0]

        idx = None
        if identifier in self._root_alternatives:
            idx = self._root_alternatives[identifier]
        elif identifier in self._ext_alternatives:
            idx = self._ext_alternatives[identifier]
            is_extension = True
        elif (data_map['is_extensible'] and identifier not in self._alternatives):
            if (identifier == '_unknown_extension' and isinstance(alternative, dict)):
                if 'index' in alternative:
                    idx = alternative['index']
                else:
                    idx = 0
            else:
                idx = 0
            is_extension = True
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        osspy.per.encode_choice_preamble(stream, is_extension, idx, **data_map)

        if identifier in self._alternatives:
            if identifier == 'itis':
                DSecond.encode(encoding_rule, alternative, value_tracker, stream)
            if identifier == 'text':
                ITIStext.encode(encoding_rule, alternative, value_tracker, stream)
        elif (identifier == '_unknown_extension' and isinstance(alternative, dict) and 'value' in alternative):
            hex_value = bytearray.fromhex(alternative['value'])
            stream.write_octets_with_indefinite_length(hex_value)
        else:
            value_tracker.remove_ancestor()
            raise TypeError("62403: The choice alternative identifier is missing from the choice value!")

        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        choice_type = ITIScodesAndText__3()
        return choice_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> object:
        data_map = {}
        value = {}
        identifier = None
        alternative = None
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_alternatives'] = 2
        data_map['width_index_unaligned'] = 1
        data_map['width_index_aligned'] = 1
        data_map['width_length_aligned'] = None
        data_map['align_index'] = False

        idx, is_extension = osspy.per.decode_choice_preamble(stream, **data_map)

        if not is_extension:
            if idx + 1 > data_map['num_alternatives']:
                value_tracker.remove_ancestor()
                raise TypeError("62409: The choice alternative in the encoded data was not recognized!")
            identifier = list(self._root_alternatives.keys())[idx]
        else:
            if idx + 1 <= len(self._ext_alternatives):
                identifier = list(self._ext_alternatives.keys())[idx]

        if identifier is not None:
            if identifier == 'itis':
                alternative = DSecond.decode(encoding_rule, stream, value_tracker)
            if identifier == 'text':
                alternative = ITIStext.decode(encoding_rule, stream, value_tracker)
        else:
            hex_value = stream.read_octets_with_indefinite_length()
            identifier = '_unknown_extension'
            alternative = hex_value.hex().upper()
            alternative = {
                'index' : idx,
                'value' : alternative
            }
        value[identifier] = alternative

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        choice_type = ITIScodesAndText__3()
        return choice_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        is_checked = False
        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'itis' in value:
            DSecond.validate(value['itis'], errors, '{}/{}'.format(comp_path ,'itis'))
            is_checked = True
        if 'text' in value:
            ITIStext.validate(value['text'], errors, '{}/{}'.format(comp_path ,'text'))
            is_checked = True
        if (not is_checked and '_unknown_extension' not in value):
            report_empty_value(value, type(self).__name__, errors, comp_path)
        return errors

class DSecond:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "0..65535","permitted":[(0,65535)]}}]
        self._unique_indetifier = "DSRC.DSecond"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = DSecond()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 65535

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = DSecond()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 16
        data_map['width_value_unaligned'] = 16
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 65535

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = DSecond()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

EssPrecipRate = DSecond
EssSolarRadiation = DSecond
IntersectionID = DSecond
ITIScodes = DSecond
RoadRegulatorID = DSecond
RoadSegmentID = DSecond
SemiMajorAxisOrientation = DSecond

class RegionalExtension_34:
    def __init__(self):
        self._comp_types = {"regionId" : RegionalExtension_34__1, "regExtValue" : RegionalExtension_34__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = None
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegionalExtension_34()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'regionId' in value:
            RegionalExtension_34__1.encode(encoding_rule, value['regionId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'regExtValue' in value:
            RegionalExtension_34__2.encode(encoding_rule, value['regExtValue'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegionalExtension_34()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['regionId'] = RegionalExtension_34__1.decode(encoding_rule, stream, value_tracker)
        value['regExtValue'] = RegionalExtension_34__2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegionalExtension_34()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'regionId' in value:
            RegionalExtension_34__1.validate(value['regionId'], errors, '{}/{}'.format(comp_path ,'regionId'))
        elif 'regionId' not in value:
            report_missing_field(type(self).__name__, 'regionId', errors, comp_path)
        if 'regExtValue' in value:
            RegionalExtension_34__2.validate(value['regExtValue'], errors, '{}/{}'.format(comp_path ,'regExtValue'))
        elif 'regExtValue' not in value:
            report_missing_field(type(self).__name__, 'regExtValue', errors, comp_path)

        return errors

class RegionalExtension_34__1:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "{Set}","permitted":[(0,255)]}},{"type":"simple table constraint","isExtensible": True,"fields":{"type":"single value","permitted": 3}}]
        self._unique_indetifier = "DSRC.RegionalExtension-34.regionId"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = RegionalExtension_34__1()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 255

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = RegionalExtension_34__1()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 255

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = RegionalExtension_34__1()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

RegionalExtension_40__1 = RegionalExtension_34__1
RegionalExtension_5__1 = RegionalExtension_34__1
RegionalExtension_53__1 = RegionalExtension_34__1

class RegionalExtension_34__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RegionalExtension-34.regExtValue"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = RegionalExtension_34__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded and value is not None and value_tracker.are_equivalent([3], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                ConnectionManeuverAssist_addGrpC.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = RegionalExtension_34__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            if (not is_decoded and value_tracker.are_equivalent([3], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = ConnectionManeuverAssist_addGrpC.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = RegionalExtension_34__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class RegionalExtension_40:
    def __init__(self):
        self._comp_types = {"regionId" : RegionalExtension_34__1, "regExtValue" : RegionalExtension_40__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = None
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegionalExtension_40()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'regionId' in value:
            RegionalExtension_34__1.encode(encoding_rule, value['regionId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'regExtValue' in value:
            RegionalExtension_40__2.encode(encoding_rule, value['regExtValue'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegionalExtension_40()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['regionId'] = RegionalExtension_34__1.decode(encoding_rule, stream, value_tracker)
        value['regExtValue'] = RegionalExtension_40__2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegionalExtension_40()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'regionId' in value:
            RegionalExtension_34__1.validate(value['regionId'], errors, '{}/{}'.format(comp_path ,'regionId'))
        elif 'regionId' not in value:
            report_missing_field(type(self).__name__, 'regionId', errors, comp_path)
        if 'regExtValue' in value:
            RegionalExtension_40__2.validate(value['regExtValue'], errors, '{}/{}'.format(comp_path ,'regExtValue'))
        elif 'regExtValue' not in value:
            report_missing_field(type(self).__name__, 'regExtValue', errors, comp_path)

        return errors

class RegionalExtension_40__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RegionalExtension-40.regExtValue"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = RegionalExtension_40__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded and value is not None and value_tracker.are_equivalent([3], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                IntersectionState_addGrpC.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = RegionalExtension_40__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            if (not is_decoded and value_tracker.are_equivalent([3], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = IntersectionState_addGrpC.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = RegionalExtension_40__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class RegionalExtension_1:
    def __init__(self):
        self._comp_types = {"regionId" : RegionalExtension_1__1, "regExtValue" : RegionalExtension_1__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = None
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegionalExtension_1()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'regionId' in value:
            RegionalExtension_1__1.encode(encoding_rule, value['regionId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'regExtValue' in value:
            RegionalExtension_1__2.encode(encoding_rule, value['regExtValue'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegionalExtension_1()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['regionId'] = RegionalExtension_1__1.decode(encoding_rule, stream, value_tracker)
        value['regExtValue'] = RegionalExtension_1__2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegionalExtension_1()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'regionId' in value:
            RegionalExtension_1__1.validate(value['regionId'], errors, '{}/{}'.format(comp_path ,'regionId'))
        elif 'regionId' not in value:
            report_missing_field(type(self).__name__, 'regionId', errors, comp_path)
        if 'regExtValue' in value:
            RegionalExtension_1__2.validate(value['regExtValue'], errors, '{}/{}'.format(comp_path ,'regExtValue'))
        elif 'regExtValue' not in value:
            report_missing_field(type(self).__name__, 'regExtValue', errors, comp_path)

        return errors

RegionalExtension_10 = RegionalExtension_1
RegionalExtension_11 = RegionalExtension_1
RegionalExtension_12 = RegionalExtension_1
RegionalExtension_13 = RegionalExtension_1
RegionalExtension_14 = RegionalExtension_1
RegionalExtension_15 = RegionalExtension_1
RegionalExtension_16 = RegionalExtension_1
RegionalExtension_17 = RegionalExtension_1
RegionalExtension_18 = RegionalExtension_1
RegionalExtension_19 = RegionalExtension_1
RegionalExtension_2 = RegionalExtension_1
RegionalExtension_20 = RegionalExtension_1
RegionalExtension_21 = RegionalExtension_1
RegionalExtension_22 = RegionalExtension_1
RegionalExtension_23 = RegionalExtension_1
RegionalExtension_24 = RegionalExtension_1
RegionalExtension_25 = RegionalExtension_1
RegionalExtension_26 = RegionalExtension_1
RegionalExtension_27 = RegionalExtension_1
RegionalExtension_28 = RegionalExtension_1
RegionalExtension_29 = RegionalExtension_1
RegionalExtension_3 = RegionalExtension_1
RegionalExtension_30 = RegionalExtension_1
RegionalExtension_31 = RegionalExtension_1
RegionalExtension_32 = RegionalExtension_1
RegionalExtension_33 = RegionalExtension_1
RegionalExtension_35 = RegionalExtension_1
RegionalExtension_36 = RegionalExtension_1
RegionalExtension_37 = RegionalExtension_1
RegionalExtension_38 = RegionalExtension_1
RegionalExtension_39 = RegionalExtension_1
RegionalExtension_4 = RegionalExtension_1
RegionalExtension_41 = RegionalExtension_1
RegionalExtension_44 = RegionalExtension_1
RegionalExtension_45 = RegionalExtension_1
RegionalExtension_46 = RegionalExtension_1
RegionalExtension_47 = RegionalExtension_1
RegionalExtension_50 = RegionalExtension_1
RegionalExtension_51 = RegionalExtension_1
RegionalExtension_52 = RegionalExtension_1
RegionalExtension_54 = RegionalExtension_1
RegionalExtension_55 = RegionalExtension_1
RegionalExtension_56 = RegionalExtension_1
RegionalExtension_57 = RegionalExtension_1
RegionalExtension_58 = RegionalExtension_1
RegionalExtension_59 = RegionalExtension_1
RegionalExtension_6 = RegionalExtension_1
RegionalExtension_60 = RegionalExtension_1
RegionalExtension_61 = RegionalExtension_1
RegionalExtension_7 = RegionalExtension_1
RegionalExtension_8 = RegionalExtension_1
RegionalExtension_9 = RegionalExtension_1

class RegionalExtension_1__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RegionalExtension-1.regExtValue"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = RegionalExtension_1__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, None, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = RegionalExtension_1__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            pass
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = RegionalExtension_1__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

RegionalExtension_10__2 = RegionalExtension_1__2
RegionalExtension_11__2 = RegionalExtension_1__2
RegionalExtension_12__2 = RegionalExtension_1__2
RegionalExtension_13__2 = RegionalExtension_1__2
RegionalExtension_14__2 = RegionalExtension_1__2
RegionalExtension_15__2 = RegionalExtension_1__2
RegionalExtension_16__2 = RegionalExtension_1__2
RegionalExtension_17__2 = RegionalExtension_1__2
RegionalExtension_18__2 = RegionalExtension_1__2
RegionalExtension_19__2 = RegionalExtension_1__2
RegionalExtension_2__2 = RegionalExtension_1__2
RegionalExtension_20__2 = RegionalExtension_1__2
RegionalExtension_21__2 = RegionalExtension_1__2
RegionalExtension_22__2 = RegionalExtension_1__2
RegionalExtension_23__2 = RegionalExtension_1__2
RegionalExtension_24__2 = RegionalExtension_1__2
RegionalExtension_25__2 = RegionalExtension_1__2
RegionalExtension_26__2 = RegionalExtension_1__2
RegionalExtension_27__2 = RegionalExtension_1__2
RegionalExtension_28__2 = RegionalExtension_1__2
RegionalExtension_29__2 = RegionalExtension_1__2
RegionalExtension_3__2 = RegionalExtension_1__2
RegionalExtension_30__2 = RegionalExtension_1__2
RegionalExtension_31__2 = RegionalExtension_1__2
RegionalExtension_32__2 = RegionalExtension_1__2
RegionalExtension_33__2 = RegionalExtension_1__2
RegionalExtension_35__2 = RegionalExtension_1__2
RegionalExtension_36__2 = RegionalExtension_1__2
RegionalExtension_37__2 = RegionalExtension_1__2
RegionalExtension_38__2 = RegionalExtension_1__2
RegionalExtension_39__2 = RegionalExtension_1__2
RegionalExtension_4__2 = RegionalExtension_1__2
RegionalExtension_41__2 = RegionalExtension_1__2
RegionalExtension_44__2 = RegionalExtension_1__2
RegionalExtension_45__2 = RegionalExtension_1__2
RegionalExtension_46__2 = RegionalExtension_1__2
RegionalExtension_47__2 = RegionalExtension_1__2
RegionalExtension_50__2 = RegionalExtension_1__2
RegionalExtension_51__2 = RegionalExtension_1__2
RegionalExtension_52__2 = RegionalExtension_1__2
RegionalExtension_54__2 = RegionalExtension_1__2
RegionalExtension_55__2 = RegionalExtension_1__2
RegionalExtension_56__2 = RegionalExtension_1__2
RegionalExtension_57__2 = RegionalExtension_1__2
RegionalExtension_58__2 = RegionalExtension_1__2
RegionalExtension_59__2 = RegionalExtension_1__2
RegionalExtension_6__2 = RegionalExtension_1__2
RegionalExtension_60__2 = RegionalExtension_1__2
RegionalExtension_61__2 = RegionalExtension_1__2
RegionalExtension_7__2 = RegionalExtension_1__2
RegionalExtension_8__2 = RegionalExtension_1__2
RegionalExtension_9__2 = RegionalExtension_1__2

class RegionalExtension_42:
    def __init__(self):
        self._comp_types = {"regionId" : RegionalExtension_42__1, "regExtValue" : RegionalExtension_42__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = None
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegionalExtension_42()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'regionId' in value:
            RegionalExtension_42__1.encode(encoding_rule, value['regionId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'regExtValue' in value:
            RegionalExtension_42__2.encode(encoding_rule, value['regExtValue'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegionalExtension_42()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['regionId'] = RegionalExtension_42__1.decode(encoding_rule, stream, value_tracker)
        value['regExtValue'] = RegionalExtension_42__2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegionalExtension_42()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'regionId' in value:
            RegionalExtension_42__1.validate(value['regionId'], errors, '{}/{}'.format(comp_path ,'regionId'))
        elif 'regionId' not in value:
            report_missing_field(type(self).__name__, 'regionId', errors, comp_path)
        if 'regExtValue' in value:
            RegionalExtension_42__2.validate(value['regExtValue'], errors, '{}/{}'.format(comp_path ,'regExtValue'))
        elif 'regExtValue' not in value:
            report_missing_field(type(self).__name__, 'regExtValue', errors, comp_path)

        return errors

class RegionalExtension_42__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RegionalExtension-42.regExtValue"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = RegionalExtension_42__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded and value is not None and value_tracker.are_equivalent([2], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                LaneDataAttribute_addGrpB.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = RegionalExtension_42__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            if (not is_decoded and value_tracker.are_equivalent([2], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = LaneDataAttribute_addGrpB.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = RegionalExtension_42__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class RegionalExtension_43:
    def __init__(self):
        self._comp_types = {"regionId" : RegionalExtension_42__1, "regExtValue" : RegionalExtension_43__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = None
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegionalExtension_43()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'regionId' in value:
            RegionalExtension_42__1.encode(encoding_rule, value['regionId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'regExtValue' in value:
            RegionalExtension_43__2.encode(encoding_rule, value['regExtValue'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegionalExtension_43()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['regionId'] = RegionalExtension_42__1.decode(encoding_rule, stream, value_tracker)
        value['regExtValue'] = RegionalExtension_43__2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegionalExtension_43()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'regionId' in value:
            RegionalExtension_42__1.validate(value['regionId'], errors, '{}/{}'.format(comp_path ,'regionId'))
        elif 'regionId' not in value:
            report_missing_field(type(self).__name__, 'regionId', errors, comp_path)
        if 'regExtValue' in value:
            RegionalExtension_43__2.validate(value['regExtValue'], errors, '{}/{}'.format(comp_path ,'regExtValue'))
        elif 'regExtValue' not in value:
            report_missing_field(type(self).__name__, 'regExtValue', errors, comp_path)

        return errors

class RegionalExtension_43__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RegionalExtension-43.regExtValue"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = RegionalExtension_43__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded and value is not None and value_tracker.are_equivalent([2], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                MovementEvent_addGrpB.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = RegionalExtension_43__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            if (not is_decoded and value_tracker.are_equivalent([2], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = MovementEvent_addGrpB.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = RegionalExtension_43__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class RegionalExtension_48:
    def __init__(self):
        self._comp_types = {"regionId" : RegionalExtension_42__1, "regExtValue" : RegionalExtension_48__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = None
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegionalExtension_48()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'regionId' in value:
            RegionalExtension_42__1.encode(encoding_rule, value['regionId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'regExtValue' in value:
            RegionalExtension_48__2.encode(encoding_rule, value['regExtValue'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegionalExtension_48()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['regionId'] = RegionalExtension_42__1.decode(encoding_rule, stream, value_tracker)
        value['regExtValue'] = RegionalExtension_48__2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegionalExtension_48()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'regionId' in value:
            RegionalExtension_42__1.validate(value['regionId'], errors, '{}/{}'.format(comp_path ,'regionId'))
        elif 'regionId' not in value:
            report_missing_field(type(self).__name__, 'regionId', errors, comp_path)
        if 'regExtValue' in value:
            RegionalExtension_48__2.validate(value['regExtValue'], errors, '{}/{}'.format(comp_path ,'regExtValue'))
        elif 'regExtValue' not in value:
            report_missing_field(type(self).__name__, 'regExtValue', errors, comp_path)

        return errors

class RegionalExtension_42__1:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "{Set}","permitted":[(0,255)]}},{"type":"simple table constraint","isExtensible": True,"fields":{"type":"single value","permitted": 2}}]
        self._unique_indetifier = "DSRC.RegionalExtension-42.regionId"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = RegionalExtension_42__1()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 255

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = RegionalExtension_42__1()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 255

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = RegionalExtension_42__1()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

RegionalExtension_43__1 = RegionalExtension_42__1
RegionalExtension_48__1 = RegionalExtension_42__1

class RegionalExtension_48__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RegionalExtension-48.regExtValue"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = RegionalExtension_48__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded and value is not None and value_tracker.are_equivalent([2], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                NodeOffsetPointXY_addGrpB.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = RegionalExtension_48__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            if (not is_decoded and value_tracker.are_equivalent([2], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = NodeOffsetPointXY_addGrpB.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = RegionalExtension_48__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class RegionalExtension_49:
    def __init__(self):
        self._comp_types = {"regionId" : RegionalExtension_49__1, "regExtValue" : RegionalExtension_49__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = None
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegionalExtension_49()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'regionId' in value:
            RegionalExtension_49__1.encode(encoding_rule, value['regionId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'regExtValue' in value:
            RegionalExtension_49__2.encode(encoding_rule, value['regExtValue'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegionalExtension_49()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['regionId'] = RegionalExtension_49__1.decode(encoding_rule, stream, value_tracker)
        value['regExtValue'] = RegionalExtension_49__2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegionalExtension_49()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'regionId' in value:
            RegionalExtension_49__1.validate(value['regionId'], errors, '{}/{}'.format(comp_path ,'regionId'))
        elif 'regionId' not in value:
            report_missing_field(type(self).__name__, 'regionId', errors, comp_path)
        if 'regExtValue' in value:
            RegionalExtension_49__2.validate(value['regExtValue'], errors, '{}/{}'.format(comp_path ,'regExtValue'))
        elif 'regExtValue' not in value:
            report_missing_field(type(self).__name__, 'regExtValue', errors, comp_path)

        return errors

class RegionalExtension_49__1:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "{Set}","permitted":[(0,255)]}},{"type":"simple table constraint","isExtensible": True,"fields":{"type":"constraint union","constraints":[{"type":"single value","permitted": 2},{"type":"single value","permitted": 3}]}}]
        self._unique_indetifier = "DSRC.RegionalExtension-49.regionId"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = RegionalExtension_49__1()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 255

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = RegionalExtension_49__1()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 255

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = RegionalExtension_49__1()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class RegionalExtension_49__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RegionalExtension-49.regExtValue"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = RegionalExtension_49__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded and value is not None and value_tracker.are_equivalent([2], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                Position3D_addGrpB.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([3], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                Position3D_addGrpC.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = RegionalExtension_49__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            if (not is_decoded and value_tracker.are_equivalent([2], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = Position3D_addGrpB.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([3], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = Position3D_addGrpC.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = RegionalExtension_49__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class RegionalExtension_53:
    def __init__(self):
        self._comp_types = {"regionId" : RegionalExtension_34__1, "regExtValue" : RegionalExtension_53__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = None
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegionalExtension_53()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'regionId' in value:
            RegionalExtension_34__1.encode(encoding_rule, value['regionId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'regExtValue' in value:
            RegionalExtension_53__2.encode(encoding_rule, value['regExtValue'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegionalExtension_53()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['regionId'] = RegionalExtension_34__1.decode(encoding_rule, stream, value_tracker)
        value['regExtValue'] = RegionalExtension_53__2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegionalExtension_53()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'regionId' in value:
            RegionalExtension_34__1.validate(value['regionId'], errors, '{}/{}'.format(comp_path ,'regionId'))
        elif 'regionId' not in value:
            report_missing_field(type(self).__name__, 'regionId', errors, comp_path)
        if 'regExtValue' in value:
            RegionalExtension_53__2.validate(value['regExtValue'], errors, '{}/{}'.format(comp_path ,'regExtValue'))
        elif 'regExtValue' not in value:
            report_missing_field(type(self).__name__, 'regExtValue', errors, comp_path)

        return errors

class RegionalExtension_53__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RegionalExtension-53.regExtValue"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = RegionalExtension_53__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded and value is not None and value_tracker.are_equivalent([3], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                RestrictionUserType_addGrpC.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = RegionalExtension_53__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            if (not is_decoded and value_tracker.are_equivalent([3], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = RestrictionUserType_addGrpC.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = RegionalExtension_53__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class PartIIcontent_1:
    def __init__(self):
        self._comp_types = {"partII-Id" : PartIIcontent_1__1, "partII-Value" : PartIIcontent_1__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = None
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = PartIIcontent_1()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'partII-Id' in value:
            PartIIcontent_1__1.encode(encoding_rule, value['partII-Id'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'partII-Value' in value:
            PartIIcontent_1__2.encode(encoding_rule, value['partII-Value'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = PartIIcontent_1()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['partII-Id'] = PartIIcontent_1__1.decode(encoding_rule, stream, value_tracker)
        value['partII-Value'] = PartIIcontent_1__2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = PartIIcontent_1()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'partII-Id' in value:
            PartIIcontent_1__1.validate(value['partII-Id'], errors, '{}/{}'.format(comp_path ,'partII-Id'))
        elif 'partII-Id' not in value:
            report_missing_field(type(self).__name__, 'partII-Id', errors, comp_path)
        if 'partII-Value' in value:
            PartIIcontent_1__2.validate(value['partII-Value'], errors, '{}/{}'.format(comp_path ,'partII-Value'))
        elif 'partII-Value' not in value:
            report_missing_field(type(self).__name__, 'partII-Value', errors, comp_path)

        return errors

class PartIIcontent_1__1:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "{Set}","permitted":[(0,63)]}},{"type":"simple table constraint","isExtensible": True,"fields":{"type":"constraint union","constraints":[{"type":"single value","permitted": 0},{"type":"single value","permitted": 1},{"type":"single value","permitted": 2}]}}]
        self._unique_indetifier = "DSRC.PartIIcontent-1.partII-Id"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = PartIIcontent_1__1()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 63

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = PartIIcontent_1__1()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 6
        data_map['width_value_unaligned'] = 6
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = False
        data_map['minimum'] = 0
        data_map['maximum'] = 63

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = PartIIcontent_1__1()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class PartIIcontent_1__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.PartIIcontent-1.partII-Value"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = PartIIcontent_1__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["partII-Id"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded and value is not None and value_tracker.are_equivalent([0], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                VehicleSafetyExtensions.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([1], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                SpecialVehicleExtensions.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            if (not is_encoded and value is not None and value_tracker.are_equivalent([2], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                SupplementalVehicleExtensions.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = PartIIcontent_1__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["partII-Id"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            if (not is_decoded and value_tracker.are_equivalent([0], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = VehicleSafetyExtensions.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([1], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = SpecialVehicleExtensions.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
            if (not is_decoded and value_tracker.are_equivalent([2], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = SupplementalVehicleExtensions.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = PartIIcontent_1__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class RegionalExtension_5:
    def __init__(self):
        self._comp_types = {"regionId" : RegionalExtension_34__1, "regExtValue" : RegionalExtension_5__2}
        self._def_vals = {}
        self._constraints = []
        self._unique_indetifier = None
        self._asn1Type = Asn1Type.SEQUENCE

    @staticmethod
    def encode(encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        seq_type = RegionalExtension_5()
        return seq_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: object, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        if not isinstance(value, object):
            raise TypeError("65201: The value class containing the value to be encoded does not match the type specified in the schema!")
        value_tracker.add_ancestor(value, self._def_vals)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        preamble_bits = [False for _ in range(data_map['num_optionals'])]
        extension_bits = [False for _ in range(data_map['num_extensions'])]

        is_extended = True if True in extension_bits else False

        if data_map['is_extensible']:
            preamble_bits.insert(0, True if is_extended else False)

        if len(preamble_bits) > 0:
            stream.encode_preamble(preamble_bits)

        if 'regionId' in value:
            RegionalExtension_34__1.encode(encoding_rule, value['regionId'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")
        if 'regExtValue' in value:
            RegionalExtension_5__2.encode(encoding_rule, value['regExtValue'], value_tracker, stream)
        else:
            value_tracker.remove_ancestor()
            raise ValueError("63803: A mandatory component is missing from the sequence or set value!")

        if is_extended:
            stream.encode_extension_bitmap(extension_bits)
        value_tracker.remove_ancestor()
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        seq_type = RegionalExtension_5()
        return seq_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> dict:
        value = {}
        data_map = {}
        value_tracker.add_ancestor(value)

        data_map['is_extensible'] = False
        data_map['num_extensions'] = 0
        data_map['num_optionals'] = 0

        length = data_map['num_optionals']

        if data_map['is_extensible']:
            length += 1

        preamble_bits = stream.decode_preamble(length)

        value['regionId'] = RegionalExtension_34__1.decode(encoding_rule, stream, value_tracker)
        value['regExtValue'] = RegionalExtension_5__2.decode(encoding_rule, stream, value_tracker)

        if len(self._def_vals) > 0:
            for key, val in self._def_vals.items():
                if key not in value:
                    value[key] = val

        value = value_tracker.execute_deferred(value)
        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        seq_type = RegionalExtension_5()
        return seq_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value: dict, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if not isinstance(value, dict):
            report_empty_value(value, type(self).__name__, errors, comp_path)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)
        if 'regionId' in value:
            RegionalExtension_34__1.validate(value['regionId'], errors, '{}/{}'.format(comp_path ,'regionId'))
        elif 'regionId' not in value:
            report_missing_field(type(self).__name__, 'regionId', errors, comp_path)
        if 'regExtValue' in value:
            RegionalExtension_5__2.validate(value['regExtValue'], errors, '{}/{}'.format(comp_path ,'regExtValue'))
        elif 'regExtValue' not in value:
            report_missing_field(type(self).__name__, 'regExtValue', errors, comp_path)

        return errors

class RegionalExtension_5__2:
    def __init__(self):
        self._constraints = []
        self._unique_indetifier = "DSRC.RegionalExtension-5.regExtValue"
        self._asn1Type = Asn1Type.OpenType
        self._type_constraint = None
        self._component_relation_constraint = None

    @staticmethod
    def encode(encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        open_type = RegionalExtension_5__2()
        return open_type.encode_value(encoding_rule, value, value_tracker, stream)

    def encode_value(self, encoding_rule: str, value: Any, value_tracker: dict, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        is_encoded = False
        data_map = {}

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'encode')
            tmpstream = func(encoding_rule, value, value_tracker)
            buffer = tmpstream.get_buffer()
            stream.write_octets_with_indefinite_length(buffer)
            return stream

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if ('default_discriminator' in data_map and len(discriminators) == 0):
            discriminators.append(data_map['default_discriminator'])

        if len(discriminators) > 0:
            if (not is_encoded and value is not None and value_tracker.are_equivalent([3], discriminators)):
                tmpstream = osspy.per.encodingstream(encoding_rule)
                MapData_addGrpC.encode(encoding_rule, value, value_tracker, tmpstream)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
        if not is_encoded:
            if (isinstance(value, dict) and '_unknown_encoding' in value):
                hex_value = bytearray.fromhex(value['_unknown_encoding'])
                stream.write_octets_with_indefinite_length(hex_value)
            elif value is None:
                tmpstream = osspy.per.encodingstream(encoding_rule)
                osspy.per.encode_null(tmpstream, value, **data_map)
                buffer = tmpstream.get_buffer()
                stream.write_octets_with_indefinite_length(buffer)
                is_encoded = True
            else:
                raise TypeError("63403: The types of the 'contained values' in the two open type values are not equivalent!")
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        open_type = RegionalExtension_5__2()
        return open_type.decode_value(encoding_rule, stream, value_tracker)

    def decode_value(self, encoding_rule: str, stream: osspy.per.decodingstream, value_tracker: dict) -> Any:
        buffer = None
        if value_tracker.deferred_context:
            buffer = stream.get_bytes()
        else:
            buffer = stream.read_octets_with_indefinite_length()

        is_decoded = False
        data_map = {}
        value = None

        if self._type_constraint is not None:
            func = getattr(self._type_constraint, 'decode')
            value = func(encoding_rule, buffer, value_tracker)
            return value

        data_map['discriminators'] = [(1,["regionId"])]
        data_map['max_depth'] = 1

        discriminators = value_tracker.get_selected_entities(data_map["discriminators"])

        if len(discriminators) > 0:
            if (not is_decoded and value_tracker.are_equivalent([3], discriminators)):
                try:
                    if value_tracker.deferred_context:
                        value_tracker.reset_context()
                    current_depth = value_tracker.depth
                    value = MapData_addGrpC.decode(encoding_rule, buffer, value_tracker)
                    is_decoded = True
                except:
                    value = None
                    is_decoded = True
                    value_tracker.depth = current_depth
        if (not is_decoded and len(buffer) > 0):
            value = {}
            if buffer.hex().upper() == '00':
                value['_unknown_encoding'] = '00'
            else:
                value['_unknown_encoding'] = buffer.hex().upper()

            if not value_tracker.deferred_context:
                value_tracker.add_deferred(data_map['max_depth'], {
                    'type': self,
                    'encoding': buffer,
                    'encoding_rule': encoding_rule,
                })

        if value_tracker.deferred_context:
            value_tracker.reset_context()

        return value

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        open_type = RegionalExtension_5__2()
        return open_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if (value is not None and len(self._constraints) > 0):
            validate_value(value, self._constraints, comp_path, errors)

        return errors

class RegionalExtension_1__1:
    def __init__(self):
        self._constraints = [{"type":"subtype constraint","root expression":{"type":"value range","definition": "{Set}","permitted":[(0,255)]}},{"type":"simple table constraint","isExtensible": True,"fields":[]}]
        self._unique_indetifier = "DSRC.RegionalExtension-1.regionId"
        self._asn1Type = Asn1Type.INTEGER

    @staticmethod
    def encode(encoding_rule: str, value: int, _: dict, stream: osspy.per.encodingstream = None) -> osspy.per.encodingstream:
        if not isinstance(stream, osspy.per.encodingstream):
            stream = osspy.per.encodingstream(encoding_rule)

        simple_type = RegionalExtension_1__1()
        return simple_type.encode_value(value, stream)

    def encode_value(self, value: int, stream: osspy.per.encodingstream) -> osspy.per.encodingstream:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 255

        osspy.per.encode_integer(stream, value, **data_map)
        return stream

    @staticmethod
    def decode(encoding_rule: str, stream: osspy.per.decodingstream, _: dict) -> int:
        if not isinstance(stream, osspy.per.decodingstream):
            stream = osspy.per.decodingstream(stream, encoding_rule)

        simple_type = RegionalExtension_1__1()
        return simple_type.decode_value(encoding_rule, stream)

    def decode_value(self, _: str, stream: osspy.per.decodingstream) -> int:
        data_map = {}

        data_map['has_extensible_value'] = False
        data_map['width_value_aligned'] = 8
        data_map['width_value_unaligned'] = 8
        data_map['width_length'] = None
        data_map['align_length'] = False
        data_map['align_value'] = True
        data_map['minimum'] = 0
        data_map['maximum'] = 255

        return osspy.per.decode_integer(stream, **data_map)

    @staticmethod
    def validate(value, errors: list, comp_path: str = '') -> list:
        simple_type = RegionalExtension_1__1()
        return simple_type.validate_instance(value, errors, comp_path)

    def validate_instance(self, value, errors: list, comp_path: str) -> list:
        validate_value_type(value, comp_path, errors, self._asn1Type)

        if len(self._constraints) > 0:
            validate_value(value, self._constraints, comp_path, errors)

        return errors

RegionalExtension_10__1 = RegionalExtension_1__1
RegionalExtension_11__1 = RegionalExtension_1__1
RegionalExtension_12__1 = RegionalExtension_1__1
RegionalExtension_13__1 = RegionalExtension_1__1
RegionalExtension_14__1 = RegionalExtension_1__1
RegionalExtension_15__1 = RegionalExtension_1__1
RegionalExtension_16__1 = RegionalExtension_1__1
RegionalExtension_17__1 = RegionalExtension_1__1
RegionalExtension_18__1 = RegionalExtension_1__1
RegionalExtension_19__1 = RegionalExtension_1__1
RegionalExtension_2__1 = RegionalExtension_1__1
RegionalExtension_20__1 = RegionalExtension_1__1
RegionalExtension_21__1 = RegionalExtension_1__1
RegionalExtension_22__1 = RegionalExtension_1__1
RegionalExtension_23__1 = RegionalExtension_1__1
RegionalExtension_24__1 = RegionalExtension_1__1
RegionalExtension_25__1 = RegionalExtension_1__1
RegionalExtension_26__1 = RegionalExtension_1__1
RegionalExtension_27__1 = RegionalExtension_1__1
RegionalExtension_28__1 = RegionalExtension_1__1
RegionalExtension_29__1 = RegionalExtension_1__1
RegionalExtension_3__1 = RegionalExtension_1__1
RegionalExtension_30__1 = RegionalExtension_1__1
RegionalExtension_31__1 = RegionalExtension_1__1
RegionalExtension_32__1 = RegionalExtension_1__1
RegionalExtension_33__1 = RegionalExtension_1__1
RegionalExtension_35__1 = RegionalExtension_1__1
RegionalExtension_36__1 = RegionalExtension_1__1
RegionalExtension_37__1 = RegionalExtension_1__1
RegionalExtension_38__1 = RegionalExtension_1__1
RegionalExtension_39__1 = RegionalExtension_1__1
RegionalExtension_4__1 = RegionalExtension_1__1
RegionalExtension_41__1 = RegionalExtension_1__1
RegionalExtension_44__1 = RegionalExtension_1__1
RegionalExtension_45__1 = RegionalExtension_1__1
RegionalExtension_46__1 = RegionalExtension_1__1
RegionalExtension_47__1 = RegionalExtension_1__1
RegionalExtension_50__1 = RegionalExtension_1__1
RegionalExtension_51__1 = RegionalExtension_1__1
RegionalExtension_52__1 = RegionalExtension_1__1
RegionalExtension_54__1 = RegionalExtension_1__1
RegionalExtension_55__1 = RegionalExtension_1__1
RegionalExtension_56__1 = RegionalExtension_1__1
RegionalExtension_57__1 = RegionalExtension_1__1
RegionalExtension_58__1 = RegionalExtension_1__1
RegionalExtension_59__1 = RegionalExtension_1__1
RegionalExtension_6__1 = RegionalExtension_1__1
RegionalExtension_60__1 = RegionalExtension_1__1
RegionalExtension_61__1 = RegionalExtension_1__1
RegionalExtension_7__1 = RegionalExtension_1__1
RegionalExtension_8__1 = RegionalExtension_1__1
RegionalExtension_9__1 = RegionalExtension_1__1
